{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kotest is a flexible and comprehensive testing project for Kotlin with multiplatform support. For latest updates see Changelog . See our quick start guide to get up and running. Community Stack Overflow (don't forget to use the tag \"kotest\".) Kotest channel in the Kotlin Slack (get an invite here ) Contribute Test with Style Write simple and beautiful tests with the StringSpec style: class MyTests : StringSpec({ \"length should return size of string\" { \"hello\".length shouldBe 5 } \"startsWith should test for a prefix\" { \"world\" should startWith(\"wor\") } }) Kotest comes with several testing styles so you can choose one that fits your needs. Multitude of Matchers Use over 300 provided matchers to test assertions on many different types: \"substring\".shouldContain(\"str\") user.email.shouldBeLowerCase() myImageFile.shouldHaveExtension(\".jpg\") cityMap.shouldContainKey(\"London\") The withClue and asClue helpers can add extra context to assertions so failures are self explanatory: withClue(\"Name should be present\") { user.name shouldNotBe null } data class HttpResponse(val status: Int, body: String) val response = HttpResponse(200, \"the content\") response.asClue { it.status shouldBe 200 it.body shouldBe \"the content\" } Nesting is allowed in both cases and will show all available clues. Matchers are extension methods and so your IDE will auto complete. See the full list of matchers or write your own. Let the Computer Generate Your Test Data Use property based testing to test your code with automatically generated test data: class PropertyExample: StringSpec({ \"String size\" { checkAll<String, String> { a, b -> (a + b) shouldHaveLength a.length + b.length } } }) Check all the Tricky Cases With Data Driven Testing Handle even an enormous amount of input parameter combinations easily with data driven tests : class StringSpecExample : StringSpec({ \"maximum of two numbers\" { forAll( row(1, 5, 5), row(1, 0, 1), row(0, 0, 0) ) { a, b, max -> Math.max(a, b) shouldBe max } } }) Test Exceptions Testing for exceptions is easy with Kotest: val exception = shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } exception.message should startWith(\"Something went wrong\") Fine Tune Test Execution You can specify the number of invocations, parallelism, and a timeout for each test or for all tests. And you can group tests by tags or disable them conditionally. All you need is config : class MySpec : StringSpec({ \"should use config\".config(timeout = 2.seconds, invocations = 10, threads = 2, tags = setOf(Database, Linux)) { // test here } }) And More ... This page gives you just a short overview of Kotest. There are many more features: Test whole collections with Inspectors . Write elegant conditions with the matcher DSL : \"hello\".shouldHaveSubstring(\"ell\") . Reuse test logic for setup or tear down, with Listeners . Test non-deterministic code with eventually or continually Let Kotest close resources automatically : val reader = autoClose(StringReader(\"xyz\")) Create reusable parameterized tests via test factories Handle tricky scenarios such as System Environment with extensions Use the Spring extension to automatically inject your spring test classes. Test Arrow data types with the Arrow extension. Make use of custom plugins for integrations with tools such as Pitest Read more about Kotest from third party blogs and articles .","title":"Welcome"},{"location":"#_1","text":"Kotest is a flexible and comprehensive testing project for Kotlin with multiplatform support. For latest updates see Changelog . See our quick start guide to get up and running.","title":""},{"location":"#community","text":"Stack Overflow (don't forget to use the tag \"kotest\".) Kotest channel in the Kotlin Slack (get an invite here ) Contribute","title":"Community"},{"location":"#test-with-style","text":"Write simple and beautiful tests with the StringSpec style: class MyTests : StringSpec({ \"length should return size of string\" { \"hello\".length shouldBe 5 } \"startsWith should test for a prefix\" { \"world\" should startWith(\"wor\") } }) Kotest comes with several testing styles so you can choose one that fits your needs.","title":"Test with Style"},{"location":"#multitude-of-matchers","text":"Use over 300 provided matchers to test assertions on many different types: \"substring\".shouldContain(\"str\") user.email.shouldBeLowerCase() myImageFile.shouldHaveExtension(\".jpg\") cityMap.shouldContainKey(\"London\") The withClue and asClue helpers can add extra context to assertions so failures are self explanatory: withClue(\"Name should be present\") { user.name shouldNotBe null } data class HttpResponse(val status: Int, body: String) val response = HttpResponse(200, \"the content\") response.asClue { it.status shouldBe 200 it.body shouldBe \"the content\" } Nesting is allowed in both cases and will show all available clues. Matchers are extension methods and so your IDE will auto complete. See the full list of matchers or write your own.","title":"Multitude of Matchers"},{"location":"#let-the-computer-generate-your-test-data","text":"Use property based testing to test your code with automatically generated test data: class PropertyExample: StringSpec({ \"String size\" { checkAll<String, String> { a, b -> (a + b) shouldHaveLength a.length + b.length } } })","title":"Let the Computer Generate Your Test Data"},{"location":"#check-all-the-tricky-cases-with-data-driven-testing","text":"Handle even an enormous amount of input parameter combinations easily with data driven tests : class StringSpecExample : StringSpec({ \"maximum of two numbers\" { forAll( row(1, 5, 5), row(1, 0, 1), row(0, 0, 0) ) { a, b, max -> Math.max(a, b) shouldBe max } } })","title":"Check all the Tricky Cases With Data Driven Testing"},{"location":"#test-exceptions","text":"Testing for exceptions is easy with Kotest: val exception = shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } exception.message should startWith(\"Something went wrong\")","title":"Test Exceptions"},{"location":"#fine-tune-test-execution","text":"You can specify the number of invocations, parallelism, and a timeout for each test or for all tests. And you can group tests by tags or disable them conditionally. All you need is config : class MySpec : StringSpec({ \"should use config\".config(timeout = 2.seconds, invocations = 10, threads = 2, tags = setOf(Database, Linux)) { // test here } })","title":"Fine Tune Test Execution"},{"location":"#and-more","text":"This page gives you just a short overview of Kotest. There are many more features: Test whole collections with Inspectors . Write elegant conditions with the matcher DSL : \"hello\".shouldHaveSubstring(\"ell\") . Reuse test logic for setup or tear down, with Listeners . Test non-deterministic code with eventually or continually Let Kotest close resources automatically : val reader = autoClose(StringReader(\"xyz\")) Create reusable parameterized tests via test factories Handle tricky scenarios such as System Environment with extensions Use the Spring extension to automatically inject your spring test classes. Test Arrow data types with the Arrow extension. Make use of custom plugins for integrations with tools such as Pitest Read more about Kotest from third party blogs and articles .","title":"And More ..."},{"location":"assertions/","text":"Assertions Kotest is split into several subprojects which can be used independently. One of these subprojects is the comprehensive assertion / matchers support. These can be used with the Kotest test framework, or with another test framework like JUnit or Spock. Matchers The core functionality of the assertion modules is without doubt the statements that confirm that your test is in the state you expect. For example, to assert that a variable has an expected value: name shouldBe \"sam\" Kotest calls these functions matchers . There are general purpose matchers, such as shouldBe as well as matchers for many other specific scenarios, such as str.shouldHaveLength(10) and file.shouldBeDirectory() . They come in both infix and regular variants. There are over 325 matchers spread across multiple modules. Read about all the matchers here . Custom Matchers It is easy to add your own matchers. Simply extend the Matcher<T> interface, where T is the type you wish to match against. The Matcher interface specifies one method, test , which you must implement returning an instance of Result. The Result contains a boolean to indicate if the test passed or failed, and two messages. interface Matcher<in T> { fun test(value: T): MatcherResult } Matcher is contravariant so a matcher for Number can be used to test an Int, for example. The first message should always be in the positive, ie, indicate what \"should\" happen, and the second message is used when the matcher is used with not . For example to create a matcher that checks that a string contains the substring \"foo\", we can do the following: fun containFoo() = object : Matcher<String> { override fun test(value: String) = MatcherResult(value.contains(\"foo\"), \"String $value should include foo\", \"String $value should not include foo\") } This matcher could then be used as follows: \"hello foo\" should containFoo() \"hello bar\" shouldNot containFoo() And we should then create an extension function version, like this: fun String.shouldContainFoo() = this should containFoo() fun String.shouldNotContainFoo() = this shouldNot containFoo() Exceptions To assert that a given block of code throws an exception, one can use the shouldThrow function. Eg, shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } You can also check the caught exception: val exception = shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } exception.message should startWith(\"Something went wrong\") If you want to test that exactly a type of exception is thrown, then use shouldThrowExactly<E> . If you want to test that any exception is thrown, then use shouldThrowAny . Soft Assertions Normally, assertions like shouldBe throw an exception when they fail. But sometimes you want to perform multiple assertions in a test, and would like to see all of the assertions that failed. Kotest provides the assertSoftly function for this purpose. assertSoftly { foo shouldBe bar foo should contain(baz) } If any assertions inside the block failed, the test will continue to run. All failures will be reported in a single exception at the end of the block. Another version of assertSoftly takes a test target and lambda with test target as its receiver. assertSoftly(foo) { shouldNotEndWith(\"b\") length shouldBe 3 } We can configure assert softly to be implicitly added to every test via project config . Inspectors Inspectors allow us to test elements in a collection, and assert the quantity of elements that should be expected to pass (all, none, exactly k and so on). For example mylist.forExactly(3) { it.city shouldBe \"Chicago\" } Read about inspectors here Clues Sometimes a failed assertion contains enough information in the error message to know what went wrong, and other times the failure just shows that two values didn't match up. For example, user.name shouldNotBe null If this failed, you would simply get: <null> should not equal <null> Which isn't particularly helpful. We can add extra context to failure messages through the use of clues . Assertion Mode If you are using Kotest framework alongside Kotest assertions, you can ask Kotest to fail the build, or output a warning to stderr, if a test is executed that does not execute an assertion. To do this, set assertionMode to AssertionMode.Error or AssertionMode.Warn inside a spec. For example. class MySpec : FunSpec() { init { assertions = AssertionMode.Error test(\"this test has no assertions\") { val name = \"sam\" name.length == 3 // this isn't actually testing anything } } } Running this test will output something like: Test 'this test has no assertions' did not invoke any assertions If we want to set this globally, we can do so in project config or via the system property kotest.framework.assertion.mode . Warning Assertion mode only works for Kotest assertions and not other assertion libraries.","title":"Assertions"},{"location":"assertions/#assertions","text":"Kotest is split into several subprojects which can be used independently. One of these subprojects is the comprehensive assertion / matchers support. These can be used with the Kotest test framework, or with another test framework like JUnit or Spock.","title":"Assertions"},{"location":"assertions/#matchers","text":"The core functionality of the assertion modules is without doubt the statements that confirm that your test is in the state you expect. For example, to assert that a variable has an expected value: name shouldBe \"sam\" Kotest calls these functions matchers . There are general purpose matchers, such as shouldBe as well as matchers for many other specific scenarios, such as str.shouldHaveLength(10) and file.shouldBeDirectory() . They come in both infix and regular variants. There are over 325 matchers spread across multiple modules. Read about all the matchers here .","title":"Matchers"},{"location":"assertions/#custom-matchers","text":"It is easy to add your own matchers. Simply extend the Matcher<T> interface, where T is the type you wish to match against. The Matcher interface specifies one method, test , which you must implement returning an instance of Result. The Result contains a boolean to indicate if the test passed or failed, and two messages. interface Matcher<in T> { fun test(value: T): MatcherResult } Matcher is contravariant so a matcher for Number can be used to test an Int, for example. The first message should always be in the positive, ie, indicate what \"should\" happen, and the second message is used when the matcher is used with not . For example to create a matcher that checks that a string contains the substring \"foo\", we can do the following: fun containFoo() = object : Matcher<String> { override fun test(value: String) = MatcherResult(value.contains(\"foo\"), \"String $value should include foo\", \"String $value should not include foo\") } This matcher could then be used as follows: \"hello foo\" should containFoo() \"hello bar\" shouldNot containFoo() And we should then create an extension function version, like this: fun String.shouldContainFoo() = this should containFoo() fun String.shouldNotContainFoo() = this shouldNot containFoo()","title":"Custom Matchers"},{"location":"assertions/#exceptions","text":"To assert that a given block of code throws an exception, one can use the shouldThrow function. Eg, shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } You can also check the caught exception: val exception = shouldThrow<IllegalAccessException> { // code in here that you expect to throw an IllegalAccessException } exception.message should startWith(\"Something went wrong\") If you want to test that exactly a type of exception is thrown, then use shouldThrowExactly<E> . If you want to test that any exception is thrown, then use shouldThrowAny .","title":"Exceptions"},{"location":"assertions/#soft-assertions","text":"Normally, assertions like shouldBe throw an exception when they fail. But sometimes you want to perform multiple assertions in a test, and would like to see all of the assertions that failed. Kotest provides the assertSoftly function for this purpose. assertSoftly { foo shouldBe bar foo should contain(baz) } If any assertions inside the block failed, the test will continue to run. All failures will be reported in a single exception at the end of the block. Another version of assertSoftly takes a test target and lambda with test target as its receiver. assertSoftly(foo) { shouldNotEndWith(\"b\") length shouldBe 3 } We can configure assert softly to be implicitly added to every test via project config .","title":"Soft Assertions"},{"location":"assertions/#inspectors","text":"Inspectors allow us to test elements in a collection, and assert the quantity of elements that should be expected to pass (all, none, exactly k and so on). For example mylist.forExactly(3) { it.city shouldBe \"Chicago\" } Read about inspectors here","title":"Inspectors"},{"location":"assertions/#clues","text":"Sometimes a failed assertion contains enough information in the error message to know what went wrong, and other times the failure just shows that two values didn't match up. For example, user.name shouldNotBe null If this failed, you would simply get: <null> should not equal <null> Which isn't particularly helpful. We can add extra context to failure messages through the use of clues .","title":"Clues"},{"location":"assertions/#assertion-mode","text":"If you are using Kotest framework alongside Kotest assertions, you can ask Kotest to fail the build, or output a warning to stderr, if a test is executed that does not execute an assertion. To do this, set assertionMode to AssertionMode.Error or AssertionMode.Warn inside a spec. For example. class MySpec : FunSpec() { init { assertions = AssertionMode.Error test(\"this test has no assertions\") { val name = \"sam\" name.length == 3 // this isn't actually testing anything } } } Running this test will output something like: Test 'this test has no assertions' did not invoke any assertions If we want to set this globally, we can do so in project config or via the system property kotest.framework.assertion.mode . Warning Assertion mode only works for Kotest assertions and not other assertion libraries.","title":"Assertion Mode"},{"location":"autoclose/","text":"Closing resource automatically You can let Kotest close resources automatically after all tests have been run: class StringSpecExample : StringSpec() { val reader = autoClose(StringReader(\"xyz\")) init { \"your test case\" { // use resource reader here } } } Resources that should be closed this way must implement java.lang.AutoCloseable . Closing is performed in reversed order of declaration after the return of the last spec interceptor.","title":"Autoclose"},{"location":"autoclose/#closing-resource-automatically","text":"You can let Kotest close resources automatically after all tests have been run: class StringSpecExample : StringSpec() { val reader = autoClose(StringReader(\"xyz\")) init { \"your test case\" { // use resource reader here } } } Resources that should be closed this way must implement java.lang.AutoCloseable . Closing is performed in reversed order of declaration after the return of the last spec interceptor.","title":"Closing resource automatically"},{"location":"blogs/","text":"Blogs and Articles on Kotest These blogs and articles can be useful in addition to the official docs to show how people are using Kotest in the wild. Best Practices Unit Testing Kotlin by Phauer (2020) Testing Koin applications with Kotest by Kerooker (2020) Writing reusable tests with Kotest's test factory by Kerooker (2020) Testing a Spring Boot application with Kotest by Kerooker(2020) Data driven testing with Kotest by sksamuel (2020) Android Spec Testing by Zuhaib Ahmad (2019) Introducing the KotlinTest IntelliJ Plugin by sksamuel (2019) KotlinTest BehaviorSpec by Ben (2020) Kotlintest 3 release Android by Do u even code (2018) What's new in KotlinTest 3.2 and 3.3 by sksamuel (2019) KotlinTest and property-based testing by Biju Kunjummen (2017) Kotest migration guide by Pawe\u0142 Weselak (2020) Micronaut and KotlinTest by Ben (2020) Parameterized tests with Kotest (2020) Using Testcontainers with Micronaut and Kotest (2020)","title":"Blogs"},{"location":"blogs/#blogs-and-articles-on-kotest","text":"These blogs and articles can be useful in addition to the official docs to show how people are using Kotest in the wild. Best Practices Unit Testing Kotlin by Phauer (2020) Testing Koin applications with Kotest by Kerooker (2020) Writing reusable tests with Kotest's test factory by Kerooker (2020) Testing a Spring Boot application with Kotest by Kerooker(2020) Data driven testing with Kotest by sksamuel (2020) Android Spec Testing by Zuhaib Ahmad (2019) Introducing the KotlinTest IntelliJ Plugin by sksamuel (2019) KotlinTest BehaviorSpec by Ben (2020) Kotlintest 3 release Android by Do u even code (2018) What's new in KotlinTest 3.2 and 3.3 by sksamuel (2019) KotlinTest and property-based testing by Biju Kunjummen (2017) Kotest migration guide by Pawe\u0142 Weselak (2020) Micronaut and KotlinTest by Ben (2020) Parameterized tests with Kotest (2020) Using Testcontainers with Micronaut and Kotest (2020)","title":"Blogs and Articles on Kotest"},{"location":"changelog/","text":"Changelog 4.3.0 October 2020 - Blog Features: New data driven test DSL with data classes #1537 (framework) Option to strip whitespace from test names #1545 (framework) EnabledIf annotation for specs #1683 (framework) Propagate coroutine context to tests #1725 (framework) Option to suppress configuration dump #1742 (framework) Added severity attribute for TestCase #1746 (framework) Added kotest.framework.sourceref.disable option (framework) Make Engine dependency free #1748 (framework) Multi-line-string comparison for file contents #823 (assertions) New assertion: Iterator.shouldHaveNext() #1660 (assertions) New assertions: isEmpty / isDefined for java Optional #1661 (assertions) Non infix matchers should return this for easy chaining #1744 (assertions) Add property test module for kotlinx datetime #1679 (prop-testing) Add Gen.forNone #1636 (prop-testing) Arb should generate a single value #1754 (prop-testing) Adds an arbitrary to generate bigdecimal #1705 (prop-testing) Add steps and stack trace to allure, with full docs #460 (extensions) Added roboelectric extension to main build (extensions) Breaking Changes The kotest-extensions-junit5extensions module is now called kotest-extensions-junit5 4.2.6 October 2020 Bugfix: Fixed regression in shouldBe when using iterables/arrays #1707 #1727 Bugfix: Fix first failure in beforeTest blocks #1736 Bugfix: deprecate distinct #1730 Bugfix: Fixed the empty allure result for tests with the failed afterTest block #1724 Feature: Added per project listener for testcontainers #1731 4.2.5 September 2020 Bugfix: Fixed performance issue when using 1000s of tests in gradle #1693 Feature: Added matchers for pair / triple components 1694 Feature: Added shouldHaveNameWithoutExtension matcher for files and paths #1696 Improvement: Added koin lifecycle mode #1710 4.2.4 September 2020 Bugfix: Test time does not scale with number of tests #1685 Bugfix: Added spring listener lifecycle mode #1643 Bugfix: Fix and remove double negative in empty directory assertions Improvement: Duplicated test name exception should include test name #1686 Improvement: SpringListener to generate meaningful method names #1591 4.2.3 September 2020 Bugfix: Throwables of Error in the engine should be reported to test engine listeners Bugfix: Switched classgraph to api Bugfix: Make Set comparisons use .contains() instead of a linear search #1672 Bugfix: Change retry default delay to 1 #1670 Bugfix: removed 1.4 api usage from property tests Improvement: Allow retry to call suspend functions #1669 Improvement: Add matcher alias for Iterator have next #1664 Improvement: Add java.util.Optional matchers #1662 Improvement: Expand ktor matchers to the client libraries #1658 Improvement: Add forNone assertion #1654 Improvement: Arb and Exhaustive should be covariant #1653 Improvement: Remove the annoying executionError extra test in gradle #1655 Improvement: Added more helpful error message when spec instantiation fails Docs: Update Gradle dependencies docs removing unnecessary -jvm suffix #1650 Docs: MockServer extension documentation #1446 4.2.2 August 2020 Bugfix: Usage of a Kotlin 1.4 only method has been removed Bugfix: KotlinReflectionInternalError fixed on java enums #1611 Bugfix: Errors in a DiscoveryExtension were not propagated to output #1634 Bugfix: Tags specified via inline tags dsl were not being picked up #1642 Improvement: Updated output of some collection matchers to format an element per line #1380 4.2.1 August 2020 Feature: The assertion libraries are now also published for watchos, tvos, and ios in addition to the macos, windows, and linux targets previously. 4.2.0 August 2020 - Blog Feature: Kotest upgraded to use Kotlin 1.4.0 #1511 Feature: Allow multiple project configs to be detected and merged #1632 Feature: Allow case control in test's reports #1458 Feature: Use expression for tags instead of include/exclude #863 Feature: Add new scoped callbacks #1584 Feature: Support order annotation for SpecOrder #1593 Feature: Spec level overrides for timeout and invocation timeout #1551 Improvement: Added exhaustive only mode to property tests #1596 Improvement: Change instance of matchers to use generic contracts #1510 Improvement: Allow to disable SpringListener on final class warning #1573 Improvement: Bundle console runner with intellij plugin #1567 Improvement: Improved error message for map should contain when key present #1587 Improvement: Allow allure to be customizable #1527 Improvement: Use the SPDX compliant license identifier \"Apache-2.0\" in POM files #1517 Improvement: Use forAll(1) suspend parameters #1626 Bugfix: Running all tests in a package doesn't run tests in subpackages #1621 Bugfix: Can't run a single test method from Gradle 6.5 #1531 Bugfix: TestFactory listeners not executing on nested tests #1613 Bugfix: Disabling test execution with x-methods doesn't work with kotest-core-js #1623 Bugfix: NoSuchFileException when using kotest-extensions-junitxml with Gradle #1581 Bugfix: Non complete junit report when using FunSpec #999 Breaking Change: kotest-core module has been replaced with kotest-framework-api and kotest-framework-engine. Tools authors can depend on api only. Engine should be used for JS testing. For JVM testing, continue to use kotest-runner-junit5-jvm. 4.1.2 July 2020 Bugfix: Dkotest.tags.include= only takes into account @Tags #1536 sksamuel Bugfix: Ensure exhaustive isn't build with an empty list #1549 Cleidiano Oliveira Bugfix: Add concurrent spec runner and fix sequential spec runner #1547 sksamuel Bugfix: Take into account range for IntShrinker and LongShrinker #1535 sksamuel Feature: Support expressions for tags as an alternative to include/exclude #863 sksamuel Feature: Expand some matchers to Iterable #1538 Leonardo Colman Lopes Improvement: Add the ability to make parameter substitutions when executing http files #1560 Shane Lathrop Improvement: Added xGiven / xWhen / xThen options to Behavior spec #1534 sksamuel Improvement: Added nicer syntax for Test Containers sksamuel Improvement: Restore context to describe #1565 sksamuel Breaking Change: Updates method signature of assertSoftly to take object under test as argument Ashish Kumar Joy 4.1.1 June 2020 Bugfix: Issue with describe spec and the intellij plugin fixed #1528 Bugfix: Incorrect error message with Exhaustive's when under the min iteration count #1526 4.1.0 June 2020 - Blog Feature: The Kotest IntelliJ plugin has gone final. The plugin requires 4.1. or higher of Kotest. https://plugins.jetbrains.com/plugin/14080-kotest Feature: Highlight diff when comparing data classes #826 #1242 Feature: Improve error message in tolerance matchers #1230 Feature: Add Arb for (lat, long) #1304 Feature: Integration with Testcontainers #1353 Feature: x variants for Behavior / Feature / Expect spec #1383 Feature: Add property test global config with before / after prop test callbacks #1435 Feature: Parallel execution test cases in Spec #1362 Feature: Add variable.assertSoftly #1427 Feature: Coroutine helper for timeout #1447 Feature: Add timeout to apply to individual tests when invocations > 1 #1442 Feature: Add shouldExistInOrder matcher #1460 Feature: Added Arb.orNull #1414 Feature: Provide a way to remove test prefixes in the test output when using specs which use prefixes #1486 Feature: Adds shouldCompleteExceptionallyWith matcher #1454 Feature: Exhaustive.merge for two gens with a common supertype #1502 Improvement: Added Byte.shouldBeBetween(min, max) and Arb.bytes #1408 Improvement: Remove kotlintest aliases #1457 Improvement: Parent scopes are not coroutine scopes #1488 Improvement: isolation instead of isolationMode #1418 Improvement: Reflection equality improvements #1413 Improvement: Property tests should report exception of running shrunk input #1279 Improvement: Make beforeProject and afterProject as suspend function #1461 Improvement: Updated arb flat map to accept lists #1500 Improvement: Date generators should allow for specific dates to be selected #1354 Bugfix: Test cases with multiline names broken #1441 Bugfix: Before\\AfterProject catch only one Exception #1387 Bugfix: Arb.bind() calls the incorrect constructor #1487 Bugfix: Project config dump doesn't include enums properly #1379 Bugfix: Add Arb.choose that accepts weighted arbs #1499 Bugfix: Arb.list doesn't use ListShrinker #1493 4.0.6 June 2020 Bugfix: Dependencies of assertions-core are now included properly when not using junit runner #1425 Bugfix: checkAll would fail if exhaustive size was very large #1456 Bugfix: Show typeclass on java.nio.filePath would cause stack overflow #1313 4.0.5 April 2020 Bugfix: Focus mode would cause some nested tests to be ignored #1376 Bugfix: Arb.choice would include edgecases in the generated values #1406 Bugfix: Arb.int and Arb.long edgecases included values outside the specified ranged #1405 4.0.4 April 2020 Bugfix: Exceptions of type LinkageError , most commonly ExceptionInInitializerError were not being handled #1381 4.0.3 April 2020 Feature: Koin support now works for koin 2.1 #1357 Deprecation: String context is deprecated in ShouldSpec in favour of a context block. #1356 Improvement: Line breaks added to Collection.containExactly matcher #1380 Improvement: Tolerance matcher emits better failure message (including plus/minus values) #1230 Bugfix: Project config output now writes the correct values of test ordering and isolation mode #1379 Bugfix: Order of autoclose is restored to work like 3.4.x (was undefined in 4.0.x) #1384 Bugfix: Fix shouldContainExactly for arrays #1364 4.0.2 April 2020 Feature: Added filter and map to Exhaustives #1343 Feature: shouldBeInteger matcher using contracts #1315 Bugfix: Fixed issue with xdescribe in describe spec always being active Bugfix: Simple tags were using full class names rather than the simple name breaking backwards compatibility #1346 Improvement: Caching result of discovery for increased performance in maven #1325 Bugfix: Closing resources used in classgraph scan #1323 Bugfix: Fixed timeout for coroutine launched inside a test without its own scope #1345 Bugfix: Fix Arb.bind returning only the same value #1348 Bugfix: Restored usage of opentest4j assertions #1339 Bugfix: Fixed missing stacktrace in data driven testing #1336 Bugfix: Fixed Arb.instant always returning same value #1322 Bugfix: Added workaround for gradle 5 bugs. 4.0.1 March 2020 Improvement: Bumped kotlin to 1.3.71 Feature: Aded latlong Arb #1304 4.0.0 March 2020 The 4.0.0 release is a large release. With the project rename, the packages have changed and module names have changed. Major changes: The KotlinTest project is now multi-platform. This means most of the modules now require -jvm to be added if you are working server side JVM only. For example, io.kotlintest:kotlintest-runner-junit5 is now io.kotest:kotest-runner-junit5-jvm taking into account package name changes and the platform suffix. The main assertions library is now kotest-assertions-core and many new assertions (matchers) have been added. This changelog won't list them all. It is simpler to view the full list . The property test library has moved to a new module kotest-property and been reworked to include many new features. See new documentation here . The old property test classes are deprecated and will be removed in a future release. Many new property test generators have been added. The full list is here . Composable specs have been added in the form of Test Factories . Project config no longer requires placing in a special package name, but can be placed anywhere in the classpath . @Autoscan has been added for listeners and extensions. Added DSL version of test lifecycle callbacks . Minor changes. Feature: A new JSoup assertions module has been added. #1028 Feature: Stats matchers #851 Feature: Experimental Robolectric Support #926 Bugfix: shouldNotThrowAny return T instead of Unit #981 Internal: Removed dependency on Arrow to avoid version conflicts Feature: Project wide default test case config Feature: whenReady(f) has been replaced with f.whenReady which is coroutine enabled Feature: Alphabetic test case ordering Feature: All test callbacks are now coroutine enabled Feature: forEachAsClue Improvement: Support Koin 2.1.0 Improvement: Explicitly allow internal classes as specs Feature: Klock matcher support #1214 Feature: JDBC matcher support #1221 3.4.2 Bugfix: Enhances SpringListener to work correctly with all Spring's Listeners #950 3.4.1 Internal: Remove JUnit redeclarations #927 Feature: Add infix modifier to more Arrow matchers #921 Feature: BigDecimal range matchers #932 Feature: monotonically/strictly increasing/decreasing matcher #850 Feature: Fixes shouldBe and shouldNotBe comparison #913 Feature: Add overload to Ktor shouldHaveStatus matcher #914 Feature: Fail parent tests when child tests fail #935 3.4.0 Feature: Support for running tests with Koin #907 Feature: Global timeout option can be applied across all tests #858 Feature: Introduced await as a more feature rich version of eventually #888 #793 Feature: Array overloads for all matchers #904 Feature: Support Spring's Test Listeners #887 Feature: Limit Parallelism for some specs #786 Feature: Added new project listener #859 Feature: Change System extensions to support different modes #843 Feature: Print project configurations #841 #866 Feature: New date matcher variations for month, time units, day of week, etc #899 Feature: Multi line diff min line config option #706 Feature: Allow nested describe scope in DescribeSpec #905 Feature: Add matcher for Dates to ignore timezone #891 Feature: Reflection matchers #614 #894 Feature: Added string matchers for single line and size between #853 Feature: Added contracts and lambda variations of matchers for arrow types #802 #890 #834 Feature: Added matchers for LocalTime #889 Feature: Added Zoned and Offset date time variants of shouldBeToday #820 Feature: Add new throwable matchers #864 Feature: Added matchers for Result #836 #861 Feature: Added big decimal matchers #875 Feature: Added shouldBeSymbolicLink and shouldHaveParent matchers for files #871 Feature: Json Matchers from resources #873 Feature: Added shouldBeZero and shouldNotBeZero matcher for number types #819 #848 Feature: Added shouldContainFiles matcher for path #854 Feature: The URI matchers should also work on URLs. #818 Feature: Allow setting isolation mode in project config #842 Feature: Added containFileDeep File matcher #846 Feature: Implements SkipTestException #805 Feature: Implements Infinity and NaN Double Matchers #801 Feature: Add asClue helper function #784 Feature: Add infix map matchers using Pair #792 Feature: Add Short and Btyte primitive gens #773 Feature: Implement Gen.take(n) function #758 Feature: Implement Gen.next(predicate) function #759 Feature: Add support to change sizes of generated lists, sets, maps #757 Feature: Allow exclusion/inclusion tags at runtime #761 Bugfix: Added missing part of shouldHaveLength message #870 ) Bugfix: Updated json matchers to include actual json in the error Bugfix: Fix for before/after test listeners not failing tests #842 #865 Bugfix: Changed autoClose to accept an AutoCloseable #847 Bugfix: Fixed left vs right issue #612 Bugfix: Ensure specs that fail in initialisation fail a Maven build #832 Bugfix: Fixed test engine reporting when there is an exception in either the init block, beforeSpec or the afterSpec method #771 Internal: io.kotlintest.Result renamed to io.kotlintest.MatcherResult to avoid conflict with new Kotlin class kotlin.Result #898 3.3.0 Feature: Intellij Plugin now available! Feature: FunSpec now allows parent context blocks Feature: java.time between matcher ( #694 ) Feature: Constant 'now' listeners ( #693 ) Feature: PITest plugin ( #687 ) Feature: Spring mocking injection @MockBean @MockkBean ( #684 ) Feature: instanceOf and typeOf matchers to use the casted value ( #695 ) Feature: Digest Matchers #667 Feature: continually assertion function #643 Feature: Add project config option for assertSoftly #512 ( #655 ) Feature: Implement System Security Manager Extensions ( #640 ) Feature: Implement System Environment Extension ( #633 ) Feature: Implement shouldBeOneOf matcher and assertions ( #647 ) Feature: Add nullability matchers with Kotlin Contracts ( #602 ) ( #646 ) Feature: SystemProperty Test Helpers #524 ( #608 ) Feature: Timezone / Locale Extension #587 ( #609 ) Feature: Move extensions to Kotlintest-Extensions module ( #629 ) Feature: Provide range-based numeric generators and javax.time generators #530 ( #543 ) Feature: Extended word spec ( #635 ) Feature: Implement shouldNotThrow matchers ( #603 ) Improvement: Make \"condensed\" multi-line diffs configurable #607 Improvement: Allow Arrow Either extensions to support nullable types ( #613 ) Improvement: Enables test bang on all specs ( #606 ) Improvement: Add property testing extensions for custom generators ( #506 ) Improvement: Added issue flag in config #525 Bugfix: Added support for package selectors from junit discovery requests #597 Bugfix: Disabled top level tests are not marked as ignored in JUnit #656 Bugfix: Fix containOnlyOnce which return true when no occurrence ( #660 ) Internal: Auto deploy snapshot on each travis build Internal: Remove all deprecated matchers/assertions ( #653 ) 3.2.1 Feature: AnnotationSpec now has a expected exception configuration #527 #559 Feature: BehaviorSpec gained extra nesting possibilities, with And between any other keywords #562 #593 Bugfix: Independent tests were sharing a thread, and one test could timeout a different one for apparently no reason #588 #590 Improvement: Documentation on TestConfig.invocations clarified #591 #592 3.2.0 Feature: Support for coroutines directly from tests #386 Feature: Isolation mode added to more finely control the instances in which tests execute #379 Feature: When re-running tests, execute previously failing specs first #388 Feature: Support for @Before and @After in AnnotationSpec for easier migration from JUnit #513 Feature: Support package selectors in discovery #461 Improvement: The test listeners have been reworked to make them more powerful and clearer #494 Improvement: Better support for multi-line string comparisions #402 Improvement: Gen.oneOf should be covariant #471 Improvement: Double should have oppostive matchers for shouldBePositive and shouldBeNegative #435 Improvement: New matchers #393 #325 Bugfix: BehaviorSpec doesn't allow config bug #495 Bugfix: Error when throwing AssertionError from inside a shouldThrow{} block #479 Bugfix: Fix test timeouts #476 Bugfix: Fix annotation spec failure message #539 Internal: Build now uses Kotlin 1.3 #379 Internal: Upgraded class scanning to use ClassGraph instead of Reflections #459 3.1.11 Feature: Infix support to String matchers #443 Feature: Infix support to files, floats, sequences, types and uri matchers #445 Feature: Infix support to Double matchers #429 Feature: Infix suport to Map matchers #417 Feature: shouldNotBePositive and shouldNotBeNegative for Double matchers #435 Feature: Support for Duration in time matchers #423 Feature: arrow-assertion Failure matcher that checks underlying throwable equality #427 Feature: shouldNotBeTrue and shouldNotBeFalse for Boolean matchers #452 Improvement: Documentation for Gen.int() #419 Improvement: Javadocs for Date matchers #420 Improvement: Better error message for empty collection in matchers #438 Improvement: Better stacktrace filtering from Failures class #465 Bugfix: Double matcher shouldNotBeExactly had the wrong implementation #432 Bugfix: Single-thread test had before and after running in separate thread from the test #447 Bugfix: Test with invocations > 1 wouldn't complete if test failed #413 Bugfix: Wrong assertion on shouldThrow #479 #484 3.1.10 Feature: Infix version of some inline matchers, eg date1 shouldHaveSameYearAs date2 ( #404 #407 #409 ) Feature: Infix support for int and long matchers ( #400 ) Feature: Added startsWith/endsWith matchers on collections ( #393 ) Improvement: Use unambiguous representations in collection matchers ( #392 ) Improvement: Collection matchers now work on Sequence too ( #391 ) Improvement: Added shouldThrowUnit variant of shouldThrow ( #387 ) Fix: shouldBe on arrays without static type ( #397 ) 3.1.9 Feature: Add soft assertions ( #373 ) Feature: sortedWith (and related) matchers. ( #383 ) Improvement: Removed unnecessary Comparable<T> upper-bound from sortedWith matchers. ( #389 ) Improvement: Improve StringShrinker algorithm ( #377 ) Bugfix: shouldBeBetween should be shouldBe instead of shouldNotBe ( #390 ) Bugfix: Fix beLeft is comparing against Either.Right instead of Either.Left ( #374 ) Internal: Naming executor services for jmx monitoring 3.1.8 Bugfix: Skip tests when MethodSelector is set #367 (means can run a single test in intellij) Bugfix: Fix error when running single test in kotlintest-tests ( #371 ) Bugfix Fix table testing forNone and Double between matcher ( #372 ) Improvement: Remove matcher frames from stacktraces ( #369 ) Improvement: Use less ambiguous string representations in equality errors ( #368 ) Improvement: Improve String equality error messages ( #366 ) Internal: Update kotlin to 1.2.50 ( #365 ) 3.1.7 Feature: Added Int/Long.shouldBeNegative and Int/Long.shouldBePositive matchers #325 Feature: Added Double.shouldBeNegative and Double.shouldBePositive matchers #325 Feature: Added collection.shouldBeLargerThan(c), collection.shouldBeSmallerThan(c), collection.shouldBeSameSizeAs(c) #325 Feature: Added collection.shouldHaveAtLeastSize(n) and collection.shouldHaveAtMostSize(n) matchers. Feature: Added matcher for uri.opaque Feature: Add matchers containsExactly and containsExactlyInAnyOrder ( #360 ) Feature: Added test case filters Bugfix: Running single tests with Gradle command line #356 Change: Removed coroutine support until it is no longer experimental Improvement: Optimize sorted matcher ( #359 ) Improvement: Allow type matchers to match nullable values. ( #358 ) Improvement: Allow nullable receivers for string matchers. ( #352 ) Improvement: Run tests for all rows in a table, even after errors. ( #351 ) 3.1.6 Specs now support co-routines #332 Extension function version of inspectors. Inspectors for arrow NonEmptyLists New style of data driven tests with parameter name detection Extension function style of assert all for property testing Updated string matchers to show better error when input is null or empty string Allow nullable arguments to more matcher functions. #350 Added extension functions for table tests #349 3.1.5 Fix for bug in gradle which doesn't support parallel test events Bring back Duration extension properties #343 Added fix for gradle 4.7 issues #336 shouldBe does not handle java long #346 Fixing function return type in documentation for forAll() ( #345 ) Fixing typos in reference.md ( #344 ) Make the Table & Row data classes covariant ( #342 ) Fixing argument names in ReplaceWith of deprecated matchers ( #341 ) 3.1.4 Fix eventually nanos conversion ( #340 ) Improve array shouldBe overloads ( #339 ) 3.1.3 Added workaround for gradle 4.7/4.8 error #336 Fix URI path and URI parameter matchers ( #338 ) 3.1.2 Added arrow NonEmptyList isUnique matchers Added Float and List Shrinker Added inspecting and extracting helper functions. ( #334 ) Allow tags to be added to specs for all test cases #333 Support randomized order of top level tests #328 3.1.1 Focus option for top level tests #329 Improve shrinkage #331 Updated readme for custom generators #313 Added generator for UUIDs Fixed bug with auto-close not being called. Deprecated ProjectExtension in favour of TestListener. Added a couple of edge case matchers to the arrow extension; added arrow matchers for lists. Version 3.1.0 Simplified Setup In KotlinTest 3.1.x it is sufficent to enable JUnit in the test block of your gradle build instead of using the gradle junit plugin. This step is the same as for any test framework that uses the JUnit Platform. Assuming you have gradle 4.6 or above, then setup your test block like this: test { useJUnitPlatform() } You can additionally enable extra test logging: test { useJUnitPlatform() testLogging { events \"FAILED\", \"SKIPPED\", \"STANDARD_OUT\", \"STANDARD_ERROR\" } } Instance Per Test for all Specs In the 3.0.x train, the ability to allow an instance per test was removed from some spec styles due to implementation difficulties. This has been addressed in 3.1.x and so all spec styles now allow instance per test as in the 2.0.x releases. Note: The default value is false, so tests will use a single shared instance of the spec for all tests unless the isInstancePerTest() function is overriden to return true. Breaking Change: Config Syntax The syntax for config has now changed. Instead of a function call after the test has been defined, it is now specified after the name of the test. So, instead of: \"this is a test\" { }.config(...) You would now do: \"this is a test\".config(...) { } Matchers as extension functions All matchers can now be used as extension functions. So instead of: file should exist() or listOf(1, 2) should containNull() You can do: file.shouldExist() or listOf(1, 2).shouldContainNull() Note: The infix style is not deprecated and will be supported in future releases, but the extension function is intended to be the preferred style moving forward as it allows discovery in the IDE. Dozens of new Matchers even and odd Tests that an Int is even or odd: 4 should beEven() 3 shouldNot beEven() 3 should beOdd() 4 shouldNot beOdd() beInRange Asserts that an int or long is in the given range: 3 should beInRange(1..10) 4 should beInRange(1..3) haveElementAt Checks that a collection contains the given element at a specified index: listOf(\"a\", \"b\", \"c\") should haveElementAt(1, \"b\") listOf(\"a\", \"b\", \"c\") shouldNot haveElementAt(1, \"c\") Help out the type inferrer when using nulls: listOf(\"a\", \"b\", null) should haveElementAt<String?>(2, null) readable , writeable , executable and hidden Tests if a file is readable, writeable, or hidden: file should beRadable() file should beWriteable() file should beExecutable() file should beHidden() absolute and relative Tests if a file's path is relative or absolute. File(\"/usr/home/sam\") should beAbsolute() File(\"spark/bin\") should beRelative() startWithPath(path) Tests if a file's path begins with the specified prefix: File(\"/usr/home/sam\") should startWithPath(\"/usr/home\") File(\"/usr/home/sam\") shouldNot startWithPath(\"/var\") haveSameHashCodeAs(other) Asserts that two objects have the same hash code. obj1 should haveSameHashCodeAs(obj2) \"hello\" shouldNot haveSameHashCodeAs(\"world\") haveSameLengthAs(other) Asserts that two strings have the same length. \"hello\" should haveSameLengthAs(\"world\") \"hello\" shouldNot haveSameLengthAs(\"you\") haveScheme, havePort, haveHost, haveParameter, havePath, haveFragment Matchers for URIs: val uri = URI.create(\"https://localhost:443/index.html?q=findme#results\") uri should haveScheme(\"https\") uri should haveHost(\"localhost\") uri should havePort(443) uri should havePath(\"/index.html\") uri should haveParameter(\"q\") uri should haveFragment(\"results\") Date matchers - before / after / haveSameYear / haveSameDay / haveSameMonth / within Collections - containNull, containDuplicates Futures - completed, cancelled String - haveLineCount, contain(regex) Types - haveAnnotation(class) Arrow matcher module A new module has been added which includes matchers for Arrow - the popular and awesome functional programming library for Kotlin. To include this module add kotlintest-assertions-arrow to your build. The included matchers are: Option - Test that an Option has the given value or is a None . For example: val option = Option.pure(\"foo\") option should beSome(\"foo\") val none = None none should beNone() Either - Test that an Either is either a Right or Left . For example: Either.right(\"boo\") should beRight(\"boo\") Either.left(\"boo\") should beLeft(\"boo\") NonEmptyList - A collection (no pun intended) of matchers for Arrow's NonEmptyList . These mostly mirror the equivalent Collection matchers but for NELs. For example: NonEmptyList.of(1, 2, null).shouldContainNull() NonEmptyList.of(1, 2, 3, 4).shouldBeSorted<Int>() NonEmptyList.of(1, 2, 3, 3).shouldHaveDuplicates() NonEmptyList.of(1).shouldBeSingleElement(1) NonEmptyList.of(1, 2, 3).shouldContain(2) NonEmptyList.of(1, 2, 3).shouldHaveSize(3) NonEmptyList.of(1, 2, 3).shouldContainNoNulls() NonEmptyList.of(null, null, null).shouldContainOnlyNulls() NonEmptyList.of(1, 2, 3, 4, 5).shouldContainAll(3, 2, 1) Try - Test that a Try is either Success or Failure . Try.Success(\"foo\") should beSuccess(\"foo\") Try.Failure<Nothing>(RuntimeException()) should beFailure() Validation - Asserts that a Validation is either Valid or an Invalid Valid(\"foo\") should beValid() Invalid(RuntimeException()) should beInvalid() Generator Bind A powerful way of generating random class instances from primitive generators is to use the new bind function. A simple example is to take a data class of two fields, and then use two base generators and bind them to create random values of that class. data class User(val email: String, val id: Int) val userGen = Gen.bind(Gen.string(), Gen.positiveIntegers(), ::User) assertAll(userGen) { it.email shouldNotBe null it.id should beGreaterThan(0) } Property Testing: Classify When using property testing, it can be useful to see the distribution of values generated, to ensure you're getting a good spread of values and not just trival ones. For example, you might want to run a test on a String and you want to ensure you're getting good amounts of strings with whitespace. To generate stats on the distribution, use classify with a predicate, a label if the predicate passes, and a label if the predicate fails. For example: assertAll(Gen.string()) { a -> classify(a.contains(\" \"), \"has whitespace\", \"no whitespace\") // some test } And this will output something like: 63.70% no whitespace 36.30% has whitespace So we can see we're getting a good spread of both types of value. You don't have to include two labels if you just wish to tag the \"true\" case, and you can include more than one classification. For example: forAll(Gen.int()) { a -> classify(a == 0, \"zero\") classify(a % 2 == 0, \"even number\", \"odd number\") a + a == 2 * a } This will output something like: 51.60% even number 48.40% odd number 0.10% zero Property Testing: Shrinking Tag Extensions A new type of extension has been added called TagExtension . Implementations can override the tags() function defined in this interface to dynamically return the Tag instances that should be active at any moment. The existing system properties kotlintest.tags.include and kotlintest.tags.exclude are still valid and are not deprecated, but adding this new extension means extended scope for more complicated logic at runtime. An example might be to disable any Hadoop tests when not running in an environment that doesn't have the hadoop home env variable set. After creating a TagExtension it must be registered with the project config. object Hadoop : Tag() object HadoopTagExtension : TagExtension { override fun tags(): Tags = if (System.getenv().containsKey(\"HADOOP_HOME\")) Tags.include(Hadoop) else Tags.exclude(Hadoop) } object MyProjectConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = listOf(HadoopTagExtension) } object SimpleTest : StringSpec({ \"simple test\" { // this test would only run on environments that have hadoop configured }.config(tags = setOf(Hadoop)) }) Discovery Extensions: instantiate() Inside the DiscoveryExtension interface the function fun <T : Spec> instantiate(clazz: KClass<T>): Spec? has been added which allows you to extend the way new instances of Spec are created. By default, a no-args constructor is assumed. However, if this function is overridden then it's possible to support Spec classes which have other constructors. For example, the Spring module now supports constructor injection using this extension. Other use cases might be when you want to always inject some config class, or if you want to ensure that all your tests extend some custom interface or superclass. As a reminder, DiscoveryExtension instances are added to Project config. System out / error extensions An extension that allows you to test for a function that writes to System.out or System.err. To use this extension add the module kotlintest-extensions-system to your build. By adding the NoSystemOutListener or NoSystemErrListener to your config or spec classes, anytime a function tries to write to either of these streams, a SystemOutWriteException or SystemErrWriteException will be raised with the string that the function tried to write. This allows you to test for the exception in your code. For example: class NoSystemOutOrErrTest : StringSpec() { override fun listeners() = listOf(NoSystemOutListener, NoSystemErrListener) init { \"System.out should throw an exception when the listener is added\" { shouldThrow<SystemOutWriteException> { System.out.println(\"boom\") }.str shouldBe \"boom\" } \"System.err should throw an exception when the listener is added\" { shouldThrow<SystemErrWriteException> { System.err.println(\"boom\") }.str shouldBe \"boom\" } } } System.exit extension Another extension that is part of the kotlintest-extensions-system module. This extension will allow you to test if System.exit(Int) is invoked in a function. It achieves this by intercepting any calls to System.exit and instead of terminating the JVM, it will throw a SystemExitException with the exit code. For example: class SystemExitTest : StringSpec() { override fun listeners() = listOf(SpecSystemExitListener) init { \"System.exit should throw an exception when the listener is added\" { shouldThrow<SystemExitException> { System.exit(123) }.exitCode shouldBe 123 } } } Spring Module Updates The spring extension module kotlintest-extensions-spring has been updated to allow for constructor injection. This new extension is called SpringAutowireConstructorExtension and must be added to your `ProjectConfig. Then you can use injected dependencies directly in the primary constructor of your test class. For example: @ContextConfiguration(classes = [(Components::class)]) class SpringAutowiredConstructorTest(service: UserService) : WordSpec({ \"SpringListener\" should { \"have autowired the service\" { service.repository.findUser().name shouldBe \"system_user\" } } }) JUnit 4 Runner A JUnit 4 runner has been added which allows KotlinTest to run using the legacy JUnit 4 platform. To use this, add kotlintest-runner-junit4 to your build instead of kotlintest-runner-junit5 . Note: This is intended for use when junit5 cannot be used. It should not be the first choice as functionality is restricted. Namely: In intellij, test output will not be nested Project wide beforeAll/afterAll cannot be supported. Version 3.0.x - March 29 2018 Module split out KotlinTest has been split into multiple modules. These include core, assertions, the junit runner, and extensions such as spring, allure and junit-xml. The idea is that in a future release, further runners could be added (TestNG) or for JS support (once multi-platform Kotlin is out of beta). When upgrading you will typically want to add the kotlintest-core , kotlintest-assertions and kotlintest-runner-junit5 to your build rather than the old kotlintest module which is now defunct. When upgrading, you might find that you need to update imports to some matchers. testCompile 'io.kotlintest:kotlintest-core:3.0.0' testCompile 'io.kotlintest:kotlintest-assertions:3.0.0' testCompile 'io.kotlintest:kotlintest-runner-junit5:3.0.0' Gradle Users: Also you must include apply plugin: 'org.junit.platform.gradle.plugin' in your project and classpath \"org.junit.platform:junit-platform-gradle-plugin:1.1.0\" to the dependencies section of your buildscript or tests will not run (or worse, will hang). This allows gradle to execute jUnit-platform-5 based tests (which KotlinTest builds upon). Note: Gradle says that this is not required as of 4.6 but even with 4.6 it seems to be required. Maven users: You need to include the following in your plugins: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-surefire-plugin</artifactId> <version>2.19.1</version> <dependencies> <dependency> <groupId>org.junit.platform</groupId> <artifactId>junit-platform-surefire-provider</artifactId> <version>1.1.0</version> </dependency> </dependencies> </plugin> And you must include <dependency> <groupId>io.kotlintest</groupId> <artifactId>kotlintest-runner-junit5</artifactId> <version>${kotlintest.version}</version> <scope>test</scope> </dependency> as a regular dependency. Breaking: ProjectConfig Project wide config in KotlinTest is controlled by implementing a subclass of AbstractProjectConfig . In previous versions you could call this what you wanted, and place it where you wanted, and KotlinTest would attempt to find it and use it. This was the cause of many bug reports about project start up times and reflection errors. So in version 3.0.x onwards, KotlinTest will no longer attempt to scan the classpath. Instead you must call this class ProjectConfig and place it in a package io.kotlintest.provided . It must still be a subclass of AbstractProjectConfig This means kotlintest can do a simple Class.forName to find it, and so there is no startup penalty nor reflection issues. Project config now allows you to register multiple types of extensions and listeners, as well as setting parallelism. Breaking: Interceptors have been deprecated and replaced with Listeners The previous inteceptors were sometimes confusing. You had to invoke the continuation function or the spec/test would not execute. Not invoking the function didn't mean the spec/test was skipped, but that it would hang. So interceptors are deprecated, and in some places removed. Those are not removed are now located in classes called SpecExtension and TestCaseExtension and those interfaces should be used rather than functions directly. Here is an example of a migrated interceptor. val mySpecExtension = object : SpecExtension { override fun intercept(spec: Spec, process: () -> Unit) { println(\"Before spec!\") process() println(\"After spec!\") } } As a replacement, in 3.0.0 we've added the TestListener interface which is the more traditional before/after style callbacks. In addition, these methods include the result of the test (success, fail, error, skipped) which gives you more context in writing plugins. The TestListener interface offers everything the old interceptors could do, and more. Here is an example of a simple listener. object TimeTracker : TestListener { var started = 0L override fun beforeTest(description: Description) { TimeTrackerTest.started = System.currentTimeMillis() } override fun afterTest(description: Description, result: TestResult) { val duration = System.currentTimeMillis() - TimeTrackerTest.started println(\"Test ${description.fullName()} took ${duration}ms\") } } If you want to use these methods in a Spec itself, then you can just override the functions directly because a Spec is already a TestListener. object TimeTracker : WordSpec() { var started = 0L override fun beforeTest(description: Description) { started = System.currentTimeMillis() } override fun afterTest(description: Description, result: TestResult) { val duration = System.currentTimeMillis() - started println(\"Test ${description.fullName()} took ${duration}ms\") } init { \"some test\" should { \"be timed\" { // test here } } } } Listeners can be added project wide by overriding listeners() in the ProjectConfig . Note: In the next release, new Extension functions will be added which will be similar to the old interceptors, but with complete control over the lifecycle. For instance, a future intercept method will enforce that the user skip, run or abort a test in the around advice. They will be more complex, and so suited to more advanced use cases. The new TestListener interface will remain of course, and is the preferred option. Parallelism If you want to run more than one spec class in parallel, you can by overriding parallelism inside your projects ProjectConfig or by supplying the system property kotlintest.parallelism . Note the system property always takes precedence over the config. Futures Support Test cases now support waiting on futures in a neat way. If you have a value in a CompletableFuture that you want to test against once it completes, then you can do this like this: val stringFuture: CompletableFuture<String> = ... \"My future test\" should { \"support CompletableFuture<T>\" { whenReady(stringFuture) { it shouldBe \"wibble\" } } } Breaking: Exception Matcher Changes The shouldThrow<T> method has been changed to also test for subclasses. For example, shouldThrow<IOException> will also match exceptions of type FileNotFoundException . This is different to the behavior in all previous KotlinTest versions. If you wish to have functionality as before - testing exactly for that type - then you can use the newly added shouldThrowExactly<T> . JUnit XML Module Support for writing out reports in junit-format XML has added via the kotlintest-extensions-junitxml module which you will need to add to your build. This module provides a JUnitXmlListener which you can register with your project to autowire your tests. You can register this by overriding listeners() in ProjectConfig . class ProjectConfig : AbstractProjectConfig() { override fun listeners() = listOf(JUnitXmlListener) } Spring Module Spring support has been added via the kotlintest-extensions-spring module which you will need to add to your build. This module provides a SpringListener which you can register with your project to autowire your tests. You can register this for just some classes by overriding the listeners() function inside your spec, for example: class MySpec : ParentSpec() { override fun listeners() = listOf(SpringListener) } Or you can register this for all classes by adding it to the ProjectConfig . See the section on ProjectConfig for how to do this. Breaking: Tag System Property Rename The system property used to include/exclude tags has been renamed to kotlintest.tags.include and kotlintest.tags.exclude . Make sure you update your build jobs to set the right properties as the old ones no longer have any effect. If the old tags are detected then a warning message will be emitted on startup. New Matchers beInstanceOf<T> has been added to easily test that a class is an instance of T. This is in addition to the more verbose beInstanceOf(SomeType::class) . The following matchers have been added for maps: containAll , haveKeys , haveValues . These will output helpful error messages showing you which keys/values or entries were missing. New matchers added for Strings: haveSameLengthAs(other) , beEmpty() , beBlank() , containOnlyDigits() , containADigit() , containIgnoringCase(substring) , lowerCase() , upperCase() . New matchers for URIs: haveHost(hostname) , havePort(port) , haveScheme(scheme) . New matchers for collections: containNoNulls() , containOnlyNulls() Breaking: One instance per test changes One instance per test is no longer supported for specs which offer nested scopes . For example, WordSpec . This is because of the tricky nature of having nested closures work across fresh instances of the spec. When using one instance per test, a fresh spec class is required for each test, but that means selectively executing some closures and not others in order to ensure the correct state. This has proved the largest source of bugs in previous versions. KotlinTest 3.0.x takes a simplified approach. If you want the flexibilty to lay out your tests with nested scopes, then all tests will execute in the same instance (like Spek and ScalaTest). If you want each test to have it's own instance (like jUnit) then you can either split up your tests into multiple files, or use a \"flat\" spec like FunSpec or StringSpec . This keeps the implementation an order of magnitude simplier (and therefore less likely to lead to bugs) while offering a pragmatic approach to keeping both sets of fans happy. New Specs Multiple new specs have been added. These are: AnnotationSpec , DescribeSpec and ExpectSpec . Expect spec allows you to use the context and expect keywords in your tests, like so: class ExpectSpecExample : ExpectSpec() { init { context(\"some context\") { expect(\"some test\") { // test here } context(\"nested context even\") { expect(\"some test\") { // test here } } } } } The AnnotationSpec offers functionality to mimic jUnit, in that tests are simply functions annotated with @io.kotlintest.specs.Test . For example: class AnnotationSpecExample : AnnotationSpec() { @Test fun test1() { } @Test fun test2() { } } And finally, the DescribeSpec is similar to SpekFramework, using describe , and , and it . This makes it very useful for those people who are looking to migrate to KotlinTest from SpekFramework. class DescribeSpecExample : DescribeSpec() { init { describe(\"some context\") { it(\"test name\") { // test here } describe(\"nested contexts\") { and(\"another context\") { it(\"test name\") { // test here } } } } } } Property Testing with Matchers The ability to use matchers in property testing has been added. Previously property testing worked only with functions that returned a Boolean, like: \"startsWith\" { forAll(Gen.string(), Gen.string(), { a, b -> (a + b).startsWith(a) }) } But now you can use assertAll and assertNone and then use regular matchers inside the block. For example: \"startsWith\" { assertAll(Gen.string(), Gen.string(), { a, b -> a + b should startWith(a) }) } This gives you the ability to use multiple matchers inside the same block, and not have to worry about combining all possible errors into a single boolean result. Generator Edge Cases Staying with property testing - the Generator interface has been changed to now provide two types of data. The first are values that should always be included - those edge cases values which are common sources of bugs. For example, a generator for Ints should always include values like zero, minus 1, positive 1, Integer.MAX_VALUE and Integer.MIN_VALUE. Another example would be for a generator for enums. That should include all the values of the enum to ensure each value is tested. The second set of values are random values, which are used to give us a greater breadth of values tested. The Int generator should return random ints from across the entire integer range. Previously generators used by property testing would only include random values, which meant you were very unlikely to see the edge cases that usually cause issues - like the aforementioned Integer MAX / MIN. Now you are guaranteed to get the edge cases first and the random values afterwards. Breaking: MockitoSugar removed This interface added a couple of helpers for Mockito, and was used primarily before Kotlin specific mocking libraries appeared. Now there is little value in this mini-wrapper so it was removed. Simply add whatever mocking library you like to your build and use it as normal. CsvDataSource This class has been added for loading data for table testing. A simple example: class CsvDataSourceTest : WordSpec() { init { \"CsvDataSource\" should { \"read data from csv file\" { val source = CsvDataSource(javaClass.getResourceAsStream(\"/user_data.csv\"), CsvFormat()) val table = source.createTable<Long, String, String>( { it: Record -> Row3(it.getLong(\"id\"), it.getString(\"name\"), it.getString(\"location\")) }, { it: Array<String> -> Headers3(it[0], it[1], it[2]) } ) forAll(table) { a, b, c -> a shouldBe gt(0) b shouldNotBe null c shouldNotBe null } } } } } Matcher Negation Errors All matchers now have the ability to report a better error when used with shouldNot and shouldNotBe . Previously a generic error was generated - which was usually the normal error but with a prefix like \"NOT:\" but now each built in matcher will provide a full message, for example: Collection should not contain element 'foo' Version 2.0.0, released 2017-03-26 Closed Issues Added You can write tests alternatively into a lambda parameter in the class constructor, eg: class StringSpecExample : StringSpec({ \"strings.size should return size of string\" { \"hello\".length shouldBe 5 \"hello\" should haveLength(5) } }) Added forNone for table tests, eg val table = table( headers(\"a\", \"b\"), row(0L, 2L), row(2L, 2L), row(4L, 5L), row(4L, 6L) ) forNone(table) { a, b -> 3 shouldBe between(a, b) } Interceptors have been added. Interceptors allow code to be executed before and after a test. See the main readme for more info. Simplified ability to add custom matchers. Simple implement Matcher<T> interface. See readme for more information. Added shouldNot to invert matchers. Eg, \"hello\" shouldNot include(\"hallo\") Deprecated matchers which do not implement Matcher . Eg, should have substring(x) has been deprecated in favour of \"hello\" should include(\"l\") . This is because instances of Matcher can be combined with or and and and can be negated with shouldNot . Added between matcher for int and long, eg 3 shouldBe between(2, 5) Added singleElement matcher for collections, eg x shouldBe singleElement(y) Added sorted matcher for collections, eg listOf(1,2,3) shouldBe sorted<Int>() Now supports comparsion of arrays #116 Added Gen.oneOf to create a generator that returns one of the values for the given Enum class. Changed Tags are objects derived from Tag class now. Tags can now be included and/or exluded. It is no longer the case that all untagged tests are always executed. Fixed bugs with parenthesis breaking layout in Intellij #112 Removed FlatSpec was removed because it has an irregular syntax with config and is essentially the same as StringSpec, but more complicated. Deprecated method overloads with duration: Long, unit: TimeUnit expecting for testing exceptions (use shouldThrow now) Version 1.3.2, released 2016-07-05 Changed Added a shouldBe exactly(b) matcher for doubles kotlintest only pulls in mockito-core now instead of mockito-all Version 1.3.1, released 2016-07-03 Changed Bumped Kotlin version to 1.0.3 Version 1.3.0, released 2016-07-03 Closed Issues Added StringSpec. You can use simply use Strings as the basis for tests, eg: class StringSpecExample : StringSpec() { init { \"strings.size should return size of string\" { \"hello\".length shouldBe 5 \"hello\" should haveLength(5) } \"strings should support config\" { \"hello\".length shouldBe 5 }.config(invocations = 5) } } Table Tests. Tables allow you to manually specific combinations of values that should be used, and are useful for edge cases and other specific values you want to test. The headers are used for when values fail, the output can show you what inputs were used for what labels. An example of using a table consisting of two-value tuples: class TableExample : StringSpec(), TableTesting { init { \"numbers should be prime\" { val table = table( headers(\"a\", \"b\"), row(5, 5), row(4, 6), row(3, 7) ) forAll(table) { a, b -> a + b == 10 } } } } Property tests. Property tests automatically generate values for testings. You provide, or have KotlinTest provide for you, generators , which will generate a set of values and the unit test will be executed for each of those values. An example using two strings and asserting that the lengths are correct: class PropertyExample: StringSpec() { \"String size\" { forAll({ a: String, b: String -> (a + b).length == a.length + b.length }) } } That test will be executed 100 times with random values in each test. See more in the readme. autoClose. Fields of type Closeable can be registered for automatic resource closing: class StringSpecExample : StringSpec() { val reader = autoClose(StringReader(\"xyz\")) ... } haveLength matcher. You can now write for strings: someString should haveLength(10) haveSize matcher. You can now write for collections: myCollection should haveSize(4) contain matcher. You can now write val col = listOf(1,2,3,4,5) col should contain(4) containInAnyOrder matcher. You can now write val col = listOf(1,2,3,4,5) col should containInAnyOrder(4,2,3) haveKey Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should haveKey(1) haveValue Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should haveValue(\"a\") contain Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should contain(1, \"a\") beTheSameInstanceAs reference matcher. This is an alias for x should be theSameInstanceAs(y) , allowing x should beTheSameInstanceAs(y) which fits in with new matcher style. Changed Replaced timeout + timeUnit with Duration ( #29 ) You can now write config(timeout = 2.seconds) instead of config(timeout = 2, timeoutUnit = TimeUnit.SECONDS) . Deprecated nothing Removed nothing Fixed Ignored tests now display properly. https://github.com/kotlintest/kotlintest/issues/43 Failing tests reported as a success AND a failure https://github.com/kotlintest/kotlintest/issues/42 Ad","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#430-october-2020-blog","text":"","title":"4.3.0 October 2020 - Blog"},{"location":"changelog/#features","text":"New data driven test DSL with data classes #1537 (framework) Option to strip whitespace from test names #1545 (framework) EnabledIf annotation for specs #1683 (framework) Propagate coroutine context to tests #1725 (framework) Option to suppress configuration dump #1742 (framework) Added severity attribute for TestCase #1746 (framework) Added kotest.framework.sourceref.disable option (framework) Make Engine dependency free #1748 (framework) Multi-line-string comparison for file contents #823 (assertions) New assertion: Iterator.shouldHaveNext() #1660 (assertions) New assertions: isEmpty / isDefined for java Optional #1661 (assertions) Non infix matchers should return this for easy chaining #1744 (assertions) Add property test module for kotlinx datetime #1679 (prop-testing) Add Gen.forNone #1636 (prop-testing) Arb should generate a single value #1754 (prop-testing) Adds an arbitrary to generate bigdecimal #1705 (prop-testing) Add steps and stack trace to allure, with full docs #460 (extensions) Added roboelectric extension to main build (extensions)","title":"Features:"},{"location":"changelog/#breaking-changes","text":"The kotest-extensions-junit5extensions module is now called kotest-extensions-junit5","title":"Breaking Changes"},{"location":"changelog/#426-october-2020","text":"Bugfix: Fixed regression in shouldBe when using iterables/arrays #1707 #1727 Bugfix: Fix first failure in beforeTest blocks #1736 Bugfix: deprecate distinct #1730 Bugfix: Fixed the empty allure result for tests with the failed afterTest block #1724 Feature: Added per project listener for testcontainers #1731","title":"4.2.6 October 2020"},{"location":"changelog/#425-september-2020","text":"Bugfix: Fixed performance issue when using 1000s of tests in gradle #1693 Feature: Added matchers for pair / triple components 1694 Feature: Added shouldHaveNameWithoutExtension matcher for files and paths #1696 Improvement: Added koin lifecycle mode #1710","title":"4.2.5 September 2020"},{"location":"changelog/#424-september-2020","text":"Bugfix: Test time does not scale with number of tests #1685 Bugfix: Added spring listener lifecycle mode #1643 Bugfix: Fix and remove double negative in empty directory assertions Improvement: Duplicated test name exception should include test name #1686 Improvement: SpringListener to generate meaningful method names #1591","title":"4.2.4 September 2020"},{"location":"changelog/#423-september-2020","text":"Bugfix: Throwables of Error in the engine should be reported to test engine listeners Bugfix: Switched classgraph to api Bugfix: Make Set comparisons use .contains() instead of a linear search #1672 Bugfix: Change retry default delay to 1 #1670 Bugfix: removed 1.4 api usage from property tests Improvement: Allow retry to call suspend functions #1669 Improvement: Add matcher alias for Iterator have next #1664 Improvement: Add java.util.Optional matchers #1662 Improvement: Expand ktor matchers to the client libraries #1658 Improvement: Add forNone assertion #1654 Improvement: Arb and Exhaustive should be covariant #1653 Improvement: Remove the annoying executionError extra test in gradle #1655 Improvement: Added more helpful error message when spec instantiation fails Docs: Update Gradle dependencies docs removing unnecessary -jvm suffix #1650 Docs: MockServer extension documentation #1446","title":"4.2.3 September 2020"},{"location":"changelog/#422-august-2020","text":"Bugfix: Usage of a Kotlin 1.4 only method has been removed Bugfix: KotlinReflectionInternalError fixed on java enums #1611 Bugfix: Errors in a DiscoveryExtension were not propagated to output #1634 Bugfix: Tags specified via inline tags dsl were not being picked up #1642 Improvement: Updated output of some collection matchers to format an element per line #1380","title":"4.2.2 August 2020"},{"location":"changelog/#421-august-2020","text":"Feature: The assertion libraries are now also published for watchos, tvos, and ios in addition to the macos, windows, and linux targets previously.","title":"4.2.1 August 2020"},{"location":"changelog/#420-august-2020-blog","text":"Feature: Kotest upgraded to use Kotlin 1.4.0 #1511 Feature: Allow multiple project configs to be detected and merged #1632 Feature: Allow case control in test's reports #1458 Feature: Use expression for tags instead of include/exclude #863 Feature: Add new scoped callbacks #1584 Feature: Support order annotation for SpecOrder #1593 Feature: Spec level overrides for timeout and invocation timeout #1551 Improvement: Added exhaustive only mode to property tests #1596 Improvement: Change instance of matchers to use generic contracts #1510 Improvement: Allow to disable SpringListener on final class warning #1573 Improvement: Bundle console runner with intellij plugin #1567 Improvement: Improved error message for map should contain when key present #1587 Improvement: Allow allure to be customizable #1527 Improvement: Use the SPDX compliant license identifier \"Apache-2.0\" in POM files #1517 Improvement: Use forAll(1) suspend parameters #1626 Bugfix: Running all tests in a package doesn't run tests in subpackages #1621 Bugfix: Can't run a single test method from Gradle 6.5 #1531 Bugfix: TestFactory listeners not executing on nested tests #1613 Bugfix: Disabling test execution with x-methods doesn't work with kotest-core-js #1623 Bugfix: NoSuchFileException when using kotest-extensions-junitxml with Gradle #1581 Bugfix: Non complete junit report when using FunSpec #999 Breaking Change: kotest-core module has been replaced with kotest-framework-api and kotest-framework-engine. Tools authors can depend on api only. Engine should be used for JS testing. For JVM testing, continue to use kotest-runner-junit5-jvm.","title":"4.2.0 August 2020 - Blog"},{"location":"changelog/#412-july-2020","text":"Bugfix: Dkotest.tags.include= only takes into account @Tags #1536 sksamuel Bugfix: Ensure exhaustive isn't build with an empty list #1549 Cleidiano Oliveira Bugfix: Add concurrent spec runner and fix sequential spec runner #1547 sksamuel Bugfix: Take into account range for IntShrinker and LongShrinker #1535 sksamuel Feature: Support expressions for tags as an alternative to include/exclude #863 sksamuel Feature: Expand some matchers to Iterable #1538 Leonardo Colman Lopes Improvement: Add the ability to make parameter substitutions when executing http files #1560 Shane Lathrop Improvement: Added xGiven / xWhen / xThen options to Behavior spec #1534 sksamuel Improvement: Added nicer syntax for Test Containers sksamuel Improvement: Restore context to describe #1565 sksamuel Breaking Change: Updates method signature of assertSoftly to take object under test as argument Ashish Kumar Joy","title":"4.1.2 July 2020"},{"location":"changelog/#411-june-2020","text":"Bugfix: Issue with describe spec and the intellij plugin fixed #1528 Bugfix: Incorrect error message with Exhaustive's when under the min iteration count #1526","title":"4.1.1 June 2020"},{"location":"changelog/#410-june-2020-blog","text":"Feature: The Kotest IntelliJ plugin has gone final. The plugin requires 4.1. or higher of Kotest. https://plugins.jetbrains.com/plugin/14080-kotest Feature: Highlight diff when comparing data classes #826 #1242 Feature: Improve error message in tolerance matchers #1230 Feature: Add Arb for (lat, long) #1304 Feature: Integration with Testcontainers #1353 Feature: x variants for Behavior / Feature / Expect spec #1383 Feature: Add property test global config with before / after prop test callbacks #1435 Feature: Parallel execution test cases in Spec #1362 Feature: Add variable.assertSoftly #1427 Feature: Coroutine helper for timeout #1447 Feature: Add timeout to apply to individual tests when invocations > 1 #1442 Feature: Add shouldExistInOrder matcher #1460 Feature: Added Arb.orNull #1414 Feature: Provide a way to remove test prefixes in the test output when using specs which use prefixes #1486 Feature: Adds shouldCompleteExceptionallyWith matcher #1454 Feature: Exhaustive.merge for two gens with a common supertype #1502 Improvement: Added Byte.shouldBeBetween(min, max) and Arb.bytes #1408 Improvement: Remove kotlintest aliases #1457 Improvement: Parent scopes are not coroutine scopes #1488 Improvement: isolation instead of isolationMode #1418 Improvement: Reflection equality improvements #1413 Improvement: Property tests should report exception of running shrunk input #1279 Improvement: Make beforeProject and afterProject as suspend function #1461 Improvement: Updated arb flat map to accept lists #1500 Improvement: Date generators should allow for specific dates to be selected #1354 Bugfix: Test cases with multiline names broken #1441 Bugfix: Before\\AfterProject catch only one Exception #1387 Bugfix: Arb.bind() calls the incorrect constructor #1487 Bugfix: Project config dump doesn't include enums properly #1379 Bugfix: Add Arb.choose that accepts weighted arbs #1499 Bugfix: Arb.list doesn't use ListShrinker #1493","title":"4.1.0 June 2020 - Blog"},{"location":"changelog/#406-june-2020","text":"Bugfix: Dependencies of assertions-core are now included properly when not using junit runner #1425 Bugfix: checkAll would fail if exhaustive size was very large #1456 Bugfix: Show typeclass on java.nio.filePath would cause stack overflow #1313","title":"4.0.6 June 2020"},{"location":"changelog/#405-april-2020","text":"Bugfix: Focus mode would cause some nested tests to be ignored #1376 Bugfix: Arb.choice would include edgecases in the generated values #1406 Bugfix: Arb.int and Arb.long edgecases included values outside the specified ranged #1405","title":"4.0.5 April 2020"},{"location":"changelog/#404-april-2020","text":"Bugfix: Exceptions of type LinkageError , most commonly ExceptionInInitializerError were not being handled #1381","title":"4.0.4 April 2020"},{"location":"changelog/#403-april-2020","text":"Feature: Koin support now works for koin 2.1 #1357 Deprecation: String context is deprecated in ShouldSpec in favour of a context block. #1356 Improvement: Line breaks added to Collection.containExactly matcher #1380 Improvement: Tolerance matcher emits better failure message (including plus/minus values) #1230 Bugfix: Project config output now writes the correct values of test ordering and isolation mode #1379 Bugfix: Order of autoclose is restored to work like 3.4.x (was undefined in 4.0.x) #1384 Bugfix: Fix shouldContainExactly for arrays #1364","title":"4.0.3 April 2020"},{"location":"changelog/#402-april-2020","text":"Feature: Added filter and map to Exhaustives #1343 Feature: shouldBeInteger matcher using contracts #1315 Bugfix: Fixed issue with xdescribe in describe spec always being active Bugfix: Simple tags were using full class names rather than the simple name breaking backwards compatibility #1346 Improvement: Caching result of discovery for increased performance in maven #1325 Bugfix: Closing resources used in classgraph scan #1323 Bugfix: Fixed timeout for coroutine launched inside a test without its own scope #1345 Bugfix: Fix Arb.bind returning only the same value #1348 Bugfix: Restored usage of opentest4j assertions #1339 Bugfix: Fixed missing stacktrace in data driven testing #1336 Bugfix: Fixed Arb.instant always returning same value #1322 Bugfix: Added workaround for gradle 5 bugs.","title":"4.0.2 April 2020"},{"location":"changelog/#401-march-2020","text":"Improvement: Bumped kotlin to 1.3.71 Feature: Aded latlong Arb #1304","title":"4.0.1 March 2020"},{"location":"changelog/#400-march-2020","text":"The 4.0.0 release is a large release. With the project rename, the packages have changed and module names have changed. Major changes: The KotlinTest project is now multi-platform. This means most of the modules now require -jvm to be added if you are working server side JVM only. For example, io.kotlintest:kotlintest-runner-junit5 is now io.kotest:kotest-runner-junit5-jvm taking into account package name changes and the platform suffix. The main assertions library is now kotest-assertions-core and many new assertions (matchers) have been added. This changelog won't list them all. It is simpler to view the full list . The property test library has moved to a new module kotest-property and been reworked to include many new features. See new documentation here . The old property test classes are deprecated and will be removed in a future release. Many new property test generators have been added. The full list is here . Composable specs have been added in the form of Test Factories . Project config no longer requires placing in a special package name, but can be placed anywhere in the classpath . @Autoscan has been added for listeners and extensions. Added DSL version of test lifecycle callbacks . Minor changes. Feature: A new JSoup assertions module has been added. #1028 Feature: Stats matchers #851 Feature: Experimental Robolectric Support #926 Bugfix: shouldNotThrowAny return T instead of Unit #981 Internal: Removed dependency on Arrow to avoid version conflicts Feature: Project wide default test case config Feature: whenReady(f) has been replaced with f.whenReady which is coroutine enabled Feature: Alphabetic test case ordering Feature: All test callbacks are now coroutine enabled Feature: forEachAsClue Improvement: Support Koin 2.1.0 Improvement: Explicitly allow internal classes as specs Feature: Klock matcher support #1214 Feature: JDBC matcher support #1221","title":"4.0.0 March 2020"},{"location":"changelog/#342","text":"Bugfix: Enhances SpringListener to work correctly with all Spring's Listeners #950","title":"3.4.2"},{"location":"changelog/#341","text":"Internal: Remove JUnit redeclarations #927 Feature: Add infix modifier to more Arrow matchers #921 Feature: BigDecimal range matchers #932 Feature: monotonically/strictly increasing/decreasing matcher #850 Feature: Fixes shouldBe and shouldNotBe comparison #913 Feature: Add overload to Ktor shouldHaveStatus matcher #914 Feature: Fail parent tests when child tests fail #935","title":"3.4.1"},{"location":"changelog/#340","text":"Feature: Support for running tests with Koin #907 Feature: Global timeout option can be applied across all tests #858 Feature: Introduced await as a more feature rich version of eventually #888 #793 Feature: Array overloads for all matchers #904 Feature: Support Spring's Test Listeners #887 Feature: Limit Parallelism for some specs #786 Feature: Added new project listener #859 Feature: Change System extensions to support different modes #843 Feature: Print project configurations #841 #866 Feature: New date matcher variations for month, time units, day of week, etc #899 Feature: Multi line diff min line config option #706 Feature: Allow nested describe scope in DescribeSpec #905 Feature: Add matcher for Dates to ignore timezone #891 Feature: Reflection matchers #614 #894 Feature: Added string matchers for single line and size between #853 Feature: Added contracts and lambda variations of matchers for arrow types #802 #890 #834 Feature: Added matchers for LocalTime #889 Feature: Added Zoned and Offset date time variants of shouldBeToday #820 Feature: Add new throwable matchers #864 Feature: Added matchers for Result #836 #861 Feature: Added big decimal matchers #875 Feature: Added shouldBeSymbolicLink and shouldHaveParent matchers for files #871 Feature: Json Matchers from resources #873 Feature: Added shouldBeZero and shouldNotBeZero matcher for number types #819 #848 Feature: Added shouldContainFiles matcher for path #854 Feature: The URI matchers should also work on URLs. #818 Feature: Allow setting isolation mode in project config #842 Feature: Added containFileDeep File matcher #846 Feature: Implements SkipTestException #805 Feature: Implements Infinity and NaN Double Matchers #801 Feature: Add asClue helper function #784 Feature: Add infix map matchers using Pair #792 Feature: Add Short and Btyte primitive gens #773 Feature: Implement Gen.take(n) function #758 Feature: Implement Gen.next(predicate) function #759 Feature: Add support to change sizes of generated lists, sets, maps #757 Feature: Allow exclusion/inclusion tags at runtime #761 Bugfix: Added missing part of shouldHaveLength message #870 ) Bugfix: Updated json matchers to include actual json in the error Bugfix: Fix for before/after test listeners not failing tests #842 #865 Bugfix: Changed autoClose to accept an AutoCloseable #847 Bugfix: Fixed left vs right issue #612 Bugfix: Ensure specs that fail in initialisation fail a Maven build #832 Bugfix: Fixed test engine reporting when there is an exception in either the init block, beforeSpec or the afterSpec method #771 Internal: io.kotlintest.Result renamed to io.kotlintest.MatcherResult to avoid conflict with new Kotlin class kotlin.Result #898","title":"3.4.0"},{"location":"changelog/#330","text":"Feature: Intellij Plugin now available! Feature: FunSpec now allows parent context blocks Feature: java.time between matcher ( #694 ) Feature: Constant 'now' listeners ( #693 ) Feature: PITest plugin ( #687 ) Feature: Spring mocking injection @MockBean @MockkBean ( #684 ) Feature: instanceOf and typeOf matchers to use the casted value ( #695 ) Feature: Digest Matchers #667 Feature: continually assertion function #643 Feature: Add project config option for assertSoftly #512 ( #655 ) Feature: Implement System Security Manager Extensions ( #640 ) Feature: Implement System Environment Extension ( #633 ) Feature: Implement shouldBeOneOf matcher and assertions ( #647 ) Feature: Add nullability matchers with Kotlin Contracts ( #602 ) ( #646 ) Feature: SystemProperty Test Helpers #524 ( #608 ) Feature: Timezone / Locale Extension #587 ( #609 ) Feature: Move extensions to Kotlintest-Extensions module ( #629 ) Feature: Provide range-based numeric generators and javax.time generators #530 ( #543 ) Feature: Extended word spec ( #635 ) Feature: Implement shouldNotThrow matchers ( #603 ) Improvement: Make \"condensed\" multi-line diffs configurable #607 Improvement: Allow Arrow Either extensions to support nullable types ( #613 ) Improvement: Enables test bang on all specs ( #606 ) Improvement: Add property testing extensions for custom generators ( #506 ) Improvement: Added issue flag in config #525 Bugfix: Added support for package selectors from junit discovery requests #597 Bugfix: Disabled top level tests are not marked as ignored in JUnit #656 Bugfix: Fix containOnlyOnce which return true when no occurrence ( #660 ) Internal: Auto deploy snapshot on each travis build Internal: Remove all deprecated matchers/assertions ( #653 )","title":"3.3.0"},{"location":"changelog/#321","text":"Feature: AnnotationSpec now has a expected exception configuration #527 #559 Feature: BehaviorSpec gained extra nesting possibilities, with And between any other keywords #562 #593 Bugfix: Independent tests were sharing a thread, and one test could timeout a different one for apparently no reason #588 #590 Improvement: Documentation on TestConfig.invocations clarified #591 #592","title":"3.2.1"},{"location":"changelog/#320","text":"Feature: Support for coroutines directly from tests #386 Feature: Isolation mode added to more finely control the instances in which tests execute #379 Feature: When re-running tests, execute previously failing specs first #388 Feature: Support for @Before and @After in AnnotationSpec for easier migration from JUnit #513 Feature: Support package selectors in discovery #461 Improvement: The test listeners have been reworked to make them more powerful and clearer #494 Improvement: Better support for multi-line string comparisions #402 Improvement: Gen.oneOf should be covariant #471 Improvement: Double should have oppostive matchers for shouldBePositive and shouldBeNegative #435 Improvement: New matchers #393 #325 Bugfix: BehaviorSpec doesn't allow config bug #495 Bugfix: Error when throwing AssertionError from inside a shouldThrow{} block #479 Bugfix: Fix test timeouts #476 Bugfix: Fix annotation spec failure message #539 Internal: Build now uses Kotlin 1.3 #379 Internal: Upgraded class scanning to use ClassGraph instead of Reflections #459","title":"3.2.0"},{"location":"changelog/#3111","text":"Feature: Infix support to String matchers #443 Feature: Infix support to files, floats, sequences, types and uri matchers #445 Feature: Infix support to Double matchers #429 Feature: Infix suport to Map matchers #417 Feature: shouldNotBePositive and shouldNotBeNegative for Double matchers #435 Feature: Support for Duration in time matchers #423 Feature: arrow-assertion Failure matcher that checks underlying throwable equality #427 Feature: shouldNotBeTrue and shouldNotBeFalse for Boolean matchers #452 Improvement: Documentation for Gen.int() #419 Improvement: Javadocs for Date matchers #420 Improvement: Better error message for empty collection in matchers #438 Improvement: Better stacktrace filtering from Failures class #465 Bugfix: Double matcher shouldNotBeExactly had the wrong implementation #432 Bugfix: Single-thread test had before and after running in separate thread from the test #447 Bugfix: Test with invocations > 1 wouldn't complete if test failed #413 Bugfix: Wrong assertion on shouldThrow #479 #484","title":"3.1.11"},{"location":"changelog/#3110","text":"Feature: Infix version of some inline matchers, eg date1 shouldHaveSameYearAs date2 ( #404 #407 #409 ) Feature: Infix support for int and long matchers ( #400 ) Feature: Added startsWith/endsWith matchers on collections ( #393 ) Improvement: Use unambiguous representations in collection matchers ( #392 ) Improvement: Collection matchers now work on Sequence too ( #391 ) Improvement: Added shouldThrowUnit variant of shouldThrow ( #387 ) Fix: shouldBe on arrays without static type ( #397 )","title":"3.1.10"},{"location":"changelog/#319","text":"Feature: Add soft assertions ( #373 ) Feature: sortedWith (and related) matchers. ( #383 ) Improvement: Removed unnecessary Comparable<T> upper-bound from sortedWith matchers. ( #389 ) Improvement: Improve StringShrinker algorithm ( #377 ) Bugfix: shouldBeBetween should be shouldBe instead of shouldNotBe ( #390 ) Bugfix: Fix beLeft is comparing against Either.Right instead of Either.Left ( #374 ) Internal: Naming executor services for jmx monitoring","title":"3.1.9"},{"location":"changelog/#318","text":"Bugfix: Skip tests when MethodSelector is set #367 (means can run a single test in intellij) Bugfix: Fix error when running single test in kotlintest-tests ( #371 ) Bugfix Fix table testing forNone and Double between matcher ( #372 ) Improvement: Remove matcher frames from stacktraces ( #369 ) Improvement: Use less ambiguous string representations in equality errors ( #368 ) Improvement: Improve String equality error messages ( #366 ) Internal: Update kotlin to 1.2.50 ( #365 )","title":"3.1.8"},{"location":"changelog/#317","text":"Feature: Added Int/Long.shouldBeNegative and Int/Long.shouldBePositive matchers #325 Feature: Added Double.shouldBeNegative and Double.shouldBePositive matchers #325 Feature: Added collection.shouldBeLargerThan(c), collection.shouldBeSmallerThan(c), collection.shouldBeSameSizeAs(c) #325 Feature: Added collection.shouldHaveAtLeastSize(n) and collection.shouldHaveAtMostSize(n) matchers. Feature: Added matcher for uri.opaque Feature: Add matchers containsExactly and containsExactlyInAnyOrder ( #360 ) Feature: Added test case filters Bugfix: Running single tests with Gradle command line #356 Change: Removed coroutine support until it is no longer experimental Improvement: Optimize sorted matcher ( #359 ) Improvement: Allow type matchers to match nullable values. ( #358 ) Improvement: Allow nullable receivers for string matchers. ( #352 ) Improvement: Run tests for all rows in a table, even after errors. ( #351 )","title":"3.1.7"},{"location":"changelog/#316","text":"Specs now support co-routines #332 Extension function version of inspectors. Inspectors for arrow NonEmptyLists New style of data driven tests with parameter name detection Extension function style of assert all for property testing Updated string matchers to show better error when input is null or empty string Allow nullable arguments to more matcher functions. #350 Added extension functions for table tests #349","title":"3.1.6"},{"location":"changelog/#315","text":"Fix for bug in gradle which doesn't support parallel test events Bring back Duration extension properties #343 Added fix for gradle 4.7 issues #336 shouldBe does not handle java long #346 Fixing function return type in documentation for forAll() ( #345 ) Fixing typos in reference.md ( #344 ) Make the Table & Row data classes covariant ( #342 ) Fixing argument names in ReplaceWith of deprecated matchers ( #341 )","title":"3.1.5"},{"location":"changelog/#314","text":"Fix eventually nanos conversion ( #340 ) Improve array shouldBe overloads ( #339 )","title":"3.1.4"},{"location":"changelog/#313","text":"Added workaround for gradle 4.7/4.8 error #336 Fix URI path and URI parameter matchers ( #338 )","title":"3.1.3"},{"location":"changelog/#312","text":"Added arrow NonEmptyList isUnique matchers Added Float and List Shrinker Added inspecting and extracting helper functions. ( #334 ) Allow tags to be added to specs for all test cases #333 Support randomized order of top level tests #328","title":"3.1.2"},{"location":"changelog/#311","text":"Focus option for top level tests #329 Improve shrinkage #331 Updated readme for custom generators #313 Added generator for UUIDs Fixed bug with auto-close not being called. Deprecated ProjectExtension in favour of TestListener. Added a couple of edge case matchers to the arrow extension; added arrow matchers for lists.","title":"3.1.1"},{"location":"changelog/#version-310","text":"Simplified Setup In KotlinTest 3.1.x it is sufficent to enable JUnit in the test block of your gradle build instead of using the gradle junit plugin. This step is the same as for any test framework that uses the JUnit Platform. Assuming you have gradle 4.6 or above, then setup your test block like this: test { useJUnitPlatform() } You can additionally enable extra test logging: test { useJUnitPlatform() testLogging { events \"FAILED\", \"SKIPPED\", \"STANDARD_OUT\", \"STANDARD_ERROR\" } } Instance Per Test for all Specs In the 3.0.x train, the ability to allow an instance per test was removed from some spec styles due to implementation difficulties. This has been addressed in 3.1.x and so all spec styles now allow instance per test as in the 2.0.x releases. Note: The default value is false, so tests will use a single shared instance of the spec for all tests unless the isInstancePerTest() function is overriden to return true. Breaking Change: Config Syntax The syntax for config has now changed. Instead of a function call after the test has been defined, it is now specified after the name of the test. So, instead of: \"this is a test\" { }.config(...) You would now do: \"this is a test\".config(...) { } Matchers as extension functions All matchers can now be used as extension functions. So instead of: file should exist() or listOf(1, 2) should containNull() You can do: file.shouldExist() or listOf(1, 2).shouldContainNull() Note: The infix style is not deprecated and will be supported in future releases, but the extension function is intended to be the preferred style moving forward as it allows discovery in the IDE. Dozens of new Matchers even and odd Tests that an Int is even or odd: 4 should beEven() 3 shouldNot beEven() 3 should beOdd() 4 shouldNot beOdd() beInRange Asserts that an int or long is in the given range: 3 should beInRange(1..10) 4 should beInRange(1..3) haveElementAt Checks that a collection contains the given element at a specified index: listOf(\"a\", \"b\", \"c\") should haveElementAt(1, \"b\") listOf(\"a\", \"b\", \"c\") shouldNot haveElementAt(1, \"c\") Help out the type inferrer when using nulls: listOf(\"a\", \"b\", null) should haveElementAt<String?>(2, null) readable , writeable , executable and hidden Tests if a file is readable, writeable, or hidden: file should beRadable() file should beWriteable() file should beExecutable() file should beHidden() absolute and relative Tests if a file's path is relative or absolute. File(\"/usr/home/sam\") should beAbsolute() File(\"spark/bin\") should beRelative() startWithPath(path) Tests if a file's path begins with the specified prefix: File(\"/usr/home/sam\") should startWithPath(\"/usr/home\") File(\"/usr/home/sam\") shouldNot startWithPath(\"/var\") haveSameHashCodeAs(other) Asserts that two objects have the same hash code. obj1 should haveSameHashCodeAs(obj2) \"hello\" shouldNot haveSameHashCodeAs(\"world\") haveSameLengthAs(other) Asserts that two strings have the same length. \"hello\" should haveSameLengthAs(\"world\") \"hello\" shouldNot haveSameLengthAs(\"you\") haveScheme, havePort, haveHost, haveParameter, havePath, haveFragment Matchers for URIs: val uri = URI.create(\"https://localhost:443/index.html?q=findme#results\") uri should haveScheme(\"https\") uri should haveHost(\"localhost\") uri should havePort(443) uri should havePath(\"/index.html\") uri should haveParameter(\"q\") uri should haveFragment(\"results\") Date matchers - before / after / haveSameYear / haveSameDay / haveSameMonth / within Collections - containNull, containDuplicates Futures - completed, cancelled String - haveLineCount, contain(regex) Types - haveAnnotation(class) Arrow matcher module A new module has been added which includes matchers for Arrow - the popular and awesome functional programming library for Kotlin. To include this module add kotlintest-assertions-arrow to your build. The included matchers are: Option - Test that an Option has the given value or is a None . For example: val option = Option.pure(\"foo\") option should beSome(\"foo\") val none = None none should beNone() Either - Test that an Either is either a Right or Left . For example: Either.right(\"boo\") should beRight(\"boo\") Either.left(\"boo\") should beLeft(\"boo\") NonEmptyList - A collection (no pun intended) of matchers for Arrow's NonEmptyList . These mostly mirror the equivalent Collection matchers but for NELs. For example: NonEmptyList.of(1, 2, null).shouldContainNull() NonEmptyList.of(1, 2, 3, 4).shouldBeSorted<Int>() NonEmptyList.of(1, 2, 3, 3).shouldHaveDuplicates() NonEmptyList.of(1).shouldBeSingleElement(1) NonEmptyList.of(1, 2, 3).shouldContain(2) NonEmptyList.of(1, 2, 3).shouldHaveSize(3) NonEmptyList.of(1, 2, 3).shouldContainNoNulls() NonEmptyList.of(null, null, null).shouldContainOnlyNulls() NonEmptyList.of(1, 2, 3, 4, 5).shouldContainAll(3, 2, 1) Try - Test that a Try is either Success or Failure . Try.Success(\"foo\") should beSuccess(\"foo\") Try.Failure<Nothing>(RuntimeException()) should beFailure() Validation - Asserts that a Validation is either Valid or an Invalid Valid(\"foo\") should beValid() Invalid(RuntimeException()) should beInvalid() Generator Bind A powerful way of generating random class instances from primitive generators is to use the new bind function. A simple example is to take a data class of two fields, and then use two base generators and bind them to create random values of that class. data class User(val email: String, val id: Int) val userGen = Gen.bind(Gen.string(), Gen.positiveIntegers(), ::User) assertAll(userGen) { it.email shouldNotBe null it.id should beGreaterThan(0) } Property Testing: Classify When using property testing, it can be useful to see the distribution of values generated, to ensure you're getting a good spread of values and not just trival ones. For example, you might want to run a test on a String and you want to ensure you're getting good amounts of strings with whitespace. To generate stats on the distribution, use classify with a predicate, a label if the predicate passes, and a label if the predicate fails. For example: assertAll(Gen.string()) { a -> classify(a.contains(\" \"), \"has whitespace\", \"no whitespace\") // some test } And this will output something like: 63.70% no whitespace 36.30% has whitespace So we can see we're getting a good spread of both types of value. You don't have to include two labels if you just wish to tag the \"true\" case, and you can include more than one classification. For example: forAll(Gen.int()) { a -> classify(a == 0, \"zero\") classify(a % 2 == 0, \"even number\", \"odd number\") a + a == 2 * a } This will output something like: 51.60% even number 48.40% odd number 0.10% zero Property Testing: Shrinking Tag Extensions A new type of extension has been added called TagExtension . Implementations can override the tags() function defined in this interface to dynamically return the Tag instances that should be active at any moment. The existing system properties kotlintest.tags.include and kotlintest.tags.exclude are still valid and are not deprecated, but adding this new extension means extended scope for more complicated logic at runtime. An example might be to disable any Hadoop tests when not running in an environment that doesn't have the hadoop home env variable set. After creating a TagExtension it must be registered with the project config. object Hadoop : Tag() object HadoopTagExtension : TagExtension { override fun tags(): Tags = if (System.getenv().containsKey(\"HADOOP_HOME\")) Tags.include(Hadoop) else Tags.exclude(Hadoop) } object MyProjectConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = listOf(HadoopTagExtension) } object SimpleTest : StringSpec({ \"simple test\" { // this test would only run on environments that have hadoop configured }.config(tags = setOf(Hadoop)) }) Discovery Extensions: instantiate() Inside the DiscoveryExtension interface the function fun <T : Spec> instantiate(clazz: KClass<T>): Spec? has been added which allows you to extend the way new instances of Spec are created. By default, a no-args constructor is assumed. However, if this function is overridden then it's possible to support Spec classes which have other constructors. For example, the Spring module now supports constructor injection using this extension. Other use cases might be when you want to always inject some config class, or if you want to ensure that all your tests extend some custom interface or superclass. As a reminder, DiscoveryExtension instances are added to Project config. System out / error extensions An extension that allows you to test for a function that writes to System.out or System.err. To use this extension add the module kotlintest-extensions-system to your build. By adding the NoSystemOutListener or NoSystemErrListener to your config or spec classes, anytime a function tries to write to either of these streams, a SystemOutWriteException or SystemErrWriteException will be raised with the string that the function tried to write. This allows you to test for the exception in your code. For example: class NoSystemOutOrErrTest : StringSpec() { override fun listeners() = listOf(NoSystemOutListener, NoSystemErrListener) init { \"System.out should throw an exception when the listener is added\" { shouldThrow<SystemOutWriteException> { System.out.println(\"boom\") }.str shouldBe \"boom\" } \"System.err should throw an exception when the listener is added\" { shouldThrow<SystemErrWriteException> { System.err.println(\"boom\") }.str shouldBe \"boom\" } } } System.exit extension Another extension that is part of the kotlintest-extensions-system module. This extension will allow you to test if System.exit(Int) is invoked in a function. It achieves this by intercepting any calls to System.exit and instead of terminating the JVM, it will throw a SystemExitException with the exit code. For example: class SystemExitTest : StringSpec() { override fun listeners() = listOf(SpecSystemExitListener) init { \"System.exit should throw an exception when the listener is added\" { shouldThrow<SystemExitException> { System.exit(123) }.exitCode shouldBe 123 } } } Spring Module Updates The spring extension module kotlintest-extensions-spring has been updated to allow for constructor injection. This new extension is called SpringAutowireConstructorExtension and must be added to your `ProjectConfig. Then you can use injected dependencies directly in the primary constructor of your test class. For example: @ContextConfiguration(classes = [(Components::class)]) class SpringAutowiredConstructorTest(service: UserService) : WordSpec({ \"SpringListener\" should { \"have autowired the service\" { service.repository.findUser().name shouldBe \"system_user\" } } }) JUnit 4 Runner A JUnit 4 runner has been added which allows KotlinTest to run using the legacy JUnit 4 platform. To use this, add kotlintest-runner-junit4 to your build instead of kotlintest-runner-junit5 . Note: This is intended for use when junit5 cannot be used. It should not be the first choice as functionality is restricted. Namely: In intellij, test output will not be nested Project wide beforeAll/afterAll cannot be supported.","title":"Version 3.1.0"},{"location":"changelog/#version-30x-march-29-2018","text":"Module split out KotlinTest has been split into multiple modules. These include core, assertions, the junit runner, and extensions such as spring, allure and junit-xml. The idea is that in a future release, further runners could be added (TestNG) or for JS support (once multi-platform Kotlin is out of beta). When upgrading you will typically want to add the kotlintest-core , kotlintest-assertions and kotlintest-runner-junit5 to your build rather than the old kotlintest module which is now defunct. When upgrading, you might find that you need to update imports to some matchers. testCompile 'io.kotlintest:kotlintest-core:3.0.0' testCompile 'io.kotlintest:kotlintest-assertions:3.0.0' testCompile 'io.kotlintest:kotlintest-runner-junit5:3.0.0' Gradle Users: Also you must include apply plugin: 'org.junit.platform.gradle.plugin' in your project and classpath \"org.junit.platform:junit-platform-gradle-plugin:1.1.0\" to the dependencies section of your buildscript or tests will not run (or worse, will hang). This allows gradle to execute jUnit-platform-5 based tests (which KotlinTest builds upon). Note: Gradle says that this is not required as of 4.6 but even with 4.6 it seems to be required. Maven users: You need to include the following in your plugins: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-surefire-plugin</artifactId> <version>2.19.1</version> <dependencies> <dependency> <groupId>org.junit.platform</groupId> <artifactId>junit-platform-surefire-provider</artifactId> <version>1.1.0</version> </dependency> </dependencies> </plugin> And you must include <dependency> <groupId>io.kotlintest</groupId> <artifactId>kotlintest-runner-junit5</artifactId> <version>${kotlintest.version}</version> <scope>test</scope> </dependency> as a regular dependency. Breaking: ProjectConfig Project wide config in KotlinTest is controlled by implementing a subclass of AbstractProjectConfig . In previous versions you could call this what you wanted, and place it where you wanted, and KotlinTest would attempt to find it and use it. This was the cause of many bug reports about project start up times and reflection errors. So in version 3.0.x onwards, KotlinTest will no longer attempt to scan the classpath. Instead you must call this class ProjectConfig and place it in a package io.kotlintest.provided . It must still be a subclass of AbstractProjectConfig This means kotlintest can do a simple Class.forName to find it, and so there is no startup penalty nor reflection issues. Project config now allows you to register multiple types of extensions and listeners, as well as setting parallelism. Breaking: Interceptors have been deprecated and replaced with Listeners The previous inteceptors were sometimes confusing. You had to invoke the continuation function or the spec/test would not execute. Not invoking the function didn't mean the spec/test was skipped, but that it would hang. So interceptors are deprecated, and in some places removed. Those are not removed are now located in classes called SpecExtension and TestCaseExtension and those interfaces should be used rather than functions directly. Here is an example of a migrated interceptor. val mySpecExtension = object : SpecExtension { override fun intercept(spec: Spec, process: () -> Unit) { println(\"Before spec!\") process() println(\"After spec!\") } } As a replacement, in 3.0.0 we've added the TestListener interface which is the more traditional before/after style callbacks. In addition, these methods include the result of the test (success, fail, error, skipped) which gives you more context in writing plugins. The TestListener interface offers everything the old interceptors could do, and more. Here is an example of a simple listener. object TimeTracker : TestListener { var started = 0L override fun beforeTest(description: Description) { TimeTrackerTest.started = System.currentTimeMillis() } override fun afterTest(description: Description, result: TestResult) { val duration = System.currentTimeMillis() - TimeTrackerTest.started println(\"Test ${description.fullName()} took ${duration}ms\") } } If you want to use these methods in a Spec itself, then you can just override the functions directly because a Spec is already a TestListener. object TimeTracker : WordSpec() { var started = 0L override fun beforeTest(description: Description) { started = System.currentTimeMillis() } override fun afterTest(description: Description, result: TestResult) { val duration = System.currentTimeMillis() - started println(\"Test ${description.fullName()} took ${duration}ms\") } init { \"some test\" should { \"be timed\" { // test here } } } } Listeners can be added project wide by overriding listeners() in the ProjectConfig . Note: In the next release, new Extension functions will be added which will be similar to the old interceptors, but with complete control over the lifecycle. For instance, a future intercept method will enforce that the user skip, run or abort a test in the around advice. They will be more complex, and so suited to more advanced use cases. The new TestListener interface will remain of course, and is the preferred option. Parallelism If you want to run more than one spec class in parallel, you can by overriding parallelism inside your projects ProjectConfig or by supplying the system property kotlintest.parallelism . Note the system property always takes precedence over the config. Futures Support Test cases now support waiting on futures in a neat way. If you have a value in a CompletableFuture that you want to test against once it completes, then you can do this like this: val stringFuture: CompletableFuture<String> = ... \"My future test\" should { \"support CompletableFuture<T>\" { whenReady(stringFuture) { it shouldBe \"wibble\" } } } Breaking: Exception Matcher Changes The shouldThrow<T> method has been changed to also test for subclasses. For example, shouldThrow<IOException> will also match exceptions of type FileNotFoundException . This is different to the behavior in all previous KotlinTest versions. If you wish to have functionality as before - testing exactly for that type - then you can use the newly added shouldThrowExactly<T> . JUnit XML Module Support for writing out reports in junit-format XML has added via the kotlintest-extensions-junitxml module which you will need to add to your build. This module provides a JUnitXmlListener which you can register with your project to autowire your tests. You can register this by overriding listeners() in ProjectConfig . class ProjectConfig : AbstractProjectConfig() { override fun listeners() = listOf(JUnitXmlListener) } Spring Module Spring support has been added via the kotlintest-extensions-spring module which you will need to add to your build. This module provides a SpringListener which you can register with your project to autowire your tests. You can register this for just some classes by overriding the listeners() function inside your spec, for example: class MySpec : ParentSpec() { override fun listeners() = listOf(SpringListener) } Or you can register this for all classes by adding it to the ProjectConfig . See the section on ProjectConfig for how to do this. Breaking: Tag System Property Rename The system property used to include/exclude tags has been renamed to kotlintest.tags.include and kotlintest.tags.exclude . Make sure you update your build jobs to set the right properties as the old ones no longer have any effect. If the old tags are detected then a warning message will be emitted on startup. New Matchers beInstanceOf<T> has been added to easily test that a class is an instance of T. This is in addition to the more verbose beInstanceOf(SomeType::class) . The following matchers have been added for maps: containAll , haveKeys , haveValues . These will output helpful error messages showing you which keys/values or entries were missing. New matchers added for Strings: haveSameLengthAs(other) , beEmpty() , beBlank() , containOnlyDigits() , containADigit() , containIgnoringCase(substring) , lowerCase() , upperCase() . New matchers for URIs: haveHost(hostname) , havePort(port) , haveScheme(scheme) . New matchers for collections: containNoNulls() , containOnlyNulls() Breaking: One instance per test changes One instance per test is no longer supported for specs which offer nested scopes . For example, WordSpec . This is because of the tricky nature of having nested closures work across fresh instances of the spec. When using one instance per test, a fresh spec class is required for each test, but that means selectively executing some closures and not others in order to ensure the correct state. This has proved the largest source of bugs in previous versions. KotlinTest 3.0.x takes a simplified approach. If you want the flexibilty to lay out your tests with nested scopes, then all tests will execute in the same instance (like Spek and ScalaTest). If you want each test to have it's own instance (like jUnit) then you can either split up your tests into multiple files, or use a \"flat\" spec like FunSpec or StringSpec . This keeps the implementation an order of magnitude simplier (and therefore less likely to lead to bugs) while offering a pragmatic approach to keeping both sets of fans happy. New Specs Multiple new specs have been added. These are: AnnotationSpec , DescribeSpec and ExpectSpec . Expect spec allows you to use the context and expect keywords in your tests, like so: class ExpectSpecExample : ExpectSpec() { init { context(\"some context\") { expect(\"some test\") { // test here } context(\"nested context even\") { expect(\"some test\") { // test here } } } } } The AnnotationSpec offers functionality to mimic jUnit, in that tests are simply functions annotated with @io.kotlintest.specs.Test . For example: class AnnotationSpecExample : AnnotationSpec() { @Test fun test1() { } @Test fun test2() { } } And finally, the DescribeSpec is similar to SpekFramework, using describe , and , and it . This makes it very useful for those people who are looking to migrate to KotlinTest from SpekFramework. class DescribeSpecExample : DescribeSpec() { init { describe(\"some context\") { it(\"test name\") { // test here } describe(\"nested contexts\") { and(\"another context\") { it(\"test name\") { // test here } } } } } } Property Testing with Matchers The ability to use matchers in property testing has been added. Previously property testing worked only with functions that returned a Boolean, like: \"startsWith\" { forAll(Gen.string(), Gen.string(), { a, b -> (a + b).startsWith(a) }) } But now you can use assertAll and assertNone and then use regular matchers inside the block. For example: \"startsWith\" { assertAll(Gen.string(), Gen.string(), { a, b -> a + b should startWith(a) }) } This gives you the ability to use multiple matchers inside the same block, and not have to worry about combining all possible errors into a single boolean result. Generator Edge Cases Staying with property testing - the Generator interface has been changed to now provide two types of data. The first are values that should always be included - those edge cases values which are common sources of bugs. For example, a generator for Ints should always include values like zero, minus 1, positive 1, Integer.MAX_VALUE and Integer.MIN_VALUE. Another example would be for a generator for enums. That should include all the values of the enum to ensure each value is tested. The second set of values are random values, which are used to give us a greater breadth of values tested. The Int generator should return random ints from across the entire integer range. Previously generators used by property testing would only include random values, which meant you were very unlikely to see the edge cases that usually cause issues - like the aforementioned Integer MAX / MIN. Now you are guaranteed to get the edge cases first and the random values afterwards. Breaking: MockitoSugar removed This interface added a couple of helpers for Mockito, and was used primarily before Kotlin specific mocking libraries appeared. Now there is little value in this mini-wrapper so it was removed. Simply add whatever mocking library you like to your build and use it as normal. CsvDataSource This class has been added for loading data for table testing. A simple example: class CsvDataSourceTest : WordSpec() { init { \"CsvDataSource\" should { \"read data from csv file\" { val source = CsvDataSource(javaClass.getResourceAsStream(\"/user_data.csv\"), CsvFormat()) val table = source.createTable<Long, String, String>( { it: Record -> Row3(it.getLong(\"id\"), it.getString(\"name\"), it.getString(\"location\")) }, { it: Array<String> -> Headers3(it[0], it[1], it[2]) } ) forAll(table) { a, b, c -> a shouldBe gt(0) b shouldNotBe null c shouldNotBe null } } } } } Matcher Negation Errors All matchers now have the ability to report a better error when used with shouldNot and shouldNotBe . Previously a generic error was generated - which was usually the normal error but with a prefix like \"NOT:\" but now each built in matcher will provide a full message, for example: Collection should not contain element 'foo'","title":"Version 3.0.x - March 29 2018"},{"location":"changelog/#version-200-released-2017-03-26","text":"Closed Issues","title":"Version 2.0.0, released 2017-03-26"},{"location":"changelog/#added","text":"You can write tests alternatively into a lambda parameter in the class constructor, eg: class StringSpecExample : StringSpec({ \"strings.size should return size of string\" { \"hello\".length shouldBe 5 \"hello\" should haveLength(5) } }) Added forNone for table tests, eg val table = table( headers(\"a\", \"b\"), row(0L, 2L), row(2L, 2L), row(4L, 5L), row(4L, 6L) ) forNone(table) { a, b -> 3 shouldBe between(a, b) } Interceptors have been added. Interceptors allow code to be executed before and after a test. See the main readme for more info. Simplified ability to add custom matchers. Simple implement Matcher<T> interface. See readme for more information. Added shouldNot to invert matchers. Eg, \"hello\" shouldNot include(\"hallo\") Deprecated matchers which do not implement Matcher . Eg, should have substring(x) has been deprecated in favour of \"hello\" should include(\"l\") . This is because instances of Matcher can be combined with or and and and can be negated with shouldNot . Added between matcher for int and long, eg 3 shouldBe between(2, 5) Added singleElement matcher for collections, eg x shouldBe singleElement(y) Added sorted matcher for collections, eg listOf(1,2,3) shouldBe sorted<Int>() Now supports comparsion of arrays #116 Added Gen.oneOf to create a generator that returns one of the values for the given Enum class.","title":"Added"},{"location":"changelog/#changed","text":"Tags are objects derived from Tag class now. Tags can now be included and/or exluded. It is no longer the case that all untagged tests are always executed. Fixed bugs with parenthesis breaking layout in Intellij #112","title":"Changed"},{"location":"changelog/#removed","text":"FlatSpec was removed because it has an irregular syntax with config and is essentially the same as StringSpec, but more complicated. Deprecated method overloads with duration: Long, unit: TimeUnit expecting for testing exceptions (use shouldThrow now)","title":"Removed"},{"location":"changelog/#version-132-released-2016-07-05","text":"","title":"Version 1.3.2, released 2016-07-05"},{"location":"changelog/#changed_1","text":"Added a shouldBe exactly(b) matcher for doubles kotlintest only pulls in mockito-core now instead of mockito-all","title":"Changed"},{"location":"changelog/#version-131-released-2016-07-03","text":"","title":"Version 1.3.1, released 2016-07-03"},{"location":"changelog/#changed_2","text":"Bumped Kotlin version to 1.0.3","title":"Changed"},{"location":"changelog/#version-130-released-2016-07-03","text":"Closed Issues","title":"Version 1.3.0, released 2016-07-03"},{"location":"changelog/#added_1","text":"StringSpec. You can use simply use Strings as the basis for tests, eg: class StringSpecExample : StringSpec() { init { \"strings.size should return size of string\" { \"hello\".length shouldBe 5 \"hello\" should haveLength(5) } \"strings should support config\" { \"hello\".length shouldBe 5 }.config(invocations = 5) } } Table Tests. Tables allow you to manually specific combinations of values that should be used, and are useful for edge cases and other specific values you want to test. The headers are used for when values fail, the output can show you what inputs were used for what labels. An example of using a table consisting of two-value tuples: class TableExample : StringSpec(), TableTesting { init { \"numbers should be prime\" { val table = table( headers(\"a\", \"b\"), row(5, 5), row(4, 6), row(3, 7) ) forAll(table) { a, b -> a + b == 10 } } } } Property tests. Property tests automatically generate values for testings. You provide, or have KotlinTest provide for you, generators , which will generate a set of values and the unit test will be executed for each of those values. An example using two strings and asserting that the lengths are correct: class PropertyExample: StringSpec() { \"String size\" { forAll({ a: String, b: String -> (a + b).length == a.length + b.length }) } } That test will be executed 100 times with random values in each test. See more in the readme. autoClose. Fields of type Closeable can be registered for automatic resource closing: class StringSpecExample : StringSpec() { val reader = autoClose(StringReader(\"xyz\")) ... } haveLength matcher. You can now write for strings: someString should haveLength(10) haveSize matcher. You can now write for collections: myCollection should haveSize(4) contain matcher. You can now write val col = listOf(1,2,3,4,5) col should contain(4) containInAnyOrder matcher. You can now write val col = listOf(1,2,3,4,5) col should containInAnyOrder(4,2,3) haveKey Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should haveKey(1) haveValue Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should haveValue(\"a\") contain Map matcher. You can now write val map = mapOf(Pair(1, \"a\"), Pair(2, \"b\")) map should contain(1, \"a\") beTheSameInstanceAs reference matcher. This is an alias for x should be theSameInstanceAs(y) , allowing x should beTheSameInstanceAs(y) which fits in with new matcher style.","title":"Added"},{"location":"changelog/#changed_3","text":"","title":"Changed"},{"location":"changelog/#replaced-timeout-timeunit-with-duration-29","text":"You can now write config(timeout = 2.seconds) instead of config(timeout = 2, timeoutUnit = TimeUnit.SECONDS) .","title":"Replaced timeout + timeUnit with Duration (#29)"},{"location":"changelog/#deprecated","text":"nothing","title":"Deprecated"},{"location":"changelog/#removed_1","text":"nothing","title":"Removed"},{"location":"changelog/#fixed","text":"Ignored tests now display properly. https://github.com/kotlintest/kotlintest/issues/43 Failing tests reported as a success AND a failure https://github.com/kotlintest/kotlintest/issues/42 Ad","title":"Fixed"},{"location":"clues/","text":"Clues Sometimes a failed assertion contains enough information in the error message to know what went wrong. For example: username shouldBe \"sksamuel\" Might give an error like: expected: \"sksamuel\" but was: \"sam@myemailaddress.com\" And you would be able to see that you were populating the username field with an email address. But let's say you had a test like this: user.name shouldNotBe null If this failed, you would simply get: <null> should not equal <null> Which isn't particularly helpful. This is where withClue comes into play. The withClue and asClue helpers can add extra context to assertions so failures are self explanatory: For example, we can use withClue with a string message withClue(\"Name should be present\") { user.name shouldNotBe null } Would give an error like this: Name should be present <null> should not equal <null> We can also use the asClue extension function to turn any object into the clue message. For example: data class HttpResponse(val status: Int, val body: String) val response = HttpResponse(404, \"the content\") response.asClue { it.status shouldBe 200 it.body shouldBe \"the content\" } Would output: HttpResponse(status=404, body=the content) Expected :200 Actual :404","title":"Clues"},{"location":"clues/#clues","text":"Sometimes a failed assertion contains enough information in the error message to know what went wrong. For example: username shouldBe \"sksamuel\" Might give an error like: expected: \"sksamuel\" but was: \"sam@myemailaddress.com\" And you would be able to see that you were populating the username field with an email address. But let's say you had a test like this: user.name shouldNotBe null If this failed, you would simply get: <null> should not equal <null> Which isn't particularly helpful. This is where withClue comes into play. The withClue and asClue helpers can add extra context to assertions so failures are self explanatory: For example, we can use withClue with a string message withClue(\"Name should be present\") { user.name shouldNotBe null } Would give an error like this: Name should be present <null> should not equal <null> We can also use the asClue extension function to turn any object into the clue message. For example: data class HttpResponse(val status: Int, val body: String) val response = HttpResponse(404, \"the content\") response.asClue { it.status shouldBe 200 it.body shouldBe \"the content\" } Would output: HttpResponse(status=404, body=the content) Expected :200 Actual :404","title":"Clues"},{"location":"conditional_evaluation/","text":"Conditional Evaluation There are several ways to disable tests. Some of these are hardcoded in your test, others are evaluated at runtime. By Config You can disable a test case simply by setting the config parameter enabled to false . If you're looking for something like JUnit's @Ignore , this is for you. \"should do something\".config(enabled = false) { ... } You can use the same mechanism to run tests only under certain conditions. For example you could run certain tests only on Linux systems using SystemUtils .IS_OS_LINUX from Apache Commons Lang . \"should do something\".config(enabled = IS_OS_LINUX) { ... } isLinux and isPostgreSQL in the example are just expressions (values, variables, properties, function calls) that evaluate to true or false . If you want to use a function that is based on the test rather than a value, then you can use enabledIf . For example, if we wanted to disable all tests that begin with the word \"danger\" unless we were executing on Linux, then we could do this: val disableDangerOnWindows: EnabledIf = { !it.name.startsWith(\"danger\") || IS_OS_LINUX } \"danger will robinson\".config(enabledIf = disableDangerOnWindows) { // test here } \"very safe will\".config(enabledIf = disableDangerOnWindows) { // test here } Focus Kotest supports isolating a single top level test by preceding the test name with f: . Then only that test (and any subtests defined inside that scope) will be executed, with the rest being skipped. For example, in the following snippet only the middle test will be executed. class FocusExample : StringSpec({ \"test 1\" { // this will be skipped } \"f:test 2\" { // this will be executed } \"test 3\" { // this will be skipped } }) Tip Focus mode does not work for nested tests due to the fact that nested tests are only discovered once the parent test has executed. Bang The opposite of focus is possible, which is to prefix a test with an exclamation mark ! and then that test (and any subtests defined inside that scope) will be skipped. In the next example we\u2019ve disabled the first test by adding the \u201c!\u201d prefix. class BangExample : StringSpec({ \"!test 1\" { // this will be ignored } \"test 2\" { // this will run } \"test 3\" { // this will run too } }) Tip If you want to disable the use of ! then set the system property kotest.bang.disable to true . X-Methods Many spec styles offer variants of their keywords that begin with x to disable execution. This is a popular approach with Javascript testing frameworks. The idea is you can quickly add the x character to the test declaration to (temporarily) disable it. For example, with describe spec we can do this: class XMethodsExample : DescribeSpec({ xdescribe(\"this block and it's children are now disabled\") { it(\"will not run\") { // disabled test } } }) See which specs support this, and the syntax required on the specs styles guide . @Ignored If you wish to disable all tests in a Spec, we may use the @Ignored annotation. Then the spec will be skipped, and not even instantiated. @Ignored class IgnoredSpec : FunSpec() { init { error(\"boom\") // spec will not be created so this error will not happen } } Note This is only available on the JVM target. @EnabledIf Similar to @Ignored, we can use a function to determine if a spec should be created. The @EnabledIf annotation requires a class that implements EnabledCondition . For example, we may wish to only execute a test on Linux platforms if the name contains Linux. class LinuxOnlyCondition : EnabledCondition() { override fun enabled(specKlass: KClass<out Spec>): Boolean = if (specKlass.simpleName?.contains(\"Linux\") == true) IS_OS_LINUX else true } Then we can apply that to one or more specs @EnabledIf(LinuxOnlyCondition::class) class MyLinuxTest1 : FunSpec() { .. } @EnabledIf(LinuxOnlyCondition::class) class MyLinuxTest2 : DescribeSpec() { .. } Note This is only available on the JVM target. Gradle Test Filtering When running Kotest via the JUnit Platform runner through gradle, Kotest supports the standard gradle syntax for test filtering. You can enable filtering either in the build script or via the --tests command-line option. For example, in the build script: tasks.test { filter { //include all tests from package includeTestsMatching(\"com.sksamuel.somepackage.*\") } } Or via the command line: gradle test --tests 'com.sksamuel.somepackage*' gradle test --tests '*IntegrationTest' See full Gradle documentation here . Note Because gradle's test support is method/class based, we cannot filter tests down to the individual test level, only the class level.","title":"Conditional evaluation"},{"location":"conditional_evaluation/#conditional-evaluation","text":"There are several ways to disable tests. Some of these are hardcoded in your test, others are evaluated at runtime.","title":"Conditional Evaluation"},{"location":"conditional_evaluation/#by-config","text":"You can disable a test case simply by setting the config parameter enabled to false . If you're looking for something like JUnit's @Ignore , this is for you. \"should do something\".config(enabled = false) { ... } You can use the same mechanism to run tests only under certain conditions. For example you could run certain tests only on Linux systems using SystemUtils .IS_OS_LINUX from Apache Commons Lang . \"should do something\".config(enabled = IS_OS_LINUX) { ... } isLinux and isPostgreSQL in the example are just expressions (values, variables, properties, function calls) that evaluate to true or false . If you want to use a function that is based on the test rather than a value, then you can use enabledIf . For example, if we wanted to disable all tests that begin with the word \"danger\" unless we were executing on Linux, then we could do this: val disableDangerOnWindows: EnabledIf = { !it.name.startsWith(\"danger\") || IS_OS_LINUX } \"danger will robinson\".config(enabledIf = disableDangerOnWindows) { // test here } \"very safe will\".config(enabledIf = disableDangerOnWindows) { // test here }","title":"By Config"},{"location":"conditional_evaluation/#focus","text":"Kotest supports isolating a single top level test by preceding the test name with f: . Then only that test (and any subtests defined inside that scope) will be executed, with the rest being skipped. For example, in the following snippet only the middle test will be executed. class FocusExample : StringSpec({ \"test 1\" { // this will be skipped } \"f:test 2\" { // this will be executed } \"test 3\" { // this will be skipped } }) Tip Focus mode does not work for nested tests due to the fact that nested tests are only discovered once the parent test has executed.","title":"Focus"},{"location":"conditional_evaluation/#bang","text":"The opposite of focus is possible, which is to prefix a test with an exclamation mark ! and then that test (and any subtests defined inside that scope) will be skipped. In the next example we\u2019ve disabled the first test by adding the \u201c!\u201d prefix. class BangExample : StringSpec({ \"!test 1\" { // this will be ignored } \"test 2\" { // this will run } \"test 3\" { // this will run too } }) Tip If you want to disable the use of ! then set the system property kotest.bang.disable to true .","title":"Bang"},{"location":"conditional_evaluation/#x-methods","text":"Many spec styles offer variants of their keywords that begin with x to disable execution. This is a popular approach with Javascript testing frameworks. The idea is you can quickly add the x character to the test declaration to (temporarily) disable it. For example, with describe spec we can do this: class XMethodsExample : DescribeSpec({ xdescribe(\"this block and it's children are now disabled\") { it(\"will not run\") { // disabled test } } }) See which specs support this, and the syntax required on the specs styles guide .","title":"X-Methods"},{"location":"conditional_evaluation/#ignored","text":"If you wish to disable all tests in a Spec, we may use the @Ignored annotation. Then the spec will be skipped, and not even instantiated. @Ignored class IgnoredSpec : FunSpec() { init { error(\"boom\") // spec will not be created so this error will not happen } } Note This is only available on the JVM target.","title":"@Ignored"},{"location":"conditional_evaluation/#enabledif","text":"Similar to @Ignored, we can use a function to determine if a spec should be created. The @EnabledIf annotation requires a class that implements EnabledCondition . For example, we may wish to only execute a test on Linux platforms if the name contains Linux. class LinuxOnlyCondition : EnabledCondition() { override fun enabled(specKlass: KClass<out Spec>): Boolean = if (specKlass.simpleName?.contains(\"Linux\") == true) IS_OS_LINUX else true } Then we can apply that to one or more specs @EnabledIf(LinuxOnlyCondition::class) class MyLinuxTest1 : FunSpec() { .. } @EnabledIf(LinuxOnlyCondition::class) class MyLinuxTest2 : DescribeSpec() { .. } Note This is only available on the JVM target.","title":"@EnabledIf"},{"location":"conditional_evaluation/#gradle-test-filtering","text":"When running Kotest via the JUnit Platform runner through gradle, Kotest supports the standard gradle syntax for test filtering. You can enable filtering either in the build script or via the --tests command-line option. For example, in the build script: tasks.test { filter { //include all tests from package includeTestsMatching(\"com.sksamuel.somepackage.*\") } } Or via the command line: gradle test --tests 'com.sksamuel.somepackage*' gradle test --tests '*IntegrationTest' See full Gradle documentation here . Note Because gradle's test support is method/class based, we cannot filter tests down to the individual test level, only the class level.","title":"Gradle Test Filtering"},{"location":"custom_gens/","text":"Custom Generators To write your own generator for a type T, you just create an instance of Arb<T> or Exhaustive<T> . Arb When writing a custom arb we can use the arb builder which accepts a lambda that must return a sequence of the type we are generating for. The parameter to this lambda is a RandomSource parameter which contains the seed and the Random instance. We should typically use the provided RandomSource if we need access to a kotlin.Random instance, as this instance will have been seeded by the framework to allow for repeatable tests. For example, here is a custom arb that random generates an int between 3 and 6 using the arb builder. When using the arb builder we. We can do setup code in the outer function if required. val sillyArb = arb { rs -> generateSequence { rs.random.nextInt(3..6) } } We can also use this random if we are composing other arbs when building ours. For example, here is an Arb that supports a custom class called Person , delegating to a String arb and an Int arb. data class Person(val name: String, val age: Int) val personArb = arb { rs -> val names = Arb.string().values(rs) val ages = Arb.int().values(rs) names.zip(ages).map { (name, age) -> Person(name.value, age.value) } } Although in reality this Arb could have been easier written using bind, it demonstrates the principle. Exhaustive When writing a custom exhaustive we can use the .exhaustive() extension function on a List. Nothing more to it than that really! val singleDigitPrimes = listOf(2,3,5,7).exhaustive() class PropertyExample: StringSpec({ \"testing single digit primes\" { checkAll(singleDigitPrimes) { prime -> isPrime(prime) shouldBe true isPrime(prime * prime) shouldBe false } } })","title":"Custom Generators"},{"location":"custom_gens/#custom-generators","text":"To write your own generator for a type T, you just create an instance of Arb<T> or Exhaustive<T> .","title":"Custom Generators"},{"location":"custom_gens/#arb","text":"When writing a custom arb we can use the arb builder which accepts a lambda that must return a sequence of the type we are generating for. The parameter to this lambda is a RandomSource parameter which contains the seed and the Random instance. We should typically use the provided RandomSource if we need access to a kotlin.Random instance, as this instance will have been seeded by the framework to allow for repeatable tests. For example, here is a custom arb that random generates an int between 3 and 6 using the arb builder. When using the arb builder we. We can do setup code in the outer function if required. val sillyArb = arb { rs -> generateSequence { rs.random.nextInt(3..6) } } We can also use this random if we are composing other arbs when building ours. For example, here is an Arb that supports a custom class called Person , delegating to a String arb and an Int arb. data class Person(val name: String, val age: Int) val personArb = arb { rs -> val names = Arb.string().values(rs) val ages = Arb.int().values(rs) names.zip(ages).map { (name, age) -> Person(name.value, age.value) } } Although in reality this Arb could have been easier written using bind, it demonstrates the principle.","title":"Arb"},{"location":"custom_gens/#exhaustive","text":"When writing a custom exhaustive we can use the .exhaustive() extension function on a List. Nothing more to it than that really! val singleDigitPrimes = listOf(2,3,5,7).exhaustive() class PropertyExample: StringSpec({ \"testing single digit primes\" { checkAll(singleDigitPrimes) { prime -> isPrime(prime) shouldBe true isPrime(prime * prime) shouldBe false } } })","title":"Exhaustive"},{"location":"data_driven_testing/","text":"Data Driven Testing Note This section covers the new and improved data test support that was released with Kotest 4.3.0. To view the documentation for the previous data test support, click here When writing tests that are logic based, one or two directed examples that work through specific scenarios make sense. Other times we have tests that are example based, and we want to provide many combinations of parameters. In these situations, data driven testing (also called table driving testing) is an easy technique to avoid tedious boilerplate. Kotest has support for data driven testing built into the framework. This means it will automatically generate the test case entries, based off input values provided by you. Let's consider writing tests for a pythagorean triple function that returns true if the input values are valid triples. fun isPythagTriple(a: Int, b: Int, c: Int): Boolean = a * a + b * b == c * c We start by writing a data class that will hold each row of values. data class PythagTriple(val a: Int, val b: Int, val c: Int) Next we invoke the function forAll inside a test case, passing in one or more of these data class rows , and a lambda that performs some test logic for a given row . context(\"Pythag triples tests\") { forAll( PythagTriple(3, 4, 5), PythagTriple(6, 8, 10), PythagTriple(8, 15, 17), PythagTriple(7, 24, 25) ) { (a, b, c) -> isPythagTriple(a, b, c) shouldBe true } } Because we are using data classes, the input row can be destructured into the member properties. Note Data driven testing can be used within any spec but must always be invoked inside a container test. Kotest will automatically generate a test case for each input row, as if you had manually written a seperate test case for each. If there is an error for any particular input row, then the test will fail and Kotest will output the values that failed. For example, if we change the previous example to include the row PythagTriple(5, 4, 3) then that test will be marked as a failure. The error message will contain the error and the input row details: Test failed for (a, 5), (b, 4), (c, 3) expected:<9> but was:<41> Tip There is the inverse of forAll , called forNone which verifies that none of the rows pass the test. Custom Test Names By default, the name of each test is simply the toString() on the input row. However we can customize this if we wish, by passing in test names into the forAll / forNone functions. context(\"Pythag triples tests\") { forAll<PythagTriple>( \"3, 4, 5\" to PythagTriple(3, 4, 5), \"6, 8, 10\" to PythagTriple(6, 8, 10), \"8, 15, 17\" to PythagTriple(8, 15, 17), \"7, 24, 25\" to PythagTriple(7, 24, 25) ) { (a, b, c) -> a * a + b * b shouldBe c * c } } Note that currently, you must also specify the data class type. The output from this example is now slightly clearer: Whether this is worth the extra effort depends on how readable the toString() method is on the data classes you are using.","title":"Data driven testing"},{"location":"data_driven_testing/#data-driven-testing","text":"Note This section covers the new and improved data test support that was released with Kotest 4.3.0. To view the documentation for the previous data test support, click here When writing tests that are logic based, one or two directed examples that work through specific scenarios make sense. Other times we have tests that are example based, and we want to provide many combinations of parameters. In these situations, data driven testing (also called table driving testing) is an easy technique to avoid tedious boilerplate. Kotest has support for data driven testing built into the framework. This means it will automatically generate the test case entries, based off input values provided by you. Let's consider writing tests for a pythagorean triple function that returns true if the input values are valid triples. fun isPythagTriple(a: Int, b: Int, c: Int): Boolean = a * a + b * b == c * c We start by writing a data class that will hold each row of values. data class PythagTriple(val a: Int, val b: Int, val c: Int) Next we invoke the function forAll inside a test case, passing in one or more of these data class rows , and a lambda that performs some test logic for a given row . context(\"Pythag triples tests\") { forAll( PythagTriple(3, 4, 5), PythagTriple(6, 8, 10), PythagTriple(8, 15, 17), PythagTriple(7, 24, 25) ) { (a, b, c) -> isPythagTriple(a, b, c) shouldBe true } } Because we are using data classes, the input row can be destructured into the member properties. Note Data driven testing can be used within any spec but must always be invoked inside a container test. Kotest will automatically generate a test case for each input row, as if you had manually written a seperate test case for each. If there is an error for any particular input row, then the test will fail and Kotest will output the values that failed. For example, if we change the previous example to include the row PythagTriple(5, 4, 3) then that test will be marked as a failure. The error message will contain the error and the input row details: Test failed for (a, 5), (b, 4), (c, 3) expected:<9> but was:<41> Tip There is the inverse of forAll , called forNone which verifies that none of the rows pass the test.","title":"Data Driven Testing"},{"location":"data_driven_testing/#custom-test-names","text":"By default, the name of each test is simply the toString() on the input row. However we can customize this if we wish, by passing in test names into the forAll / forNone functions. context(\"Pythag triples tests\") { forAll<PythagTriple>( \"3, 4, 5\" to PythagTriple(3, 4, 5), \"6, 8, 10\" to PythagTriple(6, 8, 10), \"8, 15, 17\" to PythagTriple(8, 15, 17), \"7, 24, 25\" to PythagTriple(7, 24, 25) ) { (a, b, c) -> a * a + b * b shouldBe c * c } } Note that currently, you must also specify the data class type. The output from this example is now slightly clearer: Whether this is worth the extra effort depends on how readable the toString() method is on the data classes you are using.","title":"Custom Test Names"},{"location":"data_driven_testing_4.2.0/","text":"Data Driven Testing To test your code with different parameter combinations, you can use a table of values as input for your test cases. This is called data driven testing also known as table driven testing . Invoke the forAll or forNone function, passing in one or more row objects, where each row object contains the values to be used be a single invocation of the test. After the forAll or forNone function, setup your actual test function to accept the values of each row as parameters. The row object accepts any set of types, and the type checker will ensure your types are consistent with the parameter types in the test function. \"square roots\" { forAll( row(2, 4), row(3, 9), row(4, 16), row(5, 25) ) { root, square -> root * root shouldBe square } } In the above example, the root and square parameters are automatically inferrred to be integers. If there is an error for any particular input row, then the test will fail and KotlinTest will automatically match up each input to the corresponding parameter names. For example, if we change the previous example to include the row row(5,55) then the test will be marked as a failure with the following erorr message. Test failed for (root, 5), (square, 55) with error expected: 55 but was: 25 Table testing can be used within any spec. Here is an example using StringSpec . class StringSpecExample : StringSpec({ \"string concat\" { forAll( row(\"a\", \"b\", \"c\", \"abc\"), row(\"hel\", \"lo wo\", \"rld\", \"hello world\"), row(\"\", \"z\", \"\", \"z\") ) { a, b, c, d -> a + b + c shouldBe d } } }) It may be desirable to have each row of data parameters as an individual test. To generating such individual tests follow a similar pattern for each spec style. An example in the FreeSpec is below. class IntegerMathSpec : FreeSpec({ \"Addition\" - { listOf( row(\"1 + 0\", 1) { 1 + 0 }, row(\"1 + 1\", 2) { 1 + 1 } ).map { (description: String, expected: Int, math: () -> Int) -> description { math() shouldBe expected } } } // ... \"Complex Math\" - { listOf( row(\"8/2(2+2)\", 16) { 8 / 2 * (2 + 2) }, row(\"5/5 + 1*1 + 3-2\", 3) { 5 / 5 + 1 * 1 + 3 - 2 } ).map { (description: String, expected: Int, math: () -> Int) -> description { math() shouldBe expected } } } }) Produces 4 tests and 2 parent descriptions: IntegerMathSpec \u2713 Addition \u2713 1 + 0 \u2713 1 + 1 \u2713 Complex Math \u2713 8/2(2+2) \u2713 5/5 + 1*1 + 3-2","title":"Data driven testing 4.2.0"},{"location":"data_driven_testing_4.2.0/#data-driven-testing","text":"To test your code with different parameter combinations, you can use a table of values as input for your test cases. This is called data driven testing also known as table driven testing . Invoke the forAll or forNone function, passing in one or more row objects, where each row object contains the values to be used be a single invocation of the test. After the forAll or forNone function, setup your actual test function to accept the values of each row as parameters. The row object accepts any set of types, and the type checker will ensure your types are consistent with the parameter types in the test function. \"square roots\" { forAll( row(2, 4), row(3, 9), row(4, 16), row(5, 25) ) { root, square -> root * root shouldBe square } } In the above example, the root and square parameters are automatically inferrred to be integers. If there is an error for any particular input row, then the test will fail and KotlinTest will automatically match up each input to the corresponding parameter names. For example, if we change the previous example to include the row row(5,55) then the test will be marked as a failure with the following erorr message. Test failed for (root, 5), (square, 55) with error expected: 55 but was: 25 Table testing can be used within any spec. Here is an example using StringSpec . class StringSpecExample : StringSpec({ \"string concat\" { forAll( row(\"a\", \"b\", \"c\", \"abc\"), row(\"hel\", \"lo wo\", \"rld\", \"hello world\"), row(\"\", \"z\", \"\", \"z\") ) { a, b, c, d -> a + b + c shouldBe d } } }) It may be desirable to have each row of data parameters as an individual test. To generating such individual tests follow a similar pattern for each spec style. An example in the FreeSpec is below. class IntegerMathSpec : FreeSpec({ \"Addition\" - { listOf( row(\"1 + 0\", 1) { 1 + 0 }, row(\"1 + 1\", 2) { 1 + 1 } ).map { (description: String, expected: Int, math: () -> Int) -> description { math() shouldBe expected } } } // ... \"Complex Math\" - { listOf( row(\"8/2(2+2)\", 16) { 8 / 2 * (2 + 2) }, row(\"5/5 + 1*1 + 3-2\", 3) { 5 / 5 + 1 * 1 + 3 - 2 } ).map { (description: String, expected: Int, math: () -> Int) -> description { math() shouldBe expected } } } }) Produces 4 tests and 2 parent descriptions: IntegerMathSpec \u2713 Addition \u2713 1 + 0 \u2713 1 + 1 \u2713 Complex Math \u2713 8/2(2+2) \u2713 5/5 + 1*1 + 3-2","title":"Data Driven Testing"},{"location":"discovery_extension/","text":"Discovery Extension Advanced Feature Another type of extension that can be used inside ProjectConfig is the DiscoveryExtension . This extension is designed to allow customisation of the way spec classes are discovered and instantiated. There are two functions of interest that can be overridden. The first is afterScan which accepts a list of Spec classes that were discovered by Kotest during the discovery phase of the test engine. This function then returns a list of the classes that should actually be instantiated and executed. By overriding this function, you are able to filter which classes are used, or even add in extra classes not originally discovered. The second function is instantiate which accepts a KClass<Spec> and then attempts to create an instance of this Spec class in order to then run the test cases defined in it. By default, Spec classes are assumed to have a zero-arg primary constructor. If you wish to use non-zero arg primary constructors this function can be implemented with logic on how to instantiate a test class. An implementation can choose to create a new instance, or it can choose to return null if it wishes to pass control to the next extension (or if no more extensions, then back to the Test Engine itself). By overriding this function, extensions are able to customize the way classes are created, to support things like constructors with parameters, or classes that require special initialization logic. This type of extension is how the Spring Constructor Injection add-on works for example.","title":"Discovery extension"},{"location":"discovery_extension/#discovery-extension","text":"Advanced Feature Another type of extension that can be used inside ProjectConfig is the DiscoveryExtension . This extension is designed to allow customisation of the way spec classes are discovered and instantiated. There are two functions of interest that can be overridden. The first is afterScan which accepts a list of Spec classes that were discovered by Kotest during the discovery phase of the test engine. This function then returns a list of the classes that should actually be instantiated and executed. By overriding this function, you are able to filter which classes are used, or even add in extra classes not originally discovered. The second function is instantiate which accepts a KClass<Spec> and then attempts to create an instance of this Spec class in order to then run the test cases defined in it. By default, Spec classes are assumed to have a zero-arg primary constructor. If you wish to use non-zero arg primary constructors this function can be implemented with logic on how to instantiate a test class. An implementation can choose to create a new instance, or it can choose to return null if it wishes to pass control to the next extension (or if no more extensions, then back to the Test Engine itself). By overriding this function, extensions are able to customize the way classes are created, to support things like constructors with parameters, or classes that require special initialization logic. This type of extension is how the Spring Constructor Injection add-on works for example.","title":"Discovery Extension"},{"location":"extensions/","text":"Extensions Kotest integrates with many libraries and frameworks. This page outlines the extensions maintained by the Kotest team. Allure Allure is an open-source framework designed to generate detailed and interactive test reports. It works by collecting test data as tests are executed and then compiling that into a final HTML report. Kotest provides an extenstion for Allure and full integration instructions are here . Arrow The arrow assertion module provives assertions for the functional programming library arrow-kt for types such as Option , Try , and so on. To use this library you need to add kotest-assertions-arrow to your build. Here is an example asserting that an Option variable is a Some with a value \"Foo\" . val option: Option<String> = ... option shouldBe beSome(\"foo\") For the full list of arrow matchers click here . Additionally, the module provides inspectors that work specifically for the NonEmptyList type. For example, we can test that a set of assertions hold only for a single element in a Nel by using the forOne inspector. val list = NonEmptyList(2, 4, 6, 7,8) list.forOne { it.shouldBeOdd() } Other inspectors include forNone , forAll , forExactly(n) , forSome and so on. See the section on inspectors for more details. Spring Kotest offers a Spring extension that allows you to test code that wires dependencies using Spring. To use this extension add the kotest-extensions-spring module to your test compile path. In order to let Spring know which configuration class to use, you must annotate your Spec classes with @ContextConfiguration . This should point to a class annotated with the Spring @Configuration annotation. Alternatively, you can use @ActiveProfile to point to a specific application context file . There are two ways to enable spring wiring depending on if you want to use constructor injection, or field injection. Field Injection If you wish to use field injection, then the SpringListener must be registered with any Spec that uses spring beans. For example: @ContextConfiguration(classes = [(TestConfiguration::class)]) class SpringExampleSpec : WordSpec() { override fun listeners() = listOf(SpringListener) @Autowired var bean: MyBean? = null init { \"Spring Extension\" should { \"have wired up the bean\" { bean shouldNotBe null } } } } You could add the SpringListener project wide by registering the listener in ProjectConfig . Constructor Injection For constructor injection, we use a different implementation called SpringAutowireConstructorExtension which must be registered with ProjectConfig . This extension will intercept each call to create a Spec instance and will autowire the beans declared in the primary constructor. First an example of the project config. class ProjectConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = listOf(SpringAutowireConstructorExtension) } And now an example of a test class which requires a service called UserService in its primary constructor. This service class is just a regular spring bean which has been annotated with @Component. @ContextConfiguration(classes = [(Components::class)]) class SpringAutowiredConstructorTest(service: UserService) : WordSpec() { init { \"SpringListener\" should { \"have autowired the service\" { service.repository.findUser().name shouldBe \"system_user\" } } } } Final Clases When using a final class, you may receive a warning from Kotest: Using SpringListener on a final class. If any Spring annotation fails to work, try making this class open If you wish, you can disable this warning by setting the system property kotest.listener.spring.ignore.warning to true. Ktor The kotest-assertions-ktor module provides response matchers for a Ktor application. There are matchers for both TestApplicationResponse if you are using the server side test support, and for HttpResponse if you are using the ktor client classes. To add Ktor matchers, add the following dependency to your project testImplementation(\"io.kotest:kotest-assertions-ktor:${version}\") An example of using the matchers with the server side test support: withTestApplication({ module(testing = true) }) { handleRequest(HttpMethod.Get, \"/\").apply { response shouldHaveStatus HttpStatusCode.OK response shouldNotHaveContent \"failure\" response.shouldHaveHeader(name = \"Authorization\", value = \"Bearer\") response.shouldNotHaveCookie(name = \"Set-Cookie\", cookieValue = \"id=1234\") } } And an example of using the client support: val client = HttpClient(CIO) val resp = client.post(\"http://mydomain.com/foo\") response.shouldHaveStatus(HttpStatusCode.OK) response.shouldHaveHeader(name = \"Authorization\", value = \"Bearer\") Koin The Koin DI Framework can be used with Kotest through the KoinListener test listener and its own interface KoinTest . To add the listener to your project, add the depency to your project: testImplementation(\"io.kotest:kotest-extensions-koin:${version}\") With the dependency added, we can use Koin in our tests! class KotestAndKoin : FunSpec(), KoinTest { override fun listeners() = listOf(KoinListener(myKoinModule)) val userService by inject<UserService>() init { test(\"Use user service\") { userService.getUser().username shouldBe \"Kerooker\" } } } Robolectric Robolectric can be used with Kotest through the RobolectricExtension which can be found in kotest-extensions-robolectric module. To add this module to project you need specify following in your build.gradle : testImplementation 'io.kotest:kotest-extensions-robolectric:<version>' With this dependency added you should add extensions to your project config. For example if you have no such config yet it would look like class MyProjectLevelConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = super.extensions() + RobolectricExtension() } Of course you can just add this extension to another extensions you're already using. After that done any class which should be ran with Robolectric should be annotated with @RobolectricTest annotation. Compilation test The kotest-assertions-compiler extension provides matchers to assert that given kotlin code snippet compiles or not. This extension is a wrapper over kotlin-compile-testing and provides following matchers String.shouldCompile() String.shouldNotCompile() File.shouldCompile() File.shouldNotCompile() To add the compilation matcher, add the following dependency to your project testImplementation(\"io.kotest:kotest-assertions-compiler:${version}\") Usage: class CompilationTest: StringSpec() { init { \"shouldCompile test\" { val codeSnippet = \"\"\" val aString: String = \"A valid assignment\" \"\"\".trimMargin() codeSnippet.shouldCompile() File(\"SourceFile.kt\").shouldCompile() } \"shouldNotCompile test\" { val codeSnippet = \"\"\" val aInteger: Int = \"A invalid assignment\" \"\"\".trimMargin() codeSnippet.shouldNotCompile() File(\"SourceFile.kt\").shouldNotCompile() } } } During checking of code snippet compilation the classpath of calling process is inherited, which means any dependencies which are available in calling process will also be available while compiling the code snippet. System Extensions Sometimes your code might use some functionalities straight from the JVM, which are very hard to simulate. With Kotest System Extensions, these difficulties are made easy to mock and simulate, and your code can be tested correctly. After changing the system and using the extensions, the previous state will be restored. Attention : This code is sensitive to concurrency. Due to the JVM specification there can only be one instance of these extensions running (For example: Only one Environment map must exist). If you try to run more than one instance at a time, the result is unknown. System Environment With System Environment Extension you can simulate how the System Environment is behaving. That is, what you're obtaining from System.getenv() . Kotest provides some extension functions that provides a System Environment in a specific scope: withEnvironment(\"FooKey\", \"BarValue\") { System.getenv(\"FooKey\") shouldBe \"BarValue\" // System environment overriden! } You can also use multiple values in this extension, through a map or list of pairs. withEnvironment(mapOf(\"FooKey\" to \"BarValue\", \"BarKey\" to \"FooValue\")) { // Use FooKey and BarKey } These functions will add the keys and values if they're not currently present in the environment, and will override them if they are. Any keys untouched by the function will remain in the environment, and won't be messed with. Instead of extensions functions, you can also use the provided Listeners to apply these functionalities in a bigger scope. There's an alternative for the Spec/Per test level, and an alternative for the Project Level. class MyTest : FreeSpec() { override fun listeners() = listOf(SystemEnvironmentTestListener(\"foo\", \"bar\")) init { \"MyTest\" { System.getenv(\"foo\") shouldBe \"bar\" } } } class ProjectConfig : AbstractProjectConfig() { override fun listeners(): List<TestListener> = listOf(SystemEnvironmentProjectListener(\"foo\", \"bar\")) } System Property Extension In the same fashion as the Environment Extensions, you can override the System Properties ( System.getProperties() ): withSystemProperty(\"foo\", \"bar\") { System.getProperty(\"foo\") shouldBe \"bar\" } And with similar Listeners: class MyTest : FreeSpec() { override fun listeners() = listOf(SystemPropertyListener(\"foo\", \"bar\")) init { \"MyTest\" { System.getProperty(\"foo\") shouldBe \"bar\" } } } System Security Manager Similarly, with System Security Manager you can override the System Security Manager ( System.getSecurityManager() ) withSecurityManager(myManager) { // Usage of security manager } And the Listeners: class MyTest : FreeSpec() { override fun listeners() = listOf(SecurityManagerListener(myManager)) init { // Use my security manager } } System Exit Extensions Sometimes you want to test that your code calls System.exit . For that you can use the System Exit Listeners . The Listener will throw an exception when the System.exit is called, allowing you to catch it and verify: class MyTest : FreeSpec() { override fun listeners() = listOf(SpecSystemExitListener) init { \"Catch exception\" { val thrown: SystemExitException = shouldThrow<SystemExitException> { System.exit(22) } thrown.exitCode shouldBe 22 } } } No-stdout / no-stderr listeners Maybe you want to guarantee that you didn't leave any debug messages around, or that you're always using a Logger in your logging. For that, Kotest provides you with NoSystemOutListener and NoSystemErrListener . These listeners won't allow any messages to be printed straight to System.out or System.err , respectively: // In Project or in Spec override fun listeners() = listOf(NoSystemOutListener, NoSystemErrListener) Locale/Timezone listeners Some codes use and/or are sensitive to the default Locale and default Timezone. Instead of manipulating the system defaults no your own, let Kotest do it for you! withDefaultLocale(Locale.FRANCE) { println(\"My locale is now France! Tr\u00e8s bien!\") } withDefaultTimezone(TimeZone.getTimeZone(ZoneId.of(\"America/Sao_Paulo\"))) { println(\"My timezone is now America/Sao_Paulo! Muito bem!\") } And with the listeners // In Project or in Spec override fun listeners() = listOf( LocaleTestListener(Locale.FRANCE), TimeZoneTestListener(TimeZone.getTimeZone(ZoneId.of(\"America/Sao_Paulo\"))) ) Current instant listeners Sometimes you may want to use the now static functions located in java.time classes for multiple reasons, such as setting the creation date of an entity data class MyEntity(creationDate: LocalDateTime = LocalDateTime.now()) . But what to do when you want to test that value? now will be different each time you call it! For that, Kotest provides ConstantNowListener and withConstantNow functions. While executing your code, your now will always be the value that you want to test against. val foreverNow = LocalDateTime.now() withConstantNow(foreverNow) { LocalDateTime.now() shouldBe foreverNow delay(10) // Code is taking a small amount of time to execute, but `now` changed! LocalDateTime.now() shouldBe foreverNow } Or, with a listener for all the tests: override fun listeners() = listOf( ConstantNowTestListener(foreverNow) ) ATTENTION : withContantNow and ConstantNowTestListener are very sensitive to race conditions. Using them, mocks the static method now which is global to the whole JVM instance, if you're using it while running test in parallel, the results may be inconsistent. JUnit Format XML Report JUnit includes an XML report generator that it calls the legacy xml report . Many tools integrate with this format so it is very useful. However, this report has no concept of nesting tests. Therefore when used with a nested test style in Kotest, it will include parent tests as orphans. To solve this, Kotest has it's own implementation of the same format , that is configurable on whether to include parent tests and/or collapse the names. MockServer Kotest provides an extension for integration with the MockServer library through the kotest-extensions-mockserver module. MockServer is described as an in process server that returns specific responses for different requests via HTTP or HTTPS. When MockServer receives a request it matches that request against the configured expectations. If a match is found it returns that response, otherwise a 404 is returned. Read full instructions here . TestContainers testcontainers-java library that provide lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. kotest-extensions-testcontainers provides integration for using testcontainers-java with kotest. For using kotest-extensions-testcontainers add the below dependency in your build file. testImplementation(\"io.kotest:kotest-extensions-testcontainers:${version}\") Having this dependency in test classpath brings in extension method's in scope which let you convert any Startable such as a DockerContainer into a kotest TestListener, which you can register with Kotest and then Kotest will manage lifecycle of container for you. For example: class DatabaseRepositoryTest : FunSpec({ val redisContainer = GenericContainer<Nothing>(\"redis:5.0.3-alpine\") listener(redisContainer.perTest()) //converts container to listener and registering it with Kotest. test(\"some test which assume to have redis container running\") { // } }) In above example perTest() extension method converts the container into a TestListener which start's the redis container before each test and stop's that after test. Similarly if you want to reuse the container for all tests in a single spec class you can use perSpec() extension method which convert's container into a TestListener which start's the container before running any test in spec and stop's that after all tests, thus a single container is used by all tests in spec class.","title":"Extensions"},{"location":"extensions/#extensions","text":"Kotest integrates with many libraries and frameworks. This page outlines the extensions maintained by the Kotest team.","title":"Extensions"},{"location":"extensions/#allure","text":"Allure is an open-source framework designed to generate detailed and interactive test reports. It works by collecting test data as tests are executed and then compiling that into a final HTML report. Kotest provides an extenstion for Allure and full integration instructions are here .","title":"Allure"},{"location":"extensions/#arrow","text":"The arrow assertion module provives assertions for the functional programming library arrow-kt for types such as Option , Try , and so on. To use this library you need to add kotest-assertions-arrow to your build. Here is an example asserting that an Option variable is a Some with a value \"Foo\" . val option: Option<String> = ... option shouldBe beSome(\"foo\") For the full list of arrow matchers click here . Additionally, the module provides inspectors that work specifically for the NonEmptyList type. For example, we can test that a set of assertions hold only for a single element in a Nel by using the forOne inspector. val list = NonEmptyList(2, 4, 6, 7,8) list.forOne { it.shouldBeOdd() } Other inspectors include forNone , forAll , forExactly(n) , forSome and so on. See the section on inspectors for more details.","title":"Arrow"},{"location":"extensions/#spring","text":"Kotest offers a Spring extension that allows you to test code that wires dependencies using Spring. To use this extension add the kotest-extensions-spring module to your test compile path. In order to let Spring know which configuration class to use, you must annotate your Spec classes with @ContextConfiguration . This should point to a class annotated with the Spring @Configuration annotation. Alternatively, you can use @ActiveProfile to point to a specific application context file . There are two ways to enable spring wiring depending on if you want to use constructor injection, or field injection.","title":"Spring"},{"location":"extensions/#field-injection","text":"If you wish to use field injection, then the SpringListener must be registered with any Spec that uses spring beans. For example: @ContextConfiguration(classes = [(TestConfiguration::class)]) class SpringExampleSpec : WordSpec() { override fun listeners() = listOf(SpringListener) @Autowired var bean: MyBean? = null init { \"Spring Extension\" should { \"have wired up the bean\" { bean shouldNotBe null } } } } You could add the SpringListener project wide by registering the listener in ProjectConfig .","title":"Field Injection"},{"location":"extensions/#constructor-injection","text":"For constructor injection, we use a different implementation called SpringAutowireConstructorExtension which must be registered with ProjectConfig . This extension will intercept each call to create a Spec instance and will autowire the beans declared in the primary constructor. First an example of the project config. class ProjectConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = listOf(SpringAutowireConstructorExtension) } And now an example of a test class which requires a service called UserService in its primary constructor. This service class is just a regular spring bean which has been annotated with @Component. @ContextConfiguration(classes = [(Components::class)]) class SpringAutowiredConstructorTest(service: UserService) : WordSpec() { init { \"SpringListener\" should { \"have autowired the service\" { service.repository.findUser().name shouldBe \"system_user\" } } } }","title":"Constructor Injection"},{"location":"extensions/#final-clases","text":"When using a final class, you may receive a warning from Kotest: Using SpringListener on a final class. If any Spring annotation fails to work, try making this class open If you wish, you can disable this warning by setting the system property kotest.listener.spring.ignore.warning to true.","title":"Final Clases"},{"location":"extensions/#ktor","text":"The kotest-assertions-ktor module provides response matchers for a Ktor application. There are matchers for both TestApplicationResponse if you are using the server side test support, and for HttpResponse if you are using the ktor client classes. To add Ktor matchers, add the following dependency to your project testImplementation(\"io.kotest:kotest-assertions-ktor:${version}\") An example of using the matchers with the server side test support: withTestApplication({ module(testing = true) }) { handleRequest(HttpMethod.Get, \"/\").apply { response shouldHaveStatus HttpStatusCode.OK response shouldNotHaveContent \"failure\" response.shouldHaveHeader(name = \"Authorization\", value = \"Bearer\") response.shouldNotHaveCookie(name = \"Set-Cookie\", cookieValue = \"id=1234\") } } And an example of using the client support: val client = HttpClient(CIO) val resp = client.post(\"http://mydomain.com/foo\") response.shouldHaveStatus(HttpStatusCode.OK) response.shouldHaveHeader(name = \"Authorization\", value = \"Bearer\")","title":"Ktor"},{"location":"extensions/#koin","text":"The Koin DI Framework can be used with Kotest through the KoinListener test listener and its own interface KoinTest . To add the listener to your project, add the depency to your project: testImplementation(\"io.kotest:kotest-extensions-koin:${version}\") With the dependency added, we can use Koin in our tests! class KotestAndKoin : FunSpec(), KoinTest { override fun listeners() = listOf(KoinListener(myKoinModule)) val userService by inject<UserService>() init { test(\"Use user service\") { userService.getUser().username shouldBe \"Kerooker\" } } }","title":"Koin"},{"location":"extensions/#robolectric","text":"Robolectric can be used with Kotest through the RobolectricExtension which can be found in kotest-extensions-robolectric module. To add this module to project you need specify following in your build.gradle : testImplementation 'io.kotest:kotest-extensions-robolectric:<version>' With this dependency added you should add extensions to your project config. For example if you have no such config yet it would look like class MyProjectLevelConfig : AbstractProjectConfig() { override fun extensions(): List<Extension> = super.extensions() + RobolectricExtension() } Of course you can just add this extension to another extensions you're already using. After that done any class which should be ran with Robolectric should be annotated with @RobolectricTest annotation.","title":"Robolectric"},{"location":"extensions/#compilation-test","text":"The kotest-assertions-compiler extension provides matchers to assert that given kotlin code snippet compiles or not. This extension is a wrapper over kotlin-compile-testing and provides following matchers String.shouldCompile() String.shouldNotCompile() File.shouldCompile() File.shouldNotCompile() To add the compilation matcher, add the following dependency to your project testImplementation(\"io.kotest:kotest-assertions-compiler:${version}\") Usage: class CompilationTest: StringSpec() { init { \"shouldCompile test\" { val codeSnippet = \"\"\" val aString: String = \"A valid assignment\" \"\"\".trimMargin() codeSnippet.shouldCompile() File(\"SourceFile.kt\").shouldCompile() } \"shouldNotCompile test\" { val codeSnippet = \"\"\" val aInteger: Int = \"A invalid assignment\" \"\"\".trimMargin() codeSnippet.shouldNotCompile() File(\"SourceFile.kt\").shouldNotCompile() } } } During checking of code snippet compilation the classpath of calling process is inherited, which means any dependencies which are available in calling process will also be available while compiling the code snippet.","title":"Compilation test"},{"location":"extensions/#system-extensions","text":"Sometimes your code might use some functionalities straight from the JVM, which are very hard to simulate. With Kotest System Extensions, these difficulties are made easy to mock and simulate, and your code can be tested correctly. After changing the system and using the extensions, the previous state will be restored. Attention : This code is sensitive to concurrency. Due to the JVM specification there can only be one instance of these extensions running (For example: Only one Environment map must exist). If you try to run more than one instance at a time, the result is unknown.","title":"System Extensions"},{"location":"extensions/#system-environment","text":"With System Environment Extension you can simulate how the System Environment is behaving. That is, what you're obtaining from System.getenv() . Kotest provides some extension functions that provides a System Environment in a specific scope: withEnvironment(\"FooKey\", \"BarValue\") { System.getenv(\"FooKey\") shouldBe \"BarValue\" // System environment overriden! } You can also use multiple values in this extension, through a map or list of pairs. withEnvironment(mapOf(\"FooKey\" to \"BarValue\", \"BarKey\" to \"FooValue\")) { // Use FooKey and BarKey } These functions will add the keys and values if they're not currently present in the environment, and will override them if they are. Any keys untouched by the function will remain in the environment, and won't be messed with. Instead of extensions functions, you can also use the provided Listeners to apply these functionalities in a bigger scope. There's an alternative for the Spec/Per test level, and an alternative for the Project Level. class MyTest : FreeSpec() { override fun listeners() = listOf(SystemEnvironmentTestListener(\"foo\", \"bar\")) init { \"MyTest\" { System.getenv(\"foo\") shouldBe \"bar\" } } } class ProjectConfig : AbstractProjectConfig() { override fun listeners(): List<TestListener> = listOf(SystemEnvironmentProjectListener(\"foo\", \"bar\")) }","title":"System Environment"},{"location":"extensions/#system-property-extension","text":"In the same fashion as the Environment Extensions, you can override the System Properties ( System.getProperties() ): withSystemProperty(\"foo\", \"bar\") { System.getProperty(\"foo\") shouldBe \"bar\" } And with similar Listeners: class MyTest : FreeSpec() { override fun listeners() = listOf(SystemPropertyListener(\"foo\", \"bar\")) init { \"MyTest\" { System.getProperty(\"foo\") shouldBe \"bar\" } } }","title":"System Property Extension"},{"location":"extensions/#system-security-manager","text":"Similarly, with System Security Manager you can override the System Security Manager ( System.getSecurityManager() ) withSecurityManager(myManager) { // Usage of security manager } And the Listeners: class MyTest : FreeSpec() { override fun listeners() = listOf(SecurityManagerListener(myManager)) init { // Use my security manager } }","title":"System Security Manager"},{"location":"extensions/#system-exit-extensions","text":"Sometimes you want to test that your code calls System.exit . For that you can use the System Exit Listeners . The Listener will throw an exception when the System.exit is called, allowing you to catch it and verify: class MyTest : FreeSpec() { override fun listeners() = listOf(SpecSystemExitListener) init { \"Catch exception\" { val thrown: SystemExitException = shouldThrow<SystemExitException> { System.exit(22) } thrown.exitCode shouldBe 22 } } }","title":"System Exit Extensions"},{"location":"extensions/#no-stdout-no-stderr-listeners","text":"Maybe you want to guarantee that you didn't leave any debug messages around, or that you're always using a Logger in your logging. For that, Kotest provides you with NoSystemOutListener and NoSystemErrListener . These listeners won't allow any messages to be printed straight to System.out or System.err , respectively: // In Project or in Spec override fun listeners() = listOf(NoSystemOutListener, NoSystemErrListener)","title":"No-stdout / no-stderr listeners"},{"location":"extensions/#localetimezone-listeners","text":"Some codes use and/or are sensitive to the default Locale and default Timezone. Instead of manipulating the system defaults no your own, let Kotest do it for you! withDefaultLocale(Locale.FRANCE) { println(\"My locale is now France! Tr\u00e8s bien!\") } withDefaultTimezone(TimeZone.getTimeZone(ZoneId.of(\"America/Sao_Paulo\"))) { println(\"My timezone is now America/Sao_Paulo! Muito bem!\") } And with the listeners // In Project or in Spec override fun listeners() = listOf( LocaleTestListener(Locale.FRANCE), TimeZoneTestListener(TimeZone.getTimeZone(ZoneId.of(\"America/Sao_Paulo\"))) )","title":"Locale/Timezone listeners"},{"location":"extensions/#current-instant-listeners","text":"Sometimes you may want to use the now static functions located in java.time classes for multiple reasons, such as setting the creation date of an entity data class MyEntity(creationDate: LocalDateTime = LocalDateTime.now()) . But what to do when you want to test that value? now will be different each time you call it! For that, Kotest provides ConstantNowListener and withConstantNow functions. While executing your code, your now will always be the value that you want to test against. val foreverNow = LocalDateTime.now() withConstantNow(foreverNow) { LocalDateTime.now() shouldBe foreverNow delay(10) // Code is taking a small amount of time to execute, but `now` changed! LocalDateTime.now() shouldBe foreverNow } Or, with a listener for all the tests: override fun listeners() = listOf( ConstantNowTestListener(foreverNow) ) ATTENTION : withContantNow and ConstantNowTestListener are very sensitive to race conditions. Using them, mocks the static method now which is global to the whole JVM instance, if you're using it while running test in parallel, the results may be inconsistent.","title":"Current instant listeners"},{"location":"extensions/#junit-format-xml-report","text":"JUnit includes an XML report generator that it calls the legacy xml report . Many tools integrate with this format so it is very useful. However, this report has no concept of nesting tests. Therefore when used with a nested test style in Kotest, it will include parent tests as orphans. To solve this, Kotest has it's own implementation of the same format , that is configurable on whether to include parent tests and/or collapse the names.","title":"JUnit Format XML Report"},{"location":"extensions/#mockserver","text":"Kotest provides an extension for integration with the MockServer library through the kotest-extensions-mockserver module. MockServer is described as an in process server that returns specific responses for different requests via HTTP or HTTPS. When MockServer receives a request it matches that request against the configured expectations. If a match is found it returns that response, otherwise a 404 is returned. Read full instructions here .","title":"MockServer"},{"location":"extensions/#testcontainers","text":"testcontainers-java library that provide lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. kotest-extensions-testcontainers provides integration for using testcontainers-java with kotest. For using kotest-extensions-testcontainers add the below dependency in your build file. testImplementation(\"io.kotest:kotest-extensions-testcontainers:${version}\") Having this dependency in test classpath brings in extension method's in scope which let you convert any Startable such as a DockerContainer into a kotest TestListener, which you can register with Kotest and then Kotest will manage lifecycle of container for you. For example: class DatabaseRepositoryTest : FunSpec({ val redisContainer = GenericContainer<Nothing>(\"redis:5.0.3-alpine\") listener(redisContainer.perTest()) //converts container to listener and registering it with Kotest. test(\"some test which assume to have redis container running\") { // } }) In above example perTest() extension method converts the container into a TestListener which start's the redis container before each test and stop's that after test. Similarly if you want to reuse the container for all tests in a single spec class you can use perSpec() extension method which convert's container into a TestListener which start's the container before running any test in spec and stop's that after all tests, thus a single container is used by all tests in spec class.","title":"TestContainers"},{"location":"inspectors/","text":"Inspectors Inspectors allow us to test elements in a collection. They are extension functions for collections and arrays that test that all, none or some of the elements pass the given assertions. For example, to test that all elements in a collection contain an underscore and start with \"aa\" we could do: class StringSpecExample : StringSpec({ \"your test case\" { val xs = listOf(\"aa_1\", \"aa_2\", \"aa_3\") xs.forAll { it.shouldContain(\"_\") it.shouldStartWith(\"aa\") } } }) Similarly, if we wanted to asset that no elements in a collection passed the assertions, we can do: xs.forNone { it.shouldContain(\"x\") it.shouldStartWith(\"bb\") } The full list of inspectors are: forAll which asserts every element passes the assertions forNone which asserts no element passes forOne which asserts only a single element passed forAtMostOne which asserts that either 0 or 1 elements pass forAtLeastOne which asserts that 1 or more elements passed forAtLeast(k) which is a generalization that k or more elements passed forAtMost(k) which is a generalization that k or fewer elements passed forAny which is an alias for forAtLeastOne forSome which asserts that between 1 and n-1 elements passed. Ie, if NONE pass or ALL pass then we consider that a failure. forExactly(k) which is a generalization that exactly k elements passed. This is the basis for the implementation of the other methods","title":"Inspectors"},{"location":"inspectors/#inspectors","text":"Inspectors allow us to test elements in a collection. They are extension functions for collections and arrays that test that all, none or some of the elements pass the given assertions. For example, to test that all elements in a collection contain an underscore and start with \"aa\" we could do: class StringSpecExample : StringSpec({ \"your test case\" { val xs = listOf(\"aa_1\", \"aa_2\", \"aa_3\") xs.forAll { it.shouldContain(\"_\") it.shouldStartWith(\"aa\") } } }) Similarly, if we wanted to asset that no elements in a collection passed the assertions, we can do: xs.forNone { it.shouldContain(\"x\") it.shouldStartWith(\"bb\") } The full list of inspectors are: forAll which asserts every element passes the assertions forNone which asserts no element passes forOne which asserts only a single element passed forAtMostOne which asserts that either 0 or 1 elements pass forAtLeastOne which asserts that 1 or more elements passed forAtLeast(k) which is a generalization that k or more elements passed forAtMost(k) which is a generalization that k or fewer elements passed forAny which is an alias for forAtLeastOne forSome which asserts that between 1 and n-1 elements passed. Ie, if NONE pass or ALL pass then we consider that a failure. forExactly(k) which is a generalization that exactly k elements passed. This is the basis for the implementation of the other methods","title":"Inspectors"},{"location":"intellij/","text":"IntelliJ Plugin Kotest offers an IntelliJ plugin available at the jetbrains plugin marketplace (search from within IntelliJ). This plugin provides run icons for each test, a tool window for test navigation, duplicated test highlighting, assertion intentions, and more. Gutter Icons The plugin provides gutter run icons for specs, top level tests, and nested tests. Any tests disabled via a bang or by xfunctions such as xdescribe , will have a disabled test icon in the gutter. Running Tests If you execute a spec from the gutter icon, then all tests in that spec will be executed. If you execute a test, then that test and all nested tests will be executed. Tool Window The plugin provides a tool window view which displays the structure of your tests. The window describes the currently selected test file, which includes any specs defined in that file and tests contained inside those specs. The tree layout will mirror the structure of your tests for easy navigation. The tool window will include lifecycle callback methods (such as before / after test) if defined, as well as included test factories. Clicking on a spec, test, include or callback will navigate directly to that element in the source editor. Any tests that have been disabled using the bang prefix will have a different icon. You can execute (run/debug/run with coverage) a test or spec directly from this window. In addition, the window shows all test modules and allows you to run all tests in that module. Modules, callbacks, and includes can be filtered out if you don't wish to see them. They are included by default. Duplicated Test Highlighting You cannot have two tests with the same name. The plugin will highlight any duplicated test names as errors. Context Menu Run / Debug Right clicking on a package will allow you to run, debug or run with coverage all the tests inside that package. Intentions This plugin has some basic intentions. For example, you can quickly mark a test as disabled. Or you can highlight some text and mark it as should throw, or surround with a soft assertion block.","title":"Intellij plugin"},{"location":"intellij/#intellij-plugin","text":"Kotest offers an IntelliJ plugin available at the jetbrains plugin marketplace (search from within IntelliJ). This plugin provides run icons for each test, a tool window for test navigation, duplicated test highlighting, assertion intentions, and more.","title":"IntelliJ Plugin"},{"location":"intellij/#gutter-icons","text":"The plugin provides gutter run icons for specs, top level tests, and nested tests. Any tests disabled via a bang or by xfunctions such as xdescribe , will have a disabled test icon in the gutter.","title":"Gutter Icons"},{"location":"intellij/#running-tests","text":"If you execute a spec from the gutter icon, then all tests in that spec will be executed. If you execute a test, then that test and all nested tests will be executed.","title":"Running Tests"},{"location":"intellij/#tool-window","text":"The plugin provides a tool window view which displays the structure of your tests. The window describes the currently selected test file, which includes any specs defined in that file and tests contained inside those specs. The tree layout will mirror the structure of your tests for easy navigation. The tool window will include lifecycle callback methods (such as before / after test) if defined, as well as included test factories. Clicking on a spec, test, include or callback will navigate directly to that element in the source editor. Any tests that have been disabled using the bang prefix will have a different icon. You can execute (run/debug/run with coverage) a test or spec directly from this window. In addition, the window shows all test modules and allows you to run all tests in that module. Modules, callbacks, and includes can be filtered out if you don't wish to see them. They are included by default.","title":"Tool Window"},{"location":"intellij/#duplicated-test-highlighting","text":"You cannot have two tests with the same name. The plugin will highlight any duplicated test names as errors.","title":"Duplicated Test Highlighting"},{"location":"intellij/#context-menu-run-debug","text":"Right clicking on a package will allow you to run, debug or run with coverage all the tests inside that package.","title":"Context Menu Run / Debug"},{"location":"intellij/#intentions","text":"This plugin has some basic intentions. For example, you can quickly mark a test as disabled. Or you can highlight some text and mark it as should throw, or surround with a soft assertion block.","title":"Intentions"},{"location":"isolation_mode/","text":"Isolation Modes All specs allow you to control how the test engine creates instances of Specs for test cases. This behavior is called the isolation mode and is controlled by an enum IsolationMode . There are three values: SingleInstance , InstancePerLeaf , and InstancePerTest . If you want tests to be executed inside fresh instances of the spec - to allow for state shared between tests to be reset - you can change the isolation mode. This can be done by using the DSL such as: class MyTestClass : WordSpec({ isolationMode = IsolationMode.SingleInstance // tests here }) Or if you prefer function overrides, you can override fun isolationMode(): IsolationMode : class MyTestClass : WordSpec() { override fun isolationMode() = IsolationMode.SingleInstance init { // tests here } } Single Instance The default isolation mode is SingleInstance whereby one instance of the Spec class is created and then each test case is exected in turn until all tests have completed. For example, in the following spec, the same id would be printed three times as the same instance is used for all tests. class SingleInstanceExample : WordSpec({ val id = UUID.randomUUID() \"a\" should { println(id) \"b\" { println(id) } \"c\" { println(id) } } }) Warning The default is the same as ScalaTest (the inspiration for this framework), Jest, Jasmine, and other Javascript frameworks, but different to JUnit. InstancePerTest The next mode is IsolationMode.InstancePerTest where a new spec will be created for every test case, including inner contexts. In other words, outer contexts will execute as a \"stand alone\" test in their own instance of the spec. An example should make this clear. class InstancePerTestExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerTest init { \"a\" should { println(\"Hello\") \"b\" { println(\"From\") } \"c\" { println(\"Sam\") } } } } Do you see how we've overriden the isolationMode function here. When this is executed, the following will be printed: Hello Hello From Hello Sam This is because the outer context (test \"a\") will be executed first. Then it will be executed again for test \"b\", and then again for test \"c\". Each time in a clean instance of the Spec class. This is very useful when we want to re-use variables. Another example will show how the variables are reset. class InstancePerTestExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerTest val counter = AtomicInteger(0) init { \"a\" should { println(\"a=\" + counter.getAndIncrement()) \"b\" { println(\"b=\" + counter.getAndIncrement()) } \"c\" { println(\"c=\" + counter.getAndIncrement()) } } } } This time, the output will be: a=0 a=0 b=1 a=0 c=1 InstancePerLeaf The next mode is IsolationMode.InstancePerLeaf where a new spec will be created for every leaf test case - so excluding inner contexts. In other words, inner contexts are only executed as part of the \"path\" to an outer test. An example should make this clear. class InstancePerLeafExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerLeaf init { \"a\" should { println(\"Hello\") \"b\" { println(\"From\") } \"c\" { println(\"Sam\") } } } } When this is executed, the following will be printed: Hello From Hello Sam This is because the outer context - test \"a\" - will be executed first, followed by test \"b\" in the same instance. Then a new spec will be created, and test \"a\" again executed, followed by test \"c\". Another example will show how the variables are reset. class InstancePerLeafExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerLeaf val counter = AtomicInteger(0) init { \"a\" should { println(\"a=\" + counter.getAndIncrement()) \"b\" { println(\"b=\" + counter.getAndIncrement()) } \"c\" { println(\"c=\" + counter.getAndIncrement()) } } } } This time, the output will be: a=0 b=1 a=0 c=1 Global Isolation Mode Rather than setting the isolation mode in every spec, we can set it globally in project config or via a system property. System Property To set the global isolation mode at the command line, use the system property kotest.framework.isolation.mode with one of the values: InstancePerTest InstancePerLeaf SingleInstance Info The values are case sensitive. Config See the docs on setting up project wide config , and then add the isolation mode you want to be the default. For example: class ProjectConfig: AbstractProjectConfig() { override val isolationMode = IsolationMode.InstancePerLeaf } Info Setting an isolation mode in a Spec will always override the project wide setting.","title":"Isolation mode"},{"location":"isolation_mode/#isolation-modes","text":"All specs allow you to control how the test engine creates instances of Specs for test cases. This behavior is called the isolation mode and is controlled by an enum IsolationMode . There are three values: SingleInstance , InstancePerLeaf , and InstancePerTest . If you want tests to be executed inside fresh instances of the spec - to allow for state shared between tests to be reset - you can change the isolation mode. This can be done by using the DSL such as: class MyTestClass : WordSpec({ isolationMode = IsolationMode.SingleInstance // tests here }) Or if you prefer function overrides, you can override fun isolationMode(): IsolationMode : class MyTestClass : WordSpec() { override fun isolationMode() = IsolationMode.SingleInstance init { // tests here } }","title":"Isolation Modes"},{"location":"isolation_mode/#single-instance","text":"The default isolation mode is SingleInstance whereby one instance of the Spec class is created and then each test case is exected in turn until all tests have completed. For example, in the following spec, the same id would be printed three times as the same instance is used for all tests. class SingleInstanceExample : WordSpec({ val id = UUID.randomUUID() \"a\" should { println(id) \"b\" { println(id) } \"c\" { println(id) } } }) Warning The default is the same as ScalaTest (the inspiration for this framework), Jest, Jasmine, and other Javascript frameworks, but different to JUnit.","title":"Single Instance"},{"location":"isolation_mode/#instancepertest","text":"The next mode is IsolationMode.InstancePerTest where a new spec will be created for every test case, including inner contexts. In other words, outer contexts will execute as a \"stand alone\" test in their own instance of the spec. An example should make this clear. class InstancePerTestExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerTest init { \"a\" should { println(\"Hello\") \"b\" { println(\"From\") } \"c\" { println(\"Sam\") } } } } Do you see how we've overriden the isolationMode function here. When this is executed, the following will be printed: Hello Hello From Hello Sam This is because the outer context (test \"a\") will be executed first. Then it will be executed again for test \"b\", and then again for test \"c\". Each time in a clean instance of the Spec class. This is very useful when we want to re-use variables. Another example will show how the variables are reset. class InstancePerTestExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerTest val counter = AtomicInteger(0) init { \"a\" should { println(\"a=\" + counter.getAndIncrement()) \"b\" { println(\"b=\" + counter.getAndIncrement()) } \"c\" { println(\"c=\" + counter.getAndIncrement()) } } } } This time, the output will be: a=0 a=0 b=1 a=0 c=1","title":"InstancePerTest"},{"location":"isolation_mode/#instanceperleaf","text":"The next mode is IsolationMode.InstancePerLeaf where a new spec will be created for every leaf test case - so excluding inner contexts. In other words, inner contexts are only executed as part of the \"path\" to an outer test. An example should make this clear. class InstancePerLeafExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerLeaf init { \"a\" should { println(\"Hello\") \"b\" { println(\"From\") } \"c\" { println(\"Sam\") } } } } When this is executed, the following will be printed: Hello From Hello Sam This is because the outer context - test \"a\" - will be executed first, followed by test \"b\" in the same instance. Then a new spec will be created, and test \"a\" again executed, followed by test \"c\". Another example will show how the variables are reset. class InstancePerLeafExample : WordSpec() { override fun isolationMode(): IsolationMode = IsolationMode.InstancePerLeaf val counter = AtomicInteger(0) init { \"a\" should { println(\"a=\" + counter.getAndIncrement()) \"b\" { println(\"b=\" + counter.getAndIncrement()) } \"c\" { println(\"c=\" + counter.getAndIncrement()) } } } } This time, the output will be: a=0 b=1 a=0 c=1","title":"InstancePerLeaf"},{"location":"isolation_mode/#global-isolation-mode","text":"Rather than setting the isolation mode in every spec, we can set it globally in project config or via a system property.","title":"Global Isolation Mode"},{"location":"isolation_mode/#system-property","text":"To set the global isolation mode at the command line, use the system property kotest.framework.isolation.mode with one of the values: InstancePerTest InstancePerLeaf SingleInstance Info The values are case sensitive.","title":"System Property"},{"location":"isolation_mode/#config","text":"See the docs on setting up project wide config , and then add the isolation mode you want to be the default. For example: class ProjectConfig: AbstractProjectConfig() { override val isolationMode = IsolationMode.InstancePerLeaf } Info Setting an isolation mode in a Spec will always override the project wide setting.","title":"Config"},{"location":"listeners/","text":"Listeners It is a common requirement to execute code before or after tests or specs. For instance, to start (or reset) and shutdown an embedded database required by a test. Kotest provides multiple callbacks into the test lifecycle which are used for this purpose. TestListener The main interface is TestListener . The following sections describe the callbacks available on this interface. Callback Description beforeContainer Invoked directly before each test with type TestType.Container is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterContainer Invoked immediately after a TestCase with type TestType.Container has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeEach Invoked directly before each test with type TestType.Test is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterEach Invoked immediately after a TestCase with type TestType.Test has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeAny Invoked directly before each test with any TestType is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterAny Invoked immediately after a TestCase with any TestType has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeTest Invoked directly before each test is executed with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. This callback has the same behavior as beforeAny . afterTest Invoked immediately after a TestCase has finished with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. This callback has the same behavior as afterAny . beforeSpec Invoked after the Engine instantiates a spec to be used as part of a test execution. The callback is provided with the Spec instance that the test will be executed under. If a spec is instantiated multiple times - for example, if InstancePerTest or InstancePerLeaf isolation modes are used, then this callback will be invoked for each instance created, just before the first test (or only test) is executed for that spec. This callback should be used if you need to perform setup each time a new spec instance is created. If you simply need to perform setup once per class file, then use prepareSpec. This callback runs before any beforeTest functions are invoked. When running in the default SingleInstance isolation mode, then this callback and prepareSpec are functionally the same since all tests will run in the same spec instance. afterSpec Is invoked after the TestCase s that are part of a particular spec instance have completed. If a spec is instantiated multiple times - for example, if InstancePerTest or InstancePerLeaf isolation modes are used, then this callback will be invoked for each instantiated spec, after the tests that are applicable to that spec instance have returned. This callback should be used if you need to perform cleanup after each individual spec instance. If you need to perform cleanup once per class file, then use finalizeSpec. This callback runs after any afterTest callbacks have been invoked. When running in the default SingleInstance isolation mode, then this callback and finalizeSpec are functionally the same since all tests will run in the same spec instance. prepareSpec Called once per spec, when the engine is preparing to execute the tests for that spec. The KClass instance of the spec is provided as a parameter. Regardless of how many times the spec is instantiated, for example, if InstancePerTest or InstancePerLeaf isolation modes are used, this callback will only be invoked once. If there are no active tests in a spec, then this callback will still be invoked. When running in the default SingleInstance isolation mode, then this callback and beforeSpec are functionally the same since all tests will run in the same spec instance. finalizeSpec Called once per Spec , after all tests have completed for that spec. Regardless of how many times the spec is instantiated, for example, if InstancePerTest or InstancePerLeaf isolation modes are used, this callback will only be invoked once. The results parameter contains every TestCase , along with the result of that test, including tests that were ignored (which will have a TestResult that has TestStatus.Ignored ). When running in the default SingleInstance isolation mode, then this callback and afterSpec are functionally the same since all tests will run in the same spec instance. beforeInvocation Invoked before each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs. If you are running a test with the default single invocation then this callback is effectively the same as beforeTest . Note: If you have set multiple invocations _and multiple threads, then these callbacks will be invoked concurrently._ afterInvocation Invoked after each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs. If you are running a test with the default single invocation then this callback is effectively the same as afterTest . Note: If you have set multiple invocations _and multiple threads, then these callbacks will be invoked concurrently._ ProjectListener The other listener interface is ProjectListener which defines two callbacks. Callback Description beforeProject This callback is invoked once before any spec discovery and execution takes place. afterProject This callback is invoked once after all specs have completed. This callback is executed even if there are errors in specs / test cases. How to use a Listener There are several ways to use the methods in a listener. DSL Methods The first and simplest, is to use the DSL methods available inside a Spec which create and register a TestListener for you. For example, we can invoke beforeTest or afterTest (and others) directly alongside our tests. class TestSpec : WordSpec({ beforeTest { println(\"Starting a test $it\") } afterTest { (test, result) -> println(\"Finished spec with result $result\") } \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } }) Behind the scenes, these DSL methods will create an instance of TestListener , overriding the appropriate functions, and ensuring that this test listener is registered to run. You can use afterProject as a DSL method which will create an instance of ProjectListener , but there is no beforeProject because by the time the framework is at this stage of detecting a spec, the project has already started! DSL methods with functions Since these DSL methods accept functions, we can pull out logic to a function and re-use it in several places. The BeforeTest type used on the function definition is an alias to suspend (TestCase) -> Unit to keep things simple. There are aliases for the types of each of the callbacks. val startTest: BeforeTest = { println(\"Starting a test $it\") } class TestSpec : WordSpec({ // used once beforeTest(startTest) \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } }) class OtherSpec : WordSpec({ // used twice beforeTest(startTest) \"this test\" should { \"fail\" { fail(\"boom\") } } }) Overriding callback functions in a Spec The second, related, method is to override the callback functions in the Spec. This is essentially just a variation on the first method. class TestSpec : WordSpec() { override fun beforeTest(testCase: TestCase) { println(\"Starting a test $testCase\") } init { \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } } } Standalone Listener instances The next method is to create a standalone implementation of the TestListener or ProjectListener interface and register it. This is useful for TestListener s if you want to reuse a listener that has several dependant functions (such as starting and stopping a resource). class MyTestListener : TestListener { override suspend fun beforeSpec(spec:Spec) { // power up kafka } override suspend fun afterSpec(spec: Spec) { // shutdown kafka } } class TestSpec : WordSpec({ listener(MyTestListener()) // tests here }) Any listeners registered directly inside a Spec will be used for all tests in that spec (including test factories and nested tests). Maybe you want a TestListener to run for every spec in the entire project. To do that, you can either mark the listener with @AutoScan , or you can register the listener via project config. For more information on this see ProjectConfig . Instances of ProjectListener must be registered using @AutoScan or using project config level, since the beforeProject callback needs to be registered and executed any spec discovery begins. An example of @Autoscan on a project listener: @AutoScan object MyProjectListener : ProjectListener { override suspend fun beforeProject() { println(\"Project starting\") } override suspend fun afterProject() { println(\"Project complete\") } } Real Examples System Out Listener A real example of a listener in example, is our NoSystemOutListener which throws an error if any output is written to standard out. class MyTestSpec : DescribeSpec({ listener(NoSystemOutListener) describe(\"All these tests should not write to standard out\") { it(\"silence in the court\") { println(\"boom\") // failure } } }) Timer Listener Another example would be if we wanted to log the time taken for each test case. We can do this by using the beforeTest and afterTest functions as follows: object TimerListener : TestListener { var started = 0L override fun beforeTest(testCase: TestCase): Unit { started = System.currentTimeMillis() } override fun afterTest(testCase: TestCase, result: TestResult): Unit { println(\"Duration of ${testCase.description} = \" + (System.currentTimeMillis() - started)) } } Then we can register like so: class MyTestClass : FunSpec({ listeners(TimerListener) // tests here }) Or we could register it project wide: object MyConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf(TimerListener) } These functions will now be invoked for every test case inside the MyTestClass test class. Maybe you want this listener to run for every test in the entire project. To do that, you would register the listener with the project config singleton. For more information on this see ProjectConfig .","title":"Listeners"},{"location":"listeners/#listeners","text":"It is a common requirement to execute code before or after tests or specs. For instance, to start (or reset) and shutdown an embedded database required by a test. Kotest provides multiple callbacks into the test lifecycle which are used for this purpose.","title":"Listeners"},{"location":"listeners/#testlistener","text":"The main interface is TestListener . The following sections describe the callbacks available on this interface. Callback Description beforeContainer Invoked directly before each test with type TestType.Container is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterContainer Invoked immediately after a TestCase with type TestType.Container has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeEach Invoked directly before each test with type TestType.Test is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterEach Invoked immediately after a TestCase with type TestType.Test has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeAny Invoked directly before each test with any TestType is executed, with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. afterAny Invoked immediately after a TestCase with any TestType has finished, with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. beforeTest Invoked directly before each test is executed with the TestCase instance as a parameter. If the test is marked as ignored / disabled / inactive, then this callback won't be invoked. This callback has the same behavior as beforeAny . afterTest Invoked immediately after a TestCase has finished with the TestResult of that test. If a test case was skipped (ignored / disabled / inactive) then this callback will not be invoked for that particular test case. The callback will execute even if the test fails. This callback has the same behavior as afterAny . beforeSpec Invoked after the Engine instantiates a spec to be used as part of a test execution. The callback is provided with the Spec instance that the test will be executed under. If a spec is instantiated multiple times - for example, if InstancePerTest or InstancePerLeaf isolation modes are used, then this callback will be invoked for each instance created, just before the first test (or only test) is executed for that spec. This callback should be used if you need to perform setup each time a new spec instance is created. If you simply need to perform setup once per class file, then use prepareSpec. This callback runs before any beforeTest functions are invoked. When running in the default SingleInstance isolation mode, then this callback and prepareSpec are functionally the same since all tests will run in the same spec instance. afterSpec Is invoked after the TestCase s that are part of a particular spec instance have completed. If a spec is instantiated multiple times - for example, if InstancePerTest or InstancePerLeaf isolation modes are used, then this callback will be invoked for each instantiated spec, after the tests that are applicable to that spec instance have returned. This callback should be used if you need to perform cleanup after each individual spec instance. If you need to perform cleanup once per class file, then use finalizeSpec. This callback runs after any afterTest callbacks have been invoked. When running in the default SingleInstance isolation mode, then this callback and finalizeSpec are functionally the same since all tests will run in the same spec instance. prepareSpec Called once per spec, when the engine is preparing to execute the tests for that spec. The KClass instance of the spec is provided as a parameter. Regardless of how many times the spec is instantiated, for example, if InstancePerTest or InstancePerLeaf isolation modes are used, this callback will only be invoked once. If there are no active tests in a spec, then this callback will still be invoked. When running in the default SingleInstance isolation mode, then this callback and beforeSpec are functionally the same since all tests will run in the same spec instance. finalizeSpec Called once per Spec , after all tests have completed for that spec. Regardless of how many times the spec is instantiated, for example, if InstancePerTest or InstancePerLeaf isolation modes are used, this callback will only be invoked once. The results parameter contains every TestCase , along with the result of that test, including tests that were ignored (which will have a TestResult that has TestStatus.Ignored ). When running in the default SingleInstance isolation mode, then this callback and afterSpec are functionally the same since all tests will run in the same spec instance. beforeInvocation Invoked before each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs. If you are running a test with the default single invocation then this callback is effectively the same as beforeTest . Note: If you have set multiple invocations _and multiple threads, then these callbacks will be invoked concurrently._ afterInvocation Invoked after each 'run' of a test, with a flag indicating the iteration number. This callback is useful if you have set a test to have multiple invocations via config and want to do some setup / teardown between runs. If you are running a test with the default single invocation then this callback is effectively the same as afterTest . Note: If you have set multiple invocations _and multiple threads, then these callbacks will be invoked concurrently._","title":"TestListener"},{"location":"listeners/#projectlistener","text":"The other listener interface is ProjectListener which defines two callbacks. Callback Description beforeProject This callback is invoked once before any spec discovery and execution takes place. afterProject This callback is invoked once after all specs have completed. This callback is executed even if there are errors in specs / test cases.","title":"ProjectListener"},{"location":"listeners/#how-to-use-a-listener","text":"There are several ways to use the methods in a listener.","title":"How to use a Listener"},{"location":"listeners/#dsl-methods","text":"The first and simplest, is to use the DSL methods available inside a Spec which create and register a TestListener for you. For example, we can invoke beforeTest or afterTest (and others) directly alongside our tests. class TestSpec : WordSpec({ beforeTest { println(\"Starting a test $it\") } afterTest { (test, result) -> println(\"Finished spec with result $result\") } \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } }) Behind the scenes, these DSL methods will create an instance of TestListener , overriding the appropriate functions, and ensuring that this test listener is registered to run. You can use afterProject as a DSL method which will create an instance of ProjectListener , but there is no beforeProject because by the time the framework is at this stage of detecting a spec, the project has already started!","title":"DSL Methods"},{"location":"listeners/#dsl-methods-with-functions","text":"Since these DSL methods accept functions, we can pull out logic to a function and re-use it in several places. The BeforeTest type used on the function definition is an alias to suspend (TestCase) -> Unit to keep things simple. There are aliases for the types of each of the callbacks. val startTest: BeforeTest = { println(\"Starting a test $it\") } class TestSpec : WordSpec({ // used once beforeTest(startTest) \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } }) class OtherSpec : WordSpec({ // used twice beforeTest(startTest) \"this test\" should { \"fail\" { fail(\"boom\") } } })","title":"DSL methods with functions"},{"location":"listeners/#overriding-callback-functions-in-a-spec","text":"The second, related, method is to override the callback functions in the Spec. This is essentially just a variation on the first method. class TestSpec : WordSpec() { override fun beforeTest(testCase: TestCase) { println(\"Starting a test $testCase\") } init { \"this test\" should { \"be alive\" { println(\"Johnny5 is alive!\") } } } }","title":"Overriding callback functions in a Spec"},{"location":"listeners/#standalone-listener-instances","text":"The next method is to create a standalone implementation of the TestListener or ProjectListener interface and register it. This is useful for TestListener s if you want to reuse a listener that has several dependant functions (such as starting and stopping a resource). class MyTestListener : TestListener { override suspend fun beforeSpec(spec:Spec) { // power up kafka } override suspend fun afterSpec(spec: Spec) { // shutdown kafka } } class TestSpec : WordSpec({ listener(MyTestListener()) // tests here }) Any listeners registered directly inside a Spec will be used for all tests in that spec (including test factories and nested tests). Maybe you want a TestListener to run for every spec in the entire project. To do that, you can either mark the listener with @AutoScan , or you can register the listener via project config. For more information on this see ProjectConfig . Instances of ProjectListener must be registered using @AutoScan or using project config level, since the beforeProject callback needs to be registered and executed any spec discovery begins. An example of @Autoscan on a project listener: @AutoScan object MyProjectListener : ProjectListener { override suspend fun beforeProject() { println(\"Project starting\") } override suspend fun afterProject() { println(\"Project complete\") } }","title":"Standalone Listener instances"},{"location":"listeners/#real-examples","text":"","title":"Real Examples"},{"location":"listeners/#system-out-listener","text":"A real example of a listener in example, is our NoSystemOutListener which throws an error if any output is written to standard out. class MyTestSpec : DescribeSpec({ listener(NoSystemOutListener) describe(\"All these tests should not write to standard out\") { it(\"silence in the court\") { println(\"boom\") // failure } } })","title":"System Out Listener"},{"location":"listeners/#timer-listener","text":"Another example would be if we wanted to log the time taken for each test case. We can do this by using the beforeTest and afterTest functions as follows: object TimerListener : TestListener { var started = 0L override fun beforeTest(testCase: TestCase): Unit { started = System.currentTimeMillis() } override fun afterTest(testCase: TestCase, result: TestResult): Unit { println(\"Duration of ${testCase.description} = \" + (System.currentTimeMillis() - started)) } } Then we can register like so: class MyTestClass : FunSpec({ listeners(TimerListener) // tests here }) Or we could register it project wide: object MyConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf(TimerListener) } These functions will now be invoked for every test case inside the MyTestClass test class. Maybe you want this listener to run for every test in the entire project. To do that, you would register the listener with the project config singleton. For more information on this see ProjectConfig .","title":"Timer Listener"},{"location":"matchers/","text":"Matchers A Matcher is the Kotest term for an assertion that performs a specific test. For example, a matcher may test that a double is greater than zero. Or it it may test that a file is not empty. Kotest currently has approximately 325 matchers split across several modules. Most of these matchers are for standard library types. Others are project specific. Additionally, there are matchers provided by third party libraries. Kotest matchers are framework agnostic . You can use them with the Kotest framework, or with any other framework. If you are happy with JUnit, you can still use the powerful matchers provided by the kotest assertion modules. Matchers can be used in two styles: Extension functions like a.shouldBe(b) or a.shouldStartWith(\"foo\") Infix functions like a shouldBe b or a should startWith(\"foo\") Both styles are supported. The advantage of the extension function style is that the IDE can autocomplete for you, but some people may prefer the infix style as it is slightly cleaner. Matchers can be negated by using shouldNot instead of should for the infix style. For example, a shouldNot startWith(\"boo\") . For the extension function style, each function has an equivalent negated version, for example, a.shouldNotStartWith(\"boo\") . Kotest Matcher Modules These modules provide the core matcher experience. They are hosted in the main Kotest repo, and are released on the same cadence as the Kotest framework. Module Description Type kotest-assertions-core Provides matchers for standard libary types. Multiplatform kotest-assertions-json Provides matchers for testing json objects. JVM kotest-assertions-kotlinx-time Provides matchers for Kotlin's date / time library. Multiplatform kotest-assertions-sql Provides matchers for JDBC. JVM kotest-assertions-ktor Provides matchers for Ktor server test and client libraries. Multiplatform Kotest External Matcher Modules These modules are hosted in the kotest organization but in separate repositories from the main kotest project. They are released on an independent cadence from the Kotest framework. They provide matchers for third party libraries. Module Description Type kotest-assertions-arrow Provides matchers for the Arrow functional programming library. JVM kotest-assertions-compiler Provides matchers that test for compilable code. JVM kotest-assertions-klock Providers matchers for Klock. Multiplatform kotest-assertions-konform Provides matchers for Konform. Multiplatform kotest-assertions-jsoup Provides matchers JSoup. JVM Community Provided Matchers This is a list of projects that provide Kotest matchers. They are maintained outside of the Kotest organization. Library Description Http4k Functional toolkit for Kotlin HTTP applications Micronaut JVM-based, full-stack framework for building modular, easily testable microservice","title":"Matchers"},{"location":"matchers/#matchers","text":"A Matcher is the Kotest term for an assertion that performs a specific test. For example, a matcher may test that a double is greater than zero. Or it it may test that a file is not empty. Kotest currently has approximately 325 matchers split across several modules. Most of these matchers are for standard library types. Others are project specific. Additionally, there are matchers provided by third party libraries. Kotest matchers are framework agnostic . You can use them with the Kotest framework, or with any other framework. If you are happy with JUnit, you can still use the powerful matchers provided by the kotest assertion modules. Matchers can be used in two styles: Extension functions like a.shouldBe(b) or a.shouldStartWith(\"foo\") Infix functions like a shouldBe b or a should startWith(\"foo\") Both styles are supported. The advantage of the extension function style is that the IDE can autocomplete for you, but some people may prefer the infix style as it is slightly cleaner. Matchers can be negated by using shouldNot instead of should for the infix style. For example, a shouldNot startWith(\"boo\") . For the extension function style, each function has an equivalent negated version, for example, a.shouldNotStartWith(\"boo\") .","title":"Matchers"},{"location":"matchers/#kotest-matcher-modules","text":"These modules provide the core matcher experience. They are hosted in the main Kotest repo, and are released on the same cadence as the Kotest framework. Module Description Type kotest-assertions-core Provides matchers for standard libary types. Multiplatform kotest-assertions-json Provides matchers for testing json objects. JVM kotest-assertions-kotlinx-time Provides matchers for Kotlin's date / time library. Multiplatform kotest-assertions-sql Provides matchers for JDBC. JVM kotest-assertions-ktor Provides matchers for Ktor server test and client libraries. Multiplatform","title":"Kotest Matcher Modules"},{"location":"matchers/#kotest-external-matcher-modules","text":"These modules are hosted in the kotest organization but in separate repositories from the main kotest project. They are released on an independent cadence from the Kotest framework. They provide matchers for third party libraries. Module Description Type kotest-assertions-arrow Provides matchers for the Arrow functional programming library. JVM kotest-assertions-compiler Provides matchers that test for compilable code. JVM kotest-assertions-klock Providers matchers for Klock. Multiplatform kotest-assertions-konform Provides matchers for Konform. Multiplatform kotest-assertions-jsoup Provides matchers JSoup. JVM","title":"Kotest External Matcher Modules"},{"location":"matchers/#community-provided-matchers","text":"This is a list of projects that provide Kotest matchers. They are maintained outside of the Kotest organization. Library Description Http4k Functional toolkit for Kotlin HTTP applications Micronaut JVM-based, full-stack framework for building modular, easily testable microservice","title":"Community Provided Matchers"},{"location":"mocks/","text":"Mocking and Kotest Kotest itself has no mock features. However, you can plug-in your favourite mocking library with ease! Let's take for example mockk : class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } }) This example works as expected, but what if we add more tests that use that mockk ? class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } test(\"Saves to repository as well\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } }) The above snippet will cause an exception! 2 matching calls found, but needs at least 1 and at most 1 calls This will happen because the mocks are not restarted between invocations. By default, Kotest isolates tests by creating a single instance of the spec for all the tests to run. This leads to mocks being reused. But how can we fix this? Option 1 - setup mocks before tests class MyTest : FunSpec({ lateinit var repository: MyRepository lateinit var target: MyService beforeTest { repository = mockk() target = MyService(repository) } test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } }) Option 2 - reset mocks after tests class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) afterTest { clearMocks(repository) } test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } }) Positioning the listeners As for any function that is executed inside the Spec definition, you can place listeners at the end class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } afterTest { clearMocks(repository) // <---- End of file, better readability } }) Option 3 - Tweak the IsolationMode Depending on the usage, playing with the IsolationMode for a given Spec might be a good option as well. Head over to isolation mode documentation if you want to understand it better. class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } isolation = IsolationMode.InstancePerTest })","title":"Mocks"},{"location":"mocks/#mocking-and-kotest","text":"Kotest itself has no mock features. However, you can plug-in your favourite mocking library with ease! Let's take for example mockk : class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } }) This example works as expected, but what if we add more tests that use that mockk ? class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } test(\"Saves to repository as well\") { every { repository.save(any()) } just Runs target.save(MyDataClass(\"a\")) verify(exactly = 1) { repository.save(MyDataClass(\"a\")) } } }) The above snippet will cause an exception! 2 matching calls found, but needs at least 1 and at most 1 calls This will happen because the mocks are not restarted between invocations. By default, Kotest isolates tests by creating a single instance of the spec for all the tests to run. This leads to mocks being reused. But how can we fix this?","title":"Mocking and Kotest"},{"location":"mocks/#option-1-setup-mocks-before-tests","text":"class MyTest : FunSpec({ lateinit var repository: MyRepository lateinit var target: MyService beforeTest { repository = mockk() target = MyService(repository) } test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } })","title":"Option 1 - setup mocks before tests"},{"location":"mocks/#option-2-reset-mocks-after-tests","text":"class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) afterTest { clearMocks(repository) } test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } })","title":"Option 2 - reset mocks after tests"},{"location":"mocks/#positioning-the-listeners","text":"As for any function that is executed inside the Spec definition, you can place listeners at the end class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } afterTest { clearMocks(repository) // <---- End of file, better readability } })","title":"Positioning the listeners"},{"location":"mocks/#option-3-tweak-the-isolationmode","text":"Depending on the usage, playing with the IsolationMode for a given Spec might be a good option as well. Head over to isolation mode documentation if you want to understand it better. class MyTest : FunSpec({ val repository = mockk<MyRepository>() val target = MyService(repository) test(\"Saves to repository\") { // ... } test(\"Saves to repository as well\") { // ... } isolation = IsolationMode.InstancePerTest })","title":"Option 3 - Tweak the IsolationMode"},{"location":"mpp/","text":"Multiplatform Support Kotest is multiplatform in some aspects. The test framework can execute tests for both JVM and Javascript projects. Core assertions are available on all platforms except for linuxArm64. JVM To use Kotest with Kotlin JVM projects, we need to use the kotest-runner-junit5 module. Add this to the jvmTest configuration in gradle. Assertions and property testing is available for the JVM. JS To use Kotest with Kotlin Javascript projects, we need to use the kotest-framework-engine module. Add this to the jsTest configuration in gradle. Assertions and property testing is available for Javascript. Native Kotest assertions are available for native platforms but not the test framework.","title":"Mpp"},{"location":"mpp/#multiplatform-support","text":"Kotest is multiplatform in some aspects. The test framework can execute tests for both JVM and Javascript projects. Core assertions are available on all platforms except for linuxArm64.","title":"Multiplatform Support"},{"location":"mpp/#jvm","text":"To use Kotest with Kotlin JVM projects, we need to use the kotest-runner-junit5 module. Add this to the jvmTest configuration in gradle. Assertions and property testing is available for the JVM.","title":"JVM"},{"location":"mpp/#js","text":"To use Kotest with Kotlin Javascript projects, we need to use the kotest-framework-engine module. Add this to the jsTest configuration in gradle. Assertions and property testing is available for Javascript.","title":"JS"},{"location":"mpp/#native","text":"Kotest assertions are available for native platforms but not the test framework.","title":"Native"},{"location":"nondeterministic_testing/","text":"Non-deterministic Tests Sometimes you have to work with code that is non-deterministic in nature. This is never the preferred scenario, but if you have no choice then Kotest has you covered with several functions that cater to tests which may take some time to pass. Eventually When testing non-deterministic code, a common use case is \"I expect this code to pass after a short period of time\". For example, if you were testing a IO operation, you might need to wait until the IO operation has flushed. Sometimes you can do a Thread.sleep but this is isn't ideal as you need to set a sleep threshold high enough so that it won't expire prematurely on a slow machine. Plus it means that your test will sit around waiting on the timeout even if the code completes quickly on a fast machine. Or you can roll a loop and sleep and retry and sleep and retry, but this is just boilerplate slowing you down. Another common approach is to use countdown latches and this works fine if you are able to inject the latches in the appropriate places but it isn't always possible to have the code under test trigger a latch. As an alternative, Kotest provides the eventually function which will periodically test the code until it either passes, or the timeout is reached. This is perfect for nondeterministic code. Examples Simple example Let's assume that we send a message to an asynchronous service. After the message is processed, a new row is inserted into user table. We can check this behaviour with our eventually function. class MyTests : ShouldSpec() { init { should(\"check if user repository has one row after message is sent\") { sendMessage() eventually(5.seconds) { userRepository.size() shouldBe 1 } } } } Exceptions By default, eventually will ignore any exception that is thrown inside the function (note, that means it won't catch Error ). If you want to be more specific, you can tell eventually to ignore specific exceptions and any others will immediately fail the test. Let's assume that our example from before throws a UserNotFoundException while the user is not found in the database. It will eventually return the user when the message is processed by the system. In this scenario, we can explicitly skip the exception that we expect to happen until the test passed, but any other exceptions would not be ignored. Note, this example is similar to the former, but if there was some other error, say a ConnectionException for example, this would cause the eventually block to immediately exit with a failure message. class MyTests : ShouldSpec() { init { should(\"check if user repository has one row\") { eventually(5.seconds, UserNotFoundException::class.java) { userRepository.findBy(1) shouldNotBe null } } } } Continually As the dual of eventually, continually allows you to assert that a block of code suceeds, and continues to succeed, for a period of time. For example you may want to check that a http connection is kept alive for 60 seconds after the last packet has been received. You could sleep for 60 seconds, and then check, but if the connection was terminated after 5 seconds, your test will sit idle for a further 55 seconds before then failing. Better to fail fast. class MyTests : ShouldSpec() { init { should(\"pass for 60 seconds\") { continually(60.seconds) { // code here that should succeed and continue to succeed for 60 seconds } } } } The function passed to the continually block is executed every 10 milliseconds. We can specify the poll interval if we prefer: class MyTests: ShouldSpec() { init { should(\"pass for 60 seconds\") { continually(60.seconds, 5.seconds) { // code here that should succeed and continue to succeed for 60 seconds } } } } Retry Retry is similar to eventually, but rather than attempt a block of code for a period of time, it attempts a block of code a maximum number of times. We still provide a timeout period to avoid the loop running for ever. class MyTests: ShouldSpec() { init { should(\"retry up to 4 times\") { retry(4, 10.minutes) { } } } } Additional options include the delay between runs, a multiplier to use exponential delays, and an exception class if we only want to repeat for certain exceptions and fail for others.","title":"Nondeterministic testing"},{"location":"nondeterministic_testing/#non-deterministic-tests","text":"Sometimes you have to work with code that is non-deterministic in nature. This is never the preferred scenario, but if you have no choice then Kotest has you covered with several functions that cater to tests which may take some time to pass.","title":"Non-deterministic Tests"},{"location":"nondeterministic_testing/#eventually","text":"When testing non-deterministic code, a common use case is \"I expect this code to pass after a short period of time\". For example, if you were testing a IO operation, you might need to wait until the IO operation has flushed. Sometimes you can do a Thread.sleep but this is isn't ideal as you need to set a sleep threshold high enough so that it won't expire prematurely on a slow machine. Plus it means that your test will sit around waiting on the timeout even if the code completes quickly on a fast machine. Or you can roll a loop and sleep and retry and sleep and retry, but this is just boilerplate slowing you down. Another common approach is to use countdown latches and this works fine if you are able to inject the latches in the appropriate places but it isn't always possible to have the code under test trigger a latch. As an alternative, Kotest provides the eventually function which will periodically test the code until it either passes, or the timeout is reached. This is perfect for nondeterministic code.","title":"Eventually "},{"location":"nondeterministic_testing/#examples","text":"","title":"Examples"},{"location":"nondeterministic_testing/#simple-example","text":"Let's assume that we send a message to an asynchronous service. After the message is processed, a new row is inserted into user table. We can check this behaviour with our eventually function. class MyTests : ShouldSpec() { init { should(\"check if user repository has one row after message is sent\") { sendMessage() eventually(5.seconds) { userRepository.size() shouldBe 1 } } } }","title":"Simple example"},{"location":"nondeterministic_testing/#exceptions","text":"By default, eventually will ignore any exception that is thrown inside the function (note, that means it won't catch Error ). If you want to be more specific, you can tell eventually to ignore specific exceptions and any others will immediately fail the test. Let's assume that our example from before throws a UserNotFoundException while the user is not found in the database. It will eventually return the user when the message is processed by the system. In this scenario, we can explicitly skip the exception that we expect to happen until the test passed, but any other exceptions would not be ignored. Note, this example is similar to the former, but if there was some other error, say a ConnectionException for example, this would cause the eventually block to immediately exit with a failure message. class MyTests : ShouldSpec() { init { should(\"check if user repository has one row\") { eventually(5.seconds, UserNotFoundException::class.java) { userRepository.findBy(1) shouldNotBe null } } } }","title":"Exceptions"},{"location":"nondeterministic_testing/#continually","text":"As the dual of eventually, continually allows you to assert that a block of code suceeds, and continues to succeed, for a period of time. For example you may want to check that a http connection is kept alive for 60 seconds after the last packet has been received. You could sleep for 60 seconds, and then check, but if the connection was terminated after 5 seconds, your test will sit idle for a further 55 seconds before then failing. Better to fail fast. class MyTests : ShouldSpec() { init { should(\"pass for 60 seconds\") { continually(60.seconds) { // code here that should succeed and continue to succeed for 60 seconds } } } } The function passed to the continually block is executed every 10 milliseconds. We can specify the poll interval if we prefer: class MyTests: ShouldSpec() { init { should(\"pass for 60 seconds\") { continually(60.seconds, 5.seconds) { // code here that should succeed and continue to succeed for 60 seconds } } } }","title":"Continually "},{"location":"nondeterministic_testing/#retry","text":"Retry is similar to eventually, but rather than attempt a block of code for a period of time, it attempts a block of code a maximum number of times. We still provide a timeout period to avoid the loop running for ever. class MyTests: ShouldSpec() { init { should(\"retry up to 4 times\") { retry(4, 10.minutes) { } } } } Additional options include the delay between runs, a multiplier to use exponential delays, and an exception class if we only want to repeat for certain exceptions and fail for others.","title":"Retry "},{"location":"plugins/","text":"Plugins Sometimes there's a need for special integration with some tools that are more complex than using Listeners or Extensions . In this situation plugins are necessary. Pitest The Mutation Testing tool Pitest is integrated via a kotest plugin. After configuring the Pitest extension, add the kotest-plugins-pitest module to your dependencies as well: testImplementation(\"io.kotest:kotest-plugins-pitest:<version>\") After doing that, tell Pitest that we're going to use Kotest as a testPlugin : // Assuming that you have already configured the Gradle/Maven extension configure<PitestPluginExtension> { testPlugin.set(\"Kotest\") // <-- Telling Pitest that we're using Kotest targetClasses.set(listOf(\"my.company.package.*\")) } This should set everything up, and running ./gradlew pitest will generate reports in the way you configured.","title":"Plugins"},{"location":"plugins/#plugins","text":"Sometimes there's a need for special integration with some tools that are more complex than using Listeners or Extensions . In this situation plugins are necessary.","title":"Plugins"},{"location":"plugins/#pitest","text":"The Mutation Testing tool Pitest is integrated via a kotest plugin. After configuring the Pitest extension, add the kotest-plugins-pitest module to your dependencies as well: testImplementation(\"io.kotest:kotest-plugins-pitest:<version>\") After doing that, tell Pitest that we're going to use Kotest as a testPlugin : // Assuming that you have already configured the Gradle/Maven extension configure<PitestPluginExtension> { testPlugin.set(\"Kotest\") // <-- Telling Pitest that we're using Kotest targetClasses.set(listOf(\"my.company.package.*\")) } This should set everything up, and running ./gradlew pitest will generate reports in the way you configured.","title":"Pitest"},{"location":"project_config/","text":"Project Level Config Kotest is flexible and has many ways to configure tests, such as configuring the order of tests inside a spec, or how test classes are created. Sometimes you may want to set this at a global level and for that you need to use project-level-config. Project level configuration can be used by creating an object or class that extends from AbstractProjectConfig . At runtime, Kotest will scan for classes that extend this abstract class and instantiate them, reading any configuration defined there. You can create more than one config class in different modules, and any on the current classpath will be detected and configs merged. This is effective for allowing common config to be placed into a root module. In the case of clashes, one value will be arbitrarily picked, so it is not recommended to add competing settings to different configs. Any configuration set at the Spec level or directly on a test will override the config specified at the project level. Some of the configuration options available in ProjectConfig include parallelism of tests, failing specs with ignored tests, global AssertSoftly , and reusable listeners or extensions. Parallelism You can ask Kotest to run specs in parallel to take advantage of modern cpus with several cores by setting the parallelism level (default is 1).. Tests inside a spec are always executed sequentially. To do this, override parallelism inside your config and set it to a value higher than 1. The number set is the number of concurrently executing specs. For example. object ProjectConfig : AbstractProjectConfig() { override val parallelism = 3 } An alternative way to enable this is the system property kotest.parallelism which will always (if defined) take priority over the value here. Some tests may not play nice in parallel, so you can opt out individual specs and force them to be executed in isolation by using the @DoNotParallelize annotation on the spec. Note This is only available on the JVM target. Assertion Mode You can ask Kotest to fail the build, or warn in std err, if a test is executed that does not use a Kotest assertion. To do this, set assertionMode to AssertionMode.Error or AssertionMode.Warn inside your config. For example. object ProjectConfig : AbstractProjectConfig { override val assertionMode = AssertionMode.Error } Warning Assertion mode only works for Kotest assertions and not other assertion libraries. Global Assert Softly Assert softly is very useful to batch up errors into a single failure. If we want to enable this for every test automatically, we can do this in config. object ProjectConfig : AbstractProjectConfig { override val globalAssertSoftly = true } Fail On Ignored Tests You may wish to consider an ignored test as a failure. To enable this feature, set failOnIgnoredTests to true inside your project config. For example. object ProjectConfig : AbstractProjectConfig { override val failOnIgnoredTests = true } Test Ordering When running multiple tests from a Spec, there's a certain order on how to execute them. By default, a sequential order is used (the order that tests are defined in the spec), but this can be changed. For available options see test ordering . Spec Ordering By default, the ordering of Spec classes is not defined. This is often sufficient, when we have no preference, but if we need control over the execution order of specs, we can use spec ordering . Test name case The case of the test names can be controlled by changing the value of testNameCase . By default, the value is TestNameCase.AsIs which makes no change. By setting the value to TestNameCase.Lowercase a test's name will be lowercased in output. If you are using a spec that adds in prefixes to the test names (should as WordSpec or BehaviorSpec) then the values TestNameCase.Sentence and TestNameCase.InitialLowercase can be useful. Test name whitespace If you define test names over several lines then removeTestNameWhitespace can be useful. Take this example: \"\"\"this is my test case\"\"\" { // test here } Then the test name in output will be this is my test case . By setting removeTestNameWhitespace to true, then this name will be trimmed to this is my test case .","title":"Project config"},{"location":"project_config/#project-level-config","text":"Kotest is flexible and has many ways to configure tests, such as configuring the order of tests inside a spec, or how test classes are created. Sometimes you may want to set this at a global level and for that you need to use project-level-config. Project level configuration can be used by creating an object or class that extends from AbstractProjectConfig . At runtime, Kotest will scan for classes that extend this abstract class and instantiate them, reading any configuration defined there. You can create more than one config class in different modules, and any on the current classpath will be detected and configs merged. This is effective for allowing common config to be placed into a root module. In the case of clashes, one value will be arbitrarily picked, so it is not recommended to add competing settings to different configs. Any configuration set at the Spec level or directly on a test will override the config specified at the project level. Some of the configuration options available in ProjectConfig include parallelism of tests, failing specs with ignored tests, global AssertSoftly , and reusable listeners or extensions.","title":"Project Level Config"},{"location":"project_config/#parallelism","text":"You can ask Kotest to run specs in parallel to take advantage of modern cpus with several cores by setting the parallelism level (default is 1).. Tests inside a spec are always executed sequentially. To do this, override parallelism inside your config and set it to a value higher than 1. The number set is the number of concurrently executing specs. For example. object ProjectConfig : AbstractProjectConfig() { override val parallelism = 3 } An alternative way to enable this is the system property kotest.parallelism which will always (if defined) take priority over the value here. Some tests may not play nice in parallel, so you can opt out individual specs and force them to be executed in isolation by using the @DoNotParallelize annotation on the spec. Note This is only available on the JVM target.","title":"Parallelism"},{"location":"project_config/#assertion-mode","text":"You can ask Kotest to fail the build, or warn in std err, if a test is executed that does not use a Kotest assertion. To do this, set assertionMode to AssertionMode.Error or AssertionMode.Warn inside your config. For example. object ProjectConfig : AbstractProjectConfig { override val assertionMode = AssertionMode.Error } Warning Assertion mode only works for Kotest assertions and not other assertion libraries.","title":"Assertion Mode"},{"location":"project_config/#global-assert-softly","text":"Assert softly is very useful to batch up errors into a single failure. If we want to enable this for every test automatically, we can do this in config. object ProjectConfig : AbstractProjectConfig { override val globalAssertSoftly = true }","title":"Global Assert Softly"},{"location":"project_config/#fail-on-ignored-tests","text":"You may wish to consider an ignored test as a failure. To enable this feature, set failOnIgnoredTests to true inside your project config. For example. object ProjectConfig : AbstractProjectConfig { override val failOnIgnoredTests = true }","title":"Fail On Ignored Tests"},{"location":"project_config/#test-ordering","text":"When running multiple tests from a Spec, there's a certain order on how to execute them. By default, a sequential order is used (the order that tests are defined in the spec), but this can be changed. For available options see test ordering .","title":"Test Ordering"},{"location":"project_config/#spec-ordering","text":"By default, the ordering of Spec classes is not defined. This is often sufficient, when we have no preference, but if we need control over the execution order of specs, we can use spec ordering .","title":"Spec Ordering"},{"location":"project_config/#test-name-case","text":"The case of the test names can be controlled by changing the value of testNameCase . By default, the value is TestNameCase.AsIs which makes no change. By setting the value to TestNameCase.Lowercase a test's name will be lowercased in output. If you are using a spec that adds in prefixes to the test names (should as WordSpec or BehaviorSpec) then the values TestNameCase.Sentence and TestNameCase.InitialLowercase can be useful.","title":"Test name case"},{"location":"project_config/#test-name-whitespace","text":"If you define test names over several lines then removeTestNameWhitespace can be useful. Take this example: \"\"\"this is my test case\"\"\" { // test here } Then the test name in output will be this is my test case . By setting removeTestNameWhitespace to true, then this name will be trimmed to this is my test case .","title":"Test name whitespace"},{"location":"property_generators/","text":"Property Test Generators This page lists all current generators in Kotest. There are two types of generator - arbitrary and exhaustive. An arbitrary will generate random values subject to its bounds (possibly with duplicates as is the nature of random selection). An exhaustive will provide all the values over its sample space before looping if more values are required. Most generators are available on all platforms. Some are JVM specific. Numeric Description JVM JS Native Arb.int(range) Randomly chosen ints in the given range. If the range is not specified then all integers are considered. The edgecases are Int.MIN_VALUE , Int.MAX_VALUE , 0, 1, -1 \u2713 \u2713 \u2713 Arb.long(range) Randomly chosen longs in the given range. If the range is not specified then all longs are considered. The edgecases are Long.MIN_VALUE , Long.MAX_VALUE , 0, 1, -1 \u2713 \u2713 \u2713 Arb.nats(range) Randomly chosen natural numbers in the given range. If range is not specified then the default is Int.MAX_VALUE . The edgecases are Int.MAX_VALUE , 1 \u2713 \u2713 \u2713 Arb.negativeInts(range) Randomly chosen negative integers in the given range. The edgecases are Int.MIN_VALUE , -1 \u2713 \u2713 \u2713 Arb.positiveInts(range) Randomly chosen positive integers in the given range. The edgecases are Int.MAX_VALUE , 1 \u2713 \u2713 \u2713 Arb.double(range) Randomly chosen doubles in the given range. The edgecases are Double.MIN_VALUE , Double.MAX_VALUE , Double.NEGATIVE_INFINITY , Double.NaN , Double.POSITIVE_INFINITY , 0.0, 1.0, -1.0, 1e300 \u2713 \u2713 \u2713 Arb.positiveDoubles(range) Randomly chosen positive doubles in the given range. The edgecases are Double.MIN_VALUE , Double.MAX_VALUE , Double.POSITIVE_INFINITY , 1.0, 1e300 \u2713 \u2713 \u2713 Arb.negativeDoubles(range) Randomly chosen negative doubles in the given range. The edgecases are Double.NEGATIVE_INFINITY , -1.0 \u2713 \u2713 \u2713 Exhaustive.int(range) Returns all ints in the given range. \u2713 \u2713 \u2713 Exhaustive.long(range) Returns all longs in the given range. \u2713 \u2713 \u2713 Arb.multiples(k, max) Generates multiples of k up a max value. The edgecases are 0 . \u2713 \u2713 \u2713 Booleans Description JVM JS Native Exhaustive.boolean() Returns true and false. \u2713 \u2713 \u2713 Enums Description JVM JS Native Arb.enum<T>() Randomly selects constants from the given enum. \u2713 \u2713 \u2713 Exhaustive.enum<T>() Returns all the constants defined in the given enum. \u2713 \u2713 \u2713 String Description JVM JS Native Arb.string(range) Generates random printable strings with a randomly chosen size from the given range. If rangei s not specified then (0..100) is used. The edgecases include empty string, a blank string and a unicode string. \u2713 \u2713 \u2713 Exhaustive.azstring(range) Returns all A-Z strings in the given range. For example if range was 1..2 then a, b, c, ...., yz, zz would be included. \u2713 \u2713 \u2713 Arb.email(userRange, domainRange) Generates random emails where the username and domain are random strings with the size determined by the range parameters. \u2713 \u2713 \u2713 Arb.uuid(type) Generates random UUIDs of the given type \u2713 Builders Description JVM JS Native Arb.create(fn) Generates values using the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, fn) Generates values by pulling a value from each of the two given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, fn) Generates values by pulling a value from each of the three given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, fn) Generates values by pulling a value from each of the four given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, arbE, fn) Generates values by pulling a value from each of the five given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, arbE, arbF, fn) Generates values by pulling a value from each of the six given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Combinatorics Description JVM JS Native Arb.choose(pairs) Generates values based on weights. For example, Arb.choose(1 to 'A', 2 to 'B') will generate 'A' 33% of the time and 'B' 66% of the time. \u2713 \u2713 \u2713 Arb.shuffle(list) Generates random permutations of a list. For example, Arb.shuffle(listOf(1,2,3)) could generate listOf(3,1,2) , listOf(1,3,2) and so on. \u2713 \u2713 \u2713 Arb.choice(arbs) Randomly selects one of the given arbs and then uses that to generate the next element. \u2713 \u2713 \u2713 Arb.subsequence(list) Generates a random subsequence of the given list starting at index 0 and including the empty list. For example, Arb.subsequence(listOf(1,2,3)) could generate listOf(1) , listOf(1,2) , and so on. \u2713 \u2713 \u2713 arb.orNull() Generates random values from the arb instance, with null values mixed in. For example, Arb.int().orNull() could generate 1, -1, null, 8, 17 , and so on. Has overloaded versions to control the frequency of nulls being generated. \u2713 \u2713 \u2713 Collections Description JVM JS Native Arb.list(gen, range) Generates lists where values are generated by the given element generator. The size of each list is determined randomly by the specified range. \u2713 \u2713 \u2713 Arb.set(gen, range) Generates sets where values are generated by the given element generator. The size of each set is determined randomly by the specified range. \u2713 \u2713 \u2713 Arb.element(list) Randomly selects one of the elements of the given list. \u2713 \u2713 \u2713 Exhaustive.collection(list) Enumerates each element of the list one by one. \u2713 \u2713 \u2713 Dates Description JVM JS Native Arb.date(ranges) Generates random dates with the year between the given range \u2713 Arb.datetime(ranges) Generates random date times with the year between the given range \u2713 Arb.localDateTime(ranges) Generates random LocalDateTime's with the year between the given range \u2713 Arb.localDate(ranges) Generates random LocalDate's with the year between the given range \u2713","title":"List of Generators"},{"location":"property_generators/#property-test-generators","text":"This page lists all current generators in Kotest. There are two types of generator - arbitrary and exhaustive. An arbitrary will generate random values subject to its bounds (possibly with duplicates as is the nature of random selection). An exhaustive will provide all the values over its sample space before looping if more values are required. Most generators are available on all platforms. Some are JVM specific. Numeric Description JVM JS Native Arb.int(range) Randomly chosen ints in the given range. If the range is not specified then all integers are considered. The edgecases are Int.MIN_VALUE , Int.MAX_VALUE , 0, 1, -1 \u2713 \u2713 \u2713 Arb.long(range) Randomly chosen longs in the given range. If the range is not specified then all longs are considered. The edgecases are Long.MIN_VALUE , Long.MAX_VALUE , 0, 1, -1 \u2713 \u2713 \u2713 Arb.nats(range) Randomly chosen natural numbers in the given range. If range is not specified then the default is Int.MAX_VALUE . The edgecases are Int.MAX_VALUE , 1 \u2713 \u2713 \u2713 Arb.negativeInts(range) Randomly chosen negative integers in the given range. The edgecases are Int.MIN_VALUE , -1 \u2713 \u2713 \u2713 Arb.positiveInts(range) Randomly chosen positive integers in the given range. The edgecases are Int.MAX_VALUE , 1 \u2713 \u2713 \u2713 Arb.double(range) Randomly chosen doubles in the given range. The edgecases are Double.MIN_VALUE , Double.MAX_VALUE , Double.NEGATIVE_INFINITY , Double.NaN , Double.POSITIVE_INFINITY , 0.0, 1.0, -1.0, 1e300 \u2713 \u2713 \u2713 Arb.positiveDoubles(range) Randomly chosen positive doubles in the given range. The edgecases are Double.MIN_VALUE , Double.MAX_VALUE , Double.POSITIVE_INFINITY , 1.0, 1e300 \u2713 \u2713 \u2713 Arb.negativeDoubles(range) Randomly chosen negative doubles in the given range. The edgecases are Double.NEGATIVE_INFINITY , -1.0 \u2713 \u2713 \u2713 Exhaustive.int(range) Returns all ints in the given range. \u2713 \u2713 \u2713 Exhaustive.long(range) Returns all longs in the given range. \u2713 \u2713 \u2713 Arb.multiples(k, max) Generates multiples of k up a max value. The edgecases are 0 . \u2713 \u2713 \u2713 Booleans Description JVM JS Native Exhaustive.boolean() Returns true and false. \u2713 \u2713 \u2713 Enums Description JVM JS Native Arb.enum<T>() Randomly selects constants from the given enum. \u2713 \u2713 \u2713 Exhaustive.enum<T>() Returns all the constants defined in the given enum. \u2713 \u2713 \u2713 String Description JVM JS Native Arb.string(range) Generates random printable strings with a randomly chosen size from the given range. If rangei s not specified then (0..100) is used. The edgecases include empty string, a blank string and a unicode string. \u2713 \u2713 \u2713 Exhaustive.azstring(range) Returns all A-Z strings in the given range. For example if range was 1..2 then a, b, c, ...., yz, zz would be included. \u2713 \u2713 \u2713 Arb.email(userRange, domainRange) Generates random emails where the username and domain are random strings with the size determined by the range parameters. \u2713 \u2713 \u2713 Arb.uuid(type) Generates random UUIDs of the given type \u2713 Builders Description JVM JS Native Arb.create(fn) Generates values using the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, fn) Generates values by pulling a value from each of the two given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, fn) Generates values by pulling a value from each of the three given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, fn) Generates values by pulling a value from each of the four given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, arbE, fn) Generates values by pulling a value from each of the five given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Arb.bind(arbA, arbB, arbC, arbD, arbE, arbF, fn) Generates values by pulling a value from each of the six given arbs and then passing those values to the supplied function. \u2713 \u2713 \u2713 Combinatorics Description JVM JS Native Arb.choose(pairs) Generates values based on weights. For example, Arb.choose(1 to 'A', 2 to 'B') will generate 'A' 33% of the time and 'B' 66% of the time. \u2713 \u2713 \u2713 Arb.shuffle(list) Generates random permutations of a list. For example, Arb.shuffle(listOf(1,2,3)) could generate listOf(3,1,2) , listOf(1,3,2) and so on. \u2713 \u2713 \u2713 Arb.choice(arbs) Randomly selects one of the given arbs and then uses that to generate the next element. \u2713 \u2713 \u2713 Arb.subsequence(list) Generates a random subsequence of the given list starting at index 0 and including the empty list. For example, Arb.subsequence(listOf(1,2,3)) could generate listOf(1) , listOf(1,2) , and so on. \u2713 \u2713 \u2713 arb.orNull() Generates random values from the arb instance, with null values mixed in. For example, Arb.int().orNull() could generate 1, -1, null, 8, 17 , and so on. Has overloaded versions to control the frequency of nulls being generated. \u2713 \u2713 \u2713 Collections Description JVM JS Native Arb.list(gen, range) Generates lists where values are generated by the given element generator. The size of each list is determined randomly by the specified range. \u2713 \u2713 \u2713 Arb.set(gen, range) Generates sets where values are generated by the given element generator. The size of each set is determined randomly by the specified range. \u2713 \u2713 \u2713 Arb.element(list) Randomly selects one of the elements of the given list. \u2713 \u2713 \u2713 Exhaustive.collection(list) Enumerates each element of the list one by one. \u2713 \u2713 \u2713 Dates Description JVM JS Native Arb.date(ranges) Generates random dates with the year between the given range \u2713 Arb.datetime(ranges) Generates random date times with the year between the given range \u2713 Arb.localDateTime(ranges) Generates random LocalDateTime's with the year between the given range \u2713 Arb.localDate(ranges) Generates random LocalDate's with the year between the given range \u2713","title":"Property Test Generators"},{"location":"property_ops/","text":"Generator Operations Next If you want to use an Arb to just return a value (even outside of a property test), then you can call next on it. val arbA: Arb<A> = ... val a = arbA.next() // use Random.Default val a2 = arbA.next(rs) // pass in Random Filter If you have an arb and you want to create a new arb that provides a subset of values, you can call filter on the source arb. For example, one way of generating even numbers is to take the integer arb, and filter out odd values. Viz: val evens = Arb.int().filter { it.value % 2 == 0 } val odds = Arb.int().filter { it.value % 2 == 1 } Map If you have an arb and you want to transform the value generated, you can use map. val integerStrings: Arb<String> = Arb.int().map { it.toString() } FlatMap If you have an arb whose emission or edgecases depends on the emission of the previous arbitraries, you can use flatMap. val dependentArbs: Arb<String> = Arb.of(\"foo\", \"bar\").flatMap { prefix -> Arb.int(1..10).map { integer -> \"${prefix}-${integer}\" } } Merging Two generators can be merged together, so that elements 0, 2, 4, ... are taken from the first generator, and elements 1, 3, 5, ... are taken from the second generator. val merged = arbA.merge(arbB) Bind Bind is useful if you want to apply multiple arbitraries. We can take a look at how we might construct the Person data class in the previous example using Bind. data class Person(val name: String, val age: Int) val personArb: Arb<Person> = Arb.bind( Arb.string(), Arb.int() ) { name, age -> Person(name, age) }","title":"Generator Operations"},{"location":"property_ops/#generator-operations","text":"","title":"Generator Operations"},{"location":"property_ops/#next","text":"If you want to use an Arb to just return a value (even outside of a property test), then you can call next on it. val arbA: Arb<A> = ... val a = arbA.next() // use Random.Default val a2 = arbA.next(rs) // pass in Random","title":"Next"},{"location":"property_ops/#filter","text":"If you have an arb and you want to create a new arb that provides a subset of values, you can call filter on the source arb. For example, one way of generating even numbers is to take the integer arb, and filter out odd values. Viz: val evens = Arb.int().filter { it.value % 2 == 0 } val odds = Arb.int().filter { it.value % 2 == 1 }","title":"Filter"},{"location":"property_ops/#map","text":"If you have an arb and you want to transform the value generated, you can use map. val integerStrings: Arb<String> = Arb.int().map { it.toString() }","title":"Map"},{"location":"property_ops/#flatmap","text":"If you have an arb whose emission or edgecases depends on the emission of the previous arbitraries, you can use flatMap. val dependentArbs: Arb<String> = Arb.of(\"foo\", \"bar\").flatMap { prefix -> Arb.int(1..10).map { integer -> \"${prefix}-${integer}\" } }","title":"FlatMap"},{"location":"property_ops/#merging","text":"Two generators can be merged together, so that elements 0, 2, 4, ... are taken from the first generator, and elements 1, 3, 5, ... are taken from the second generator. val merged = arbA.merge(arbB)","title":"Merging"},{"location":"property_ops/#bind","text":"Bind is useful if you want to apply multiple arbitraries. We can take a look at how we might construct the Person data class in the previous example using Bind. data class Person(val name: String, val age: Int) val personArb: Arb<Person> = Arb.bind( Arb.string(), Arb.int() ) { name, age -> Person(name, age) }","title":"Bind"},{"location":"property_testing/","text":"Property-based Testing Kotest is split into several subprojects which can be used independently. One of these subprojects is the property test framework. Quick Start To use Kotest's property-based testing you need to add the module io.kotest:kotest-property:<version> to your build. Info Upgrading from 3.x? The kotest-property module is only available in version 4.0+. It replaces the previous property test classes which are now deprecated. Introduction To Property Testing Developers typically write example-based tests. These are your garden variety unit tests you know and love. You provide the inputs and the expected values, and a test framework like Kotest checks that the two align, failing the build if they don't match up. One problem with this approach is that it is very easy to miss errors due to edge cases or lack of coverage in the choosen inputs. With property testing, hundreds or thousands of values are fed into the same test, and the values are randomly generated by your property test framework. A good property test framework will include things like negative infinity, empty lists, strings with non-ascii characters, and so on. Things we often forget about when writing example based tests. Property tests were originally conceived in frameworks like Quickcheck with the notion of testing a property on some object, something that should hold true for all inputs. An example is the length of string A plus the length of string B should always be equal to the length of A + B. This is where the term property testing originates. Kotest supports this through the io.kotest.property.forAll function which accepts an n-arity function (a, ..., n) -> Boolean that tests the property. For example, here is the property test that we mentioned just a few paragraphs ago. It checks that for any two Strings, the length of a + b is the same as the length of a plus the length of b . In this example Kotest would execute the test 1000 times for random String combinations. class PropertyExample: StringSpec({ \"String size\" { forAll<String, String> { a, b -> (a + b).length == a.length + b.length } } }) Notice that the function must evaluate to a boolean value. We provide the type parameters to forAll so the framework knows which type of values to generate (in this case strings). If we don't want to provide a property that returns a boolean, Kotest also provides for io.kotest.property.checkAll which accepts an n-arity function (a, ..., n) -> Unit in which you can simply execute assertions against the inputs. For example: class PropertyExample: StringSpec({ \"integers under addition should have an identity value\" { checkAll<Int, Int, Int> { a, b, c -> a + 0 shouldbe a 0 + a shouldBe a } } }) The checkAll approach will consider a test valid if no exceptions were thrown. Iterations By default, Kotest will run the property test 1000 times. We can easily customize this by specifying the iteration count when invoking the test method. Let's say we want to run a test 10,000 times. class PropertyExample: StringSpec({ \"some test\" { checkAll<Double, Double>(10000) { a, b -> // test here } } }) Configuration Kotest provides for the ability to specify some configuration options when running a property test. We do this by passing in an instance of PropTestConfig to the test methods. For example: class PropertyExample: StringSpec({ \"String size\" { forAll<String, String>(PropTestConfig(options here...)) { a,b -> (a + b).length == a.length + b.length } } }) Seed The most common configuration option is specifying the seed for the random instance. This is used when you want to reliably create the same values each time the test is run. You might want to do this if you find a test failure, and you want to ensure that that particular set of values continues to be executed in the future as a kind of regression test. Tip Whenever a property test fails, Kotest will output the seed that was used, so you can copy it into another test to \"fix\" that seed value. For example: class PropertyExample: StringSpec({ \"String size\" { forAll<String, String>(PropTestConfig(seed = 127305235)) { a,b -> (a + b).length == a.length + b.length } } }) Min Failure By default, Kotest tolerates no failure. Perhaps you want to run some non-deterministic test a bunch of times, and you're happy to accept some small number of failures. You can specify that in config. class PropertyExample: StringSpec({ \"some flakey test\" { forAll<String, String>(PropTestConfig(maxFailure = 3)) { a,b -> // max of 3 inputs can fail } } }) PropTestListener Sometimes in property test it is required to perform some setup and tear down in each iteration of test. For this purpose you can register a PropTestListener with PropTestConfig . class PropertyExample: StringSpec({ \"some property test which require setup and tear down in each iteration\" { forAll<String, String>(PropTestConfig(listeners = listOf(MyPropTestListener))) { a,b -> // some assertion } } }) Generators Generated values are provided by instances of the sealed class Gen . You can think of a Gen as kind of like an input stream but for property testing. Each Gen will provide a (usually) infinite stream of these values. Kotest has two types of generators - Arb for arbitrary (random) values and Exhaustive for a finite set of values in a closed space. Both types of gens can be mixed and matched in property tests. For example, you could test a function with 100 random positive integers (arbitrary) alongside every even number from 0 to 200 (exhaustive). Some generators are only available on the JVM. See the full list here . Arb Arbs generate random values across a given space. The values may be repeated, and some values may never be generated at all. For example generating 1000 random integers between 0 and Int.MAX will clearly not return all possible values, and some values may happen to be generated more than once. An arb will generate an infinite stream of values. Typical arbs include numbers across a wide number line, strings in the unicode set, random lists, random data classes, emails, codepoint and chars. Exhaustive Exhaustives generate all values from a given space. This is useful when you want to ensure every value in that space is used. For instance for enum values, it is usually more helpful to ensure each enum is used, rather than picking randomly from the enums values and potentially missing some and duplicating others. Typical exhaustives include small collections, enums, boolean values, powerset of a list or set, pre-defined small integer ranges, and predefined string ranges. Specifying Generators You saw earlier when using forAll or checkAll that if we specify the type parameters, Kotest will provide an appropriate gen. This is fine for basic tests but often we want more control over the sample space. To do this, we can instantiate the generators ourselves by using extension functions on Arb and/or Exhaustive and passing those into the assert/check methods. For example, we may want to test a function for numbers in a certain range only. class PropertyExample: StringSpec({ \"is allowed to drink in Chicago\" { forAll(Arb.int(21..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } \"is allowed to drink in London\" { forAll(Arb.int(18..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } }) Actually, ages are a small space, it would probably be better not to leave the values to chance. class PropertyExample: StringSpec({ \"is allowed to drink in Chicago\" { forAll(Exhaustive.int(21..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } \"is allowed to drink in London\" { forAll(Exhaustive.int(18..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } }) You can mix and match arbs and exhaustives in the same test of course, since they are both generators. class PropertyExample: StringSpec({ \"some dummy test\" { checkAll(Arb.emails(), Exhaustive.enum<Foo>) { email, foo -> // test here } } }) See here for a list of the built in generators.","title":"Introduction"},{"location":"property_testing/#property-based-testing","text":"Kotest is split into several subprojects which can be used independently. One of these subprojects is the property test framework.","title":"Property-based Testing "},{"location":"property_testing/#quick-start","text":"To use Kotest's property-based testing you need to add the module io.kotest:kotest-property:<version> to your build. Info Upgrading from 3.x? The kotest-property module is only available in version 4.0+. It replaces the previous property test classes which are now deprecated.","title":"Quick Start"},{"location":"property_testing/#introduction-to-property-testing","text":"Developers typically write example-based tests. These are your garden variety unit tests you know and love. You provide the inputs and the expected values, and a test framework like Kotest checks that the two align, failing the build if they don't match up. One problem with this approach is that it is very easy to miss errors due to edge cases or lack of coverage in the choosen inputs. With property testing, hundreds or thousands of values are fed into the same test, and the values are randomly generated by your property test framework. A good property test framework will include things like negative infinity, empty lists, strings with non-ascii characters, and so on. Things we often forget about when writing example based tests. Property tests were originally conceived in frameworks like Quickcheck with the notion of testing a property on some object, something that should hold true for all inputs. An example is the length of string A plus the length of string B should always be equal to the length of A + B. This is where the term property testing originates. Kotest supports this through the io.kotest.property.forAll function which accepts an n-arity function (a, ..., n) -> Boolean that tests the property. For example, here is the property test that we mentioned just a few paragraphs ago. It checks that for any two Strings, the length of a + b is the same as the length of a plus the length of b . In this example Kotest would execute the test 1000 times for random String combinations. class PropertyExample: StringSpec({ \"String size\" { forAll<String, String> { a, b -> (a + b).length == a.length + b.length } } }) Notice that the function must evaluate to a boolean value. We provide the type parameters to forAll so the framework knows which type of values to generate (in this case strings). If we don't want to provide a property that returns a boolean, Kotest also provides for io.kotest.property.checkAll which accepts an n-arity function (a, ..., n) -> Unit in which you can simply execute assertions against the inputs. For example: class PropertyExample: StringSpec({ \"integers under addition should have an identity value\" { checkAll<Int, Int, Int> { a, b, c -> a + 0 shouldbe a 0 + a shouldBe a } } }) The checkAll approach will consider a test valid if no exceptions were thrown.","title":"Introduction To Property Testing"},{"location":"property_testing/#iterations","text":"By default, Kotest will run the property test 1000 times. We can easily customize this by specifying the iteration count when invoking the test method. Let's say we want to run a test 10,000 times. class PropertyExample: StringSpec({ \"some test\" { checkAll<Double, Double>(10000) { a, b -> // test here } } })","title":"Iterations"},{"location":"property_testing/#configuration","text":"Kotest provides for the ability to specify some configuration options when running a property test. We do this by passing in an instance of PropTestConfig to the test methods. For example: class PropertyExample: StringSpec({ \"String size\" { forAll<String, String>(PropTestConfig(options here...)) { a,b -> (a + b).length == a.length + b.length } } })","title":"Configuration"},{"location":"property_testing/#seed","text":"The most common configuration option is specifying the seed for the random instance. This is used when you want to reliably create the same values each time the test is run. You might want to do this if you find a test failure, and you want to ensure that that particular set of values continues to be executed in the future as a kind of regression test. Tip Whenever a property test fails, Kotest will output the seed that was used, so you can copy it into another test to \"fix\" that seed value. For example: class PropertyExample: StringSpec({ \"String size\" { forAll<String, String>(PropTestConfig(seed = 127305235)) { a,b -> (a + b).length == a.length + b.length } } })","title":"Seed"},{"location":"property_testing/#min-failure","text":"By default, Kotest tolerates no failure. Perhaps you want to run some non-deterministic test a bunch of times, and you're happy to accept some small number of failures. You can specify that in config. class PropertyExample: StringSpec({ \"some flakey test\" { forAll<String, String>(PropTestConfig(maxFailure = 3)) { a,b -> // max of 3 inputs can fail } } })","title":"Min Failure"},{"location":"property_testing/#proptestlistener","text":"Sometimes in property test it is required to perform some setup and tear down in each iteration of test. For this purpose you can register a PropTestListener with PropTestConfig . class PropertyExample: StringSpec({ \"some property test which require setup and tear down in each iteration\" { forAll<String, String>(PropTestConfig(listeners = listOf(MyPropTestListener))) { a,b -> // some assertion } } })","title":"PropTestListener"},{"location":"property_testing/#generators","text":"Generated values are provided by instances of the sealed class Gen . You can think of a Gen as kind of like an input stream but for property testing. Each Gen will provide a (usually) infinite stream of these values. Kotest has two types of generators - Arb for arbitrary (random) values and Exhaustive for a finite set of values in a closed space. Both types of gens can be mixed and matched in property tests. For example, you could test a function with 100 random positive integers (arbitrary) alongside every even number from 0 to 200 (exhaustive). Some generators are only available on the JVM. See the full list here .","title":"Generators"},{"location":"property_testing/#arb","text":"Arbs generate random values across a given space. The values may be repeated, and some values may never be generated at all. For example generating 1000 random integers between 0 and Int.MAX will clearly not return all possible values, and some values may happen to be generated more than once. An arb will generate an infinite stream of values. Typical arbs include numbers across a wide number line, strings in the unicode set, random lists, random data classes, emails, codepoint and chars.","title":"Arb"},{"location":"property_testing/#exhaustive","text":"Exhaustives generate all values from a given space. This is useful when you want to ensure every value in that space is used. For instance for enum values, it is usually more helpful to ensure each enum is used, rather than picking randomly from the enums values and potentially missing some and duplicating others. Typical exhaustives include small collections, enums, boolean values, powerset of a list or set, pre-defined small integer ranges, and predefined string ranges.","title":"Exhaustive"},{"location":"property_testing/#specifying-generators","text":"You saw earlier when using forAll or checkAll that if we specify the type parameters, Kotest will provide an appropriate gen. This is fine for basic tests but often we want more control over the sample space. To do this, we can instantiate the generators ourselves by using extension functions on Arb and/or Exhaustive and passing those into the assert/check methods. For example, we may want to test a function for numbers in a certain range only. class PropertyExample: StringSpec({ \"is allowed to drink in Chicago\" { forAll(Arb.int(21..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } \"is allowed to drink in London\" { forAll(Arb.int(18..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } }) Actually, ages are a small space, it would probably be better not to leave the values to chance. class PropertyExample: StringSpec({ \"is allowed to drink in Chicago\" { forAll(Exhaustive.int(21..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } \"is allowed to drink in London\" { forAll(Exhaustive.int(18..150)) { a -> isDrinkingAge(a) // assuming some function that calculates if we're old enough to drink } } }) You can mix and match arbs and exhaustives in the same test of course, since they are both generators. class PropertyExample: StringSpec({ \"some dummy test\" { checkAll(Arb.emails(), Exhaustive.enum<Foo>) { email, foo -> // test here } } }) See here for a list of the built in generators.","title":"Specifying Generators"},{"location":"quick_start/","text":"Quick Start Kotest is split into 3 basic sub-projects. These are provided separately so you can pick and choose which parts to use if you don't want to go all in on Kotest. Test Framework Layout tests in a fluid way and execute them on the JVM or Javascript. Assertions Library A Kotlin-first multi-platform assertions library. Property Testing An advanced multi-platform property test library with shrinking support. Which subproject(s) to use? If you want to lay out tests in a fluid way ; with built in coroutine support at every level; the ability to use functions as test lifecycle callbacks ; with extensive extension points; with advanced conditional evaluation ; and execute these tests on the JVM and/or Javascript, then build your test classes using the Kotest Test Framework. If you want a Kotlin focused multi-platform enabled assertions library; with over 300 rich assertions ; with support for inspectors ; helpers for non-determistic tests ; powerful data driven testing ; modules for arrow , json and more, then opt to use the Kotest assertions library. If you want a powerful multi-platform enabled property test library, with over 50 built in generators ; the ability to easily compose new generators; with failure shrinking; with exhaustive checks; with coverage metrics; then choose the Kotest property test module. The following instructions give you the batteries included setup in gradle or maven. Omit any modules you don't wish to use. Info Kotest is a multi-platform project . If you are unfamilar with this, then Kotlin compiles to different targets - JVM, JS, Native, iOS and so on. If you are doing server side or android development then you want the modules that end with JVM, such as kotest-property-jvm . Gradle To use in gradle, configure your build to use the JUnit Platform . For Gradle 4.6 and higher this is as simple as adding useJUnitPlatform() inside the tasks with type Test and then adding the Kotest dependency. Groovy (build.gradle) test { useJUnitPlatform() } dependencies { testImplementation 'io.kotest:kotest-runner-junit5:<version>' // for kotest framework testImplementation 'io.kotest:kotest-assertions-core:<version>' // for kotest core jvm assertions testImplementation 'io.kotest:kotest-property:<version>' // for kotest property test } Android Project (Groovy) android.testOptions { unitTests.all { useJUnitPlatform() } } dependencies { testImplementation 'io.kotest:kotest-runner-junit5:<version>' // for kotest framework testImplementation 'io.kotest:kotest-assertions-core:<version>' // for kotest core jvm assertions testImplementation 'io.kotest:kotest-property:<version>' // for kotest property test } If you are using Gradle+Kotlin, this works for both Android and non-Android projects: Kotlin (build.gradle.kts) tasks.withType<Test> { useJUnitPlatform() } dependencies { testImplementation(\"io.kotest:kotest-runner-junit5:<version>\") // for kotest framework testImplementation(\"io.kotest:kotest-assertions-core:<version>\") // for kotest core jvm assertions testImplementation(\"io.kotest:kotest-property:<version>\") // for kotest property test } Maven For maven you must configure the surefire plugin for junit tests. <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-surefire-plugin</artifactId> <version>2.22.2</version> </plugin> And then add the Kotest JUnit5 runner to your build to use the framework product. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-runner-junit5-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency> For using kotest core jvm assertions add the following configuration. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-assertions-core-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency> And for using kotest property testing add the following configuration. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-property-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency> Snapshots Snapshot are automatically published on each commit to master. If you want to test the latest snapshot build, setup the same way described above, change the version to the current snapshot version and add the following repository to your repositories block: repositories { maven(url = \"https://oss.sonatype.org/content/repositories/snapshots/\") }","title":"Quick start"},{"location":"quick_start/#quick-start","text":"Kotest is split into 3 basic sub-projects. These are provided separately so you can pick and choose which parts to use if you don't want to go all in on Kotest. Test Framework Layout tests in a fluid way and execute them on the JVM or Javascript. Assertions Library A Kotlin-first multi-platform assertions library. Property Testing An advanced multi-platform property test library with shrinking support.","title":"Quick Start"},{"location":"quick_start/#which-subprojects-to-use","text":"If you want to lay out tests in a fluid way ; with built in coroutine support at every level; the ability to use functions as test lifecycle callbacks ; with extensive extension points; with advanced conditional evaluation ; and execute these tests on the JVM and/or Javascript, then build your test classes using the Kotest Test Framework. If you want a Kotlin focused multi-platform enabled assertions library; with over 300 rich assertions ; with support for inspectors ; helpers for non-determistic tests ; powerful data driven testing ; modules for arrow , json and more, then opt to use the Kotest assertions library. If you want a powerful multi-platform enabled property test library, with over 50 built in generators ; the ability to easily compose new generators; with failure shrinking; with exhaustive checks; with coverage metrics; then choose the Kotest property test module. The following instructions give you the batteries included setup in gradle or maven. Omit any modules you don't wish to use. Info Kotest is a multi-platform project . If you are unfamilar with this, then Kotlin compiles to different targets - JVM, JS, Native, iOS and so on. If you are doing server side or android development then you want the modules that end with JVM, such as kotest-property-jvm .","title":"Which subproject(s) to use?"},{"location":"quick_start/#gradle","text":"To use in gradle, configure your build to use the JUnit Platform . For Gradle 4.6 and higher this is as simple as adding useJUnitPlatform() inside the tasks with type Test and then adding the Kotest dependency. Groovy (build.gradle) test { useJUnitPlatform() } dependencies { testImplementation 'io.kotest:kotest-runner-junit5:<version>' // for kotest framework testImplementation 'io.kotest:kotest-assertions-core:<version>' // for kotest core jvm assertions testImplementation 'io.kotest:kotest-property:<version>' // for kotest property test } Android Project (Groovy) android.testOptions { unitTests.all { useJUnitPlatform() } } dependencies { testImplementation 'io.kotest:kotest-runner-junit5:<version>' // for kotest framework testImplementation 'io.kotest:kotest-assertions-core:<version>' // for kotest core jvm assertions testImplementation 'io.kotest:kotest-property:<version>' // for kotest property test } If you are using Gradle+Kotlin, this works for both Android and non-Android projects: Kotlin (build.gradle.kts) tasks.withType<Test> { useJUnitPlatform() } dependencies { testImplementation(\"io.kotest:kotest-runner-junit5:<version>\") // for kotest framework testImplementation(\"io.kotest:kotest-assertions-core:<version>\") // for kotest core jvm assertions testImplementation(\"io.kotest:kotest-property:<version>\") // for kotest property test }","title":"Gradle"},{"location":"quick_start/#maven","text":"For maven you must configure the surefire plugin for junit tests. <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-surefire-plugin</artifactId> <version>2.22.2</version> </plugin> And then add the Kotest JUnit5 runner to your build to use the framework product. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-runner-junit5-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency> For using kotest core jvm assertions add the following configuration. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-assertions-core-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency> And for using kotest property testing add the following configuration. <dependency> <groupId>io.kotest</groupId> <artifactId>kotest-property-jvm</artifactId> <version>{version}</version> <scope>test</scope> </dependency>","title":"Maven"},{"location":"quick_start/#snapshots","text":"Snapshot are automatically published on each commit to master. If you want to test the latest snapshot build, setup the same way described above, change the version to the current snapshot version and add the following repository to your repositories block: repositories { maven(url = \"https://oss.sonatype.org/content/repositories/snapshots/\") }","title":"Snapshots"},{"location":"spec_ordering/","text":"Spec Ordering By default, the ordering of Spec classes is not defined. This means they are essentially random, in whatever order the discovery mechanism finds them. This is often sufficient, but if we need control over the execution order of specs, we can do this by specifying the order in project config . class MyConfig: AbstractProjectConfig() { override val specExecutionOrder = ... } There are several options. Undefined - This is the default. The order of specs is undefined and will execute in the order they are discovered at runtime. Eg either from JVM classpath discovery, or the order they appear in javascript files. Lexicographic - Specs are ordered lexicographically. Random - Specs are explicitly executed in a random order. Annotated - Specs are ordered using the @Order annotation added at the class level, with lowest values executed first. Any specs without such an annotation are considered \"last\". This option only works on the JVM. Any ties will be broken arbitrarily. Annotated Example Given the following specs annoated with @Order. @Order(1) class FooTest : FunSpec() { } @Order(0) class BarTest: FunSpec() {} @Order(1) class FarTest : FunSpec() { } class BooTest : FunSpec() {} BarTest will be executed first, as it has the lowest order value. FooTest and FarTest will be executed next, as they have the next lowest order values, although their values are both 1 so the order between them is undefined. Finally, BooTest will execute last, as it has no annotation.","title":"Spec ordering"},{"location":"spec_ordering/#spec-ordering","text":"By default, the ordering of Spec classes is not defined. This means they are essentially random, in whatever order the discovery mechanism finds them. This is often sufficient, but if we need control over the execution order of specs, we can do this by specifying the order in project config . class MyConfig: AbstractProjectConfig() { override val specExecutionOrder = ... } There are several options. Undefined - This is the default. The order of specs is undefined and will execute in the order they are discovered at runtime. Eg either from JVM classpath discovery, or the order they appear in javascript files. Lexicographic - Specs are ordered lexicographically. Random - Specs are explicitly executed in a random order. Annotated - Specs are ordered using the @Order annotation added at the class level, with lowest values executed first. Any specs without such an annotation are considered \"last\". This option only works on the JVM. Any ties will be broken arbitrarily.","title":"Spec Ordering"},{"location":"spec_ordering/#annotated-example","text":"Given the following specs annoated with @Order. @Order(1) class FooTest : FunSpec() { } @Order(0) class BarTest: FunSpec() {} @Order(1) class FarTest : FunSpec() { } class BooTest : FunSpec() {} BarTest will be executed first, as it has the lowest order value. FooTest and FarTest will be executed next, as they have the next lowest order values, although their values are both 1 so the order between them is undefined. Finally, BooTest will execute last, as it has no annotation.","title":"Annotated Example"},{"location":"styles/","text":"Testing Styles Kotest offers 10 different styles of test layout. Some are inspired from other popular test frameworks to make you feel right at home. Others were created just for Kotest. Test Style Inspired By Fun Spec ScalaTest Describe Spec Javascript frameworks and RSpec Should Spec A Kotest original String Spec A Kotest original Behavior Spec BDD frameworks Free Spec ScalaTest Word Spec ScalaTest Feature Spec Cucumber Expect Spec A Kotest original Annotation Spec JUnit There are no functional differences between the styles. All allow the same types of configuration \u2014 threads, tags, etc \u2014 it is simply a matter of preference how you structure your tests. Tip Some teams prefer to mandate usage of a single style, others mix and match. There is no right or wrong - do whatever feels right for your team. Fun Spec FunSpec allows you to create tests by invoking a function called test with a string parameter to describe the test, and then the test itself as a lambda. If in doubt, this is the style to use. class MyTests : FunSpec({ test(\"String length should return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } }) Tests can be disabled using the xcontext and xtest variants (in addition to the usual ways ) class MyTests : DescribeSpec({ context(\"this outer block is enabled\") { xtest(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { test(\"disabled by inheritance from the parent\") { // test here } } }) String Spec StringSpec reduces the syntax to the absolute minimum. Just write a string followed by a lambda expression with your test code. class MyTests : StringSpec({ \"strings.length should return size of string\" { \"hello\".length shouldBe 5 } }) Adding config to the test. class MyTests : StringSpec({ \"strings.length should return size of string\".config(enabled = false, invocations = 3) { \"hello\".length shouldBe 5 } }) Should Spec ShouldSpec is similar to fun spec, but uses the keyword should instead of test . class MyTests : ShouldSpec({ should(\"return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } }) Tests can be nested in one or more context blocks as well: class MyTests : ShouldSpec({ context(\"String.length\") { should(\"return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } }) Tests can be disabled using the xcontext and xshould variants (in addition to the usual ways ) class MyTests : ShouldSpec({ context(\"this outer block is enabled\") { xshould(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { should(\"disabled by inheritance from the parent\") { // test here } } }) Describe Spec DescribeSpec offers a style familiar to those from a Ruby or Javascript background, as this testing style uses describe / it keywords. Tests must be nested in one or more describe blocks. class MyTests : DescribeSpec({ describe(\"score\") { it(\"start as zero\") { // test here } describe(\"with a strike\") { it(\"adds ten\") { // test here } it(\"carries strike to the next frame\") { // test here } } describe(\"for the opposite team\") { it(\"Should negate one score\") { // test here } } } }) Tests can be disabled using the xdescribe and xit variants (in addition to the usual ways ) class MyTests : DescribeSpec({ describe(\"this outer block is enabled\") { xit(\"this test is disabled\") { // test here } } xdescribe(\"this block is disabled\") { it(\"disabled by inheritance from the parent\") { // test here } } }) Behavior Spec Popular with people who like to write tests in the BDD style, BehaviorSpec allows you to use given , when , then . class MyTests : BehaviorSpec({ given(\"a broomstick\") { `when`(\"I sit on it\") { then(\"I should be able to fly\") { // test code } } `when`(\"I throw it away\") { then(\"it should come back\") { // test code } } } }) Tip Because when is a keyword in Kotlin, we must enclose it with backticks. Alternatively, there are title case versions available if you don't like the use of backticks, eg, Given , When , Then . You can also use the And keyword in Given and When to add an extra depth to it: class MyTests : BehaviorSpec({ given(\"a broomstick\") { and(\"a witch\") { `when`(\"The witch sits on it\") { and(\"she laughs hysterically\") { then(\"She should be able to fly\") { // test code } } } } } }) Note: Then scope doesn't have an and scope due to a Gradle bug. For more information, see #594 Tests can be disabled using the xgiven , xwhen , and xthen variants (in addition to the usual ways ) class MyTests : DescribeSpec({ xgiven(\"this is disabled\") { When(\"disabled by inheritance from the parent\") { then(\"disabled by inheritance from its grandparent\") { // disabled test } } } given(\"this is active\") { When(\"this is active too\") { xthen(\"this is disabled\") { // disabled test } } } }) Word Spec WordSpec uses the keyword should and uses that to nest tests after a context string. class MyTests : WordSpec({ \"String.length\" should { \"return the length of the string\" { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } }) It also supports the keyword When allowing to add another level of nesting. Note, since when is a keyword in Kotlin, we must use backticks or the uppercase variant. class MyTests : WordSpec({ \"Hello\" When { \"asked for length\" should { \"return 5\" { \"Hello\".length shouldBe 5 } } \"appended to Bob\" should { \"return Hello Bob\" { \"Hello \" + \"Bob\" shouldBe \"Hello Bob\" } } } }) Free Spec FreeSpec allows you to nest arbitrary levels of depth using the keyword - (minus) for outer tests, and just the test name for the final test: class MyTests : FreeSpec({ \"String.length\" - { \"should return the length of the string\" { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } \"containers can be nested as deep as you want\" - { \"and so we nest another container\" - { \"yet another container\" - { \"finally a real test\" { 1 + 1 shouldBe 2 } } } } }) Warning The innermost test must not use the - (minus) keyword after the test name. Feature Spec FeatureSpec allows you to use feature and scenario , which will be familiar to those who have used cucumber . Although not intended to be exactly the same as cucumber, the keywords mimic the style. class MyTests : FeatureSpec({ feature(\"the can of coke\") { scenario(\"should be fizzy when I shake it\") { // test here } scenario(\"and should be tasty\") { // test here } } }) Tests can be disabled using the xfeature and xscenario variants (in addition to the usual ways ) class MyTests : FeatureSpec({ feature(\"this outer block is enabled\") { xscenario(\"this test is disabled\") { // test here } } xfeature(\"this block is disabled\") { scenario(\"disabled by inheritance from the parent\") { // test here } } }) Expect Spec ExpectSpec is similar to FunSpec and ShouldSpec but uses the expect keyword. class MyTests : ExpectSpec({ expect(\"my test\") { // test here } }) Tests can be nested in one or more context blocks as well: class MyTests : ExpectSpec({ context(\"a calculator\") { expect(\"simple addition\") { // test here } expect(\"integer overflow\") { // test here } } }) Tests can be disabled using the xcontext and xexpect variants (in addition to the usual ways ) class MyTests : DescribeSpec({ context(\"this outer block is enabled\") { xexpect(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { expect(\"disabled by inheritance from the parent\") { // test here } } }) Annotation Spec If you are migrating from JUnit then AnnotationSpec is a spec that uses annotations like JUnit 4/5. Just add the @Test annotation to any function defined in the spec class. You can also add annotations to execute something before tests/specs and after tests/specs, similarly to JUnit's @BeforeAll / @BeforeClass @BeforeEach / @Before @AfterAll / @AfterClass @AfterEach / @After If you want to ignore a test, use @Ignore . Success Although this spec doesn't offer much advantage over using JUnit, it allows you to migrate existing tests relatively easily, as you typically just need to adjust imports. class AnnotationSpecExample : AnnotationSpec() { @BeforeEach fun beforeTest() { println(\"Before each test\") } @Test fun test1() { 1 shouldBe 1 } @Test fun test2() { 3 shouldBe 3 } }","title":"Styles"},{"location":"styles/#testing-styles","text":"Kotest offers 10 different styles of test layout. Some are inspired from other popular test frameworks to make you feel right at home. Others were created just for Kotest. Test Style Inspired By Fun Spec ScalaTest Describe Spec Javascript frameworks and RSpec Should Spec A Kotest original String Spec A Kotest original Behavior Spec BDD frameworks Free Spec ScalaTest Word Spec ScalaTest Feature Spec Cucumber Expect Spec A Kotest original Annotation Spec JUnit There are no functional differences between the styles. All allow the same types of configuration \u2014 threads, tags, etc \u2014 it is simply a matter of preference how you structure your tests. Tip Some teams prefer to mandate usage of a single style, others mix and match. There is no right or wrong - do whatever feels right for your team.","title":"Testing Styles"},{"location":"styles/#fun-spec","text":"FunSpec allows you to create tests by invoking a function called test with a string parameter to describe the test, and then the test itself as a lambda. If in doubt, this is the style to use. class MyTests : FunSpec({ test(\"String length should return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } }) Tests can be disabled using the xcontext and xtest variants (in addition to the usual ways ) class MyTests : DescribeSpec({ context(\"this outer block is enabled\") { xtest(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { test(\"disabled by inheritance from the parent\") { // test here } } })","title":"Fun Spec"},{"location":"styles/#string-spec","text":"StringSpec reduces the syntax to the absolute minimum. Just write a string followed by a lambda expression with your test code. class MyTests : StringSpec({ \"strings.length should return size of string\" { \"hello\".length shouldBe 5 } }) Adding config to the test. class MyTests : StringSpec({ \"strings.length should return size of string\".config(enabled = false, invocations = 3) { \"hello\".length shouldBe 5 } })","title":"String Spec"},{"location":"styles/#should-spec","text":"ShouldSpec is similar to fun spec, but uses the keyword should instead of test . class MyTests : ShouldSpec({ should(\"return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } }) Tests can be nested in one or more context blocks as well: class MyTests : ShouldSpec({ context(\"String.length\") { should(\"return the length of the string\") { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } }) Tests can be disabled using the xcontext and xshould variants (in addition to the usual ways ) class MyTests : ShouldSpec({ context(\"this outer block is enabled\") { xshould(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { should(\"disabled by inheritance from the parent\") { // test here } } })","title":"Should Spec"},{"location":"styles/#describe-spec","text":"DescribeSpec offers a style familiar to those from a Ruby or Javascript background, as this testing style uses describe / it keywords. Tests must be nested in one or more describe blocks. class MyTests : DescribeSpec({ describe(\"score\") { it(\"start as zero\") { // test here } describe(\"with a strike\") { it(\"adds ten\") { // test here } it(\"carries strike to the next frame\") { // test here } } describe(\"for the opposite team\") { it(\"Should negate one score\") { // test here } } } }) Tests can be disabled using the xdescribe and xit variants (in addition to the usual ways ) class MyTests : DescribeSpec({ describe(\"this outer block is enabled\") { xit(\"this test is disabled\") { // test here } } xdescribe(\"this block is disabled\") { it(\"disabled by inheritance from the parent\") { // test here } } })","title":"Describe Spec"},{"location":"styles/#behavior-spec","text":"Popular with people who like to write tests in the BDD style, BehaviorSpec allows you to use given , when , then . class MyTests : BehaviorSpec({ given(\"a broomstick\") { `when`(\"I sit on it\") { then(\"I should be able to fly\") { // test code } } `when`(\"I throw it away\") { then(\"it should come back\") { // test code } } } }) Tip Because when is a keyword in Kotlin, we must enclose it with backticks. Alternatively, there are title case versions available if you don't like the use of backticks, eg, Given , When , Then . You can also use the And keyword in Given and When to add an extra depth to it: class MyTests : BehaviorSpec({ given(\"a broomstick\") { and(\"a witch\") { `when`(\"The witch sits on it\") { and(\"she laughs hysterically\") { then(\"She should be able to fly\") { // test code } } } } } }) Note: Then scope doesn't have an and scope due to a Gradle bug. For more information, see #594 Tests can be disabled using the xgiven , xwhen , and xthen variants (in addition to the usual ways ) class MyTests : DescribeSpec({ xgiven(\"this is disabled\") { When(\"disabled by inheritance from the parent\") { then(\"disabled by inheritance from its grandparent\") { // disabled test } } } given(\"this is active\") { When(\"this is active too\") { xthen(\"this is disabled\") { // disabled test } } } })","title":"Behavior Spec"},{"location":"styles/#word-spec","text":"WordSpec uses the keyword should and uses that to nest tests after a context string. class MyTests : WordSpec({ \"String.length\" should { \"return the length of the string\" { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } }) It also supports the keyword When allowing to add another level of nesting. Note, since when is a keyword in Kotlin, we must use backticks or the uppercase variant. class MyTests : WordSpec({ \"Hello\" When { \"asked for length\" should { \"return 5\" { \"Hello\".length shouldBe 5 } } \"appended to Bob\" should { \"return Hello Bob\" { \"Hello \" + \"Bob\" shouldBe \"Hello Bob\" } } } })","title":"Word Spec"},{"location":"styles/#free-spec","text":"FreeSpec allows you to nest arbitrary levels of depth using the keyword - (minus) for outer tests, and just the test name for the final test: class MyTests : FreeSpec({ \"String.length\" - { \"should return the length of the string\" { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } \"containers can be nested as deep as you want\" - { \"and so we nest another container\" - { \"yet another container\" - { \"finally a real test\" { 1 + 1 shouldBe 2 } } } } }) Warning The innermost test must not use the - (minus) keyword after the test name.","title":"Free Spec"},{"location":"styles/#feature-spec","text":"FeatureSpec allows you to use feature and scenario , which will be familiar to those who have used cucumber . Although not intended to be exactly the same as cucumber, the keywords mimic the style. class MyTests : FeatureSpec({ feature(\"the can of coke\") { scenario(\"should be fizzy when I shake it\") { // test here } scenario(\"and should be tasty\") { // test here } } }) Tests can be disabled using the xfeature and xscenario variants (in addition to the usual ways ) class MyTests : FeatureSpec({ feature(\"this outer block is enabled\") { xscenario(\"this test is disabled\") { // test here } } xfeature(\"this block is disabled\") { scenario(\"disabled by inheritance from the parent\") { // test here } } })","title":"Feature Spec"},{"location":"styles/#expect-spec","text":"ExpectSpec is similar to FunSpec and ShouldSpec but uses the expect keyword. class MyTests : ExpectSpec({ expect(\"my test\") { // test here } }) Tests can be nested in one or more context blocks as well: class MyTests : ExpectSpec({ context(\"a calculator\") { expect(\"simple addition\") { // test here } expect(\"integer overflow\") { // test here } } }) Tests can be disabled using the xcontext and xexpect variants (in addition to the usual ways ) class MyTests : DescribeSpec({ context(\"this outer block is enabled\") { xexpect(\"this test is disabled\") { // test here } } xcontext(\"this block is disabled\") { expect(\"disabled by inheritance from the parent\") { // test here } } })","title":"Expect Spec"},{"location":"styles/#annotation-spec","text":"If you are migrating from JUnit then AnnotationSpec is a spec that uses annotations like JUnit 4/5. Just add the @Test annotation to any function defined in the spec class. You can also add annotations to execute something before tests/specs and after tests/specs, similarly to JUnit's @BeforeAll / @BeforeClass @BeforeEach / @Before @AfterAll / @AfterClass @AfterEach / @After If you want to ignore a test, use @Ignore . Success Although this spec doesn't offer much advantage over using JUnit, it allows you to migrate existing tests relatively easily, as you typically just need to adjust imports. class AnnotationSpecExample : AnnotationSpec() { @BeforeEach fun beforeTest() { println(\"Before each test\") } @Test fun test1() { 1 shouldBe 1 } @Test fun test2() { 3 shouldBe 3 } }","title":"Annotation Spec"},{"location":"tags/","text":"Grouping Tests with Tags Sometimes you don't want to run all tests and Kotest provides tags to be able to determine which tests are executed at runtime. Tags are objects inheriting from io.kotest.core.Tag . For example, to group tests by operating system you could define the following tags: object Linux : Tag() object Windows: Tag() Alternatively, tags can be defined using the StringTag class. When using this class, observe the following rules: A tag must not be null or blank. A tag must not contain whitespace. A tag must not contain ISO control characters. A tag must not contain any of the following characters: !: exclamation mark (: left paren ): right paren &: ampersand |: pipe For example: val tag = StringTag(\"Linux\") Marking Tests Test cases can then be marked with tags using the config function: import io.kotest.specs.StringSpec class MyTest : StringSpec() { init { \"should run on Windows\".config(tags = setOf(Windows)) { // ... } \"should run on Linux\".config(tags = setOf(Linux)) { // ... } \"should run on Windows and Linux\".config(tags = setOf(Windows, Linux)) { // ... } } } Running with Tags Then by invoking the test runner with a system property of kotest.tags you can control which tests are run. The expression to be passed in is a simple boolean expression using boolean operators: & , | , ! , with parenthesis for association. For example, Tag1 & (Tag2 | Tag3) Provide the simple names of tag object (without package) when you run the tests. Please pay attention to the use of upper case and lower case! If two tag objects have the same simple name (in different name spaces) they are treated as the same tag. Example: To run only test tagged with Linux , but not tagged with Database , you would invoke Gradle like this: gradle test -Dkotest.tags=\"Linux & !Database\" Tags can also be included/excluded in runtime (for example, if you're running a project configuration instead of properties) through the RuntimeTagExtension : RuntimeTagExpressionExtension.expression = \"Linux & !Database\" Tag Expression Operators Operators (in descending order of precedence) Operator Description Example ! not !macos & and linux & integration | or windows | microservice Marking Specs You can mark all tests in a spec using the tags function in the spec itself. class MyTestClass : FunSpec({ tags(Linux, Mysql) test(\"my test\") { } // automatically marked with the above tags }) Warning When tagging tests in this way, the Spec will still need to be instantiated in order to retrieve the tags. If no root tests are active at runtime, the beforeSpec and afterSpec callbacks will not be invoked. If you wish to avoid creating the spec class at all then you can annotate a spec using @Tags(tag1, ...) . Any tags added using this annotation apply to all tests in the class, however this will not stop a class from being instantiated unless explicitly excluded. Consider the following example: @Tags(Linux) class MyTestClass : FunSpec({ tags(UnitTest) beforeSpec { println(\"Before\") } test(\"A\").config(tags = setOf(Mysql)) {} test(\"B\").config(tags = setOf(Postgres)) {} test(\"C\") {} }) Property Spec Created Callbacks Outcome kotest.tags=Linux yes yes A, B, C are executed because all tests inherit the Linux tag from the annotation kotest.tags=Linux & Mysql yes yes A is executed only because all tests have the Linux tag, but only A has the Mysql tag kotest.tags=!Linux no no No tests are executed, and the MyTestClass is not instantiated because we can exclude it based on the tags annotation kotest.tags=!UnitTest yes no No tests are executed because all tests inherit UnitTest from the tags function. MyTestClass is instantiated in order to retrieve the tags defined in the class. The beforeSpec callback is not executed because there are no active tests. kotest.tags=Mysql yes yes A is executed only, because that is the only test marked with Mysql kotest.tags=!Mysql yes yes B, C are executed only, because A is excluded by being marked with Mysql kotest.tags=Linux & !Mysql yes yes B, C are executed only, because all tests inherit Linux from the annotation, but A is excluded by the Mysql tag Gradle Special attention is needed in your gradle configuration To use System Properties (-Dx=y), your gradle must be configured to propagate them to the test executors, and an extra configuration must be added to your tests: Groovy: test { //... Other configurations ... systemProperties = System.properties } Kotlin Gradle DSL: val test by tasks.getting(Test::class) { // ... Other configurations ... systemProperties = System.getProperties().map { it.key.toString() to it.value }.toMap() } This will guarantee that the system property is correctly read by the JVM","title":"Tags"},{"location":"tags/#grouping-tests-with-tags","text":"Sometimes you don't want to run all tests and Kotest provides tags to be able to determine which tests are executed at runtime. Tags are objects inheriting from io.kotest.core.Tag . For example, to group tests by operating system you could define the following tags: object Linux : Tag() object Windows: Tag() Alternatively, tags can be defined using the StringTag class. When using this class, observe the following rules: A tag must not be null or blank. A tag must not contain whitespace. A tag must not contain ISO control characters. A tag must not contain any of the following characters: !: exclamation mark (: left paren ): right paren &: ampersand |: pipe For example: val tag = StringTag(\"Linux\")","title":"Grouping Tests with Tags"},{"location":"tags/#marking-tests","text":"Test cases can then be marked with tags using the config function: import io.kotest.specs.StringSpec class MyTest : StringSpec() { init { \"should run on Windows\".config(tags = setOf(Windows)) { // ... } \"should run on Linux\".config(tags = setOf(Linux)) { // ... } \"should run on Windows and Linux\".config(tags = setOf(Windows, Linux)) { // ... } } }","title":"Marking Tests"},{"location":"tags/#running-with-tags","text":"Then by invoking the test runner with a system property of kotest.tags you can control which tests are run. The expression to be passed in is a simple boolean expression using boolean operators: & , | , ! , with parenthesis for association. For example, Tag1 & (Tag2 | Tag3) Provide the simple names of tag object (without package) when you run the tests. Please pay attention to the use of upper case and lower case! If two tag objects have the same simple name (in different name spaces) they are treated as the same tag. Example: To run only test tagged with Linux , but not tagged with Database , you would invoke Gradle like this: gradle test -Dkotest.tags=\"Linux & !Database\" Tags can also be included/excluded in runtime (for example, if you're running a project configuration instead of properties) through the RuntimeTagExtension : RuntimeTagExpressionExtension.expression = \"Linux & !Database\"","title":"Running with Tags"},{"location":"tags/#tag-expression-operators","text":"Operators (in descending order of precedence) Operator Description Example ! not !macos & and linux & integration | or windows | microservice","title":"Tag Expression Operators"},{"location":"tags/#marking-specs","text":"You can mark all tests in a spec using the tags function in the spec itself. class MyTestClass : FunSpec({ tags(Linux, Mysql) test(\"my test\") { } // automatically marked with the above tags }) Warning When tagging tests in this way, the Spec will still need to be instantiated in order to retrieve the tags. If no root tests are active at runtime, the beforeSpec and afterSpec callbacks will not be invoked. If you wish to avoid creating the spec class at all then you can annotate a spec using @Tags(tag1, ...) . Any tags added using this annotation apply to all tests in the class, however this will not stop a class from being instantiated unless explicitly excluded. Consider the following example: @Tags(Linux) class MyTestClass : FunSpec({ tags(UnitTest) beforeSpec { println(\"Before\") } test(\"A\").config(tags = setOf(Mysql)) {} test(\"B\").config(tags = setOf(Postgres)) {} test(\"C\") {} }) Property Spec Created Callbacks Outcome kotest.tags=Linux yes yes A, B, C are executed because all tests inherit the Linux tag from the annotation kotest.tags=Linux & Mysql yes yes A is executed only because all tests have the Linux tag, but only A has the Mysql tag kotest.tags=!Linux no no No tests are executed, and the MyTestClass is not instantiated because we can exclude it based on the tags annotation kotest.tags=!UnitTest yes no No tests are executed because all tests inherit UnitTest from the tags function. MyTestClass is instantiated in order to retrieve the tags defined in the class. The beforeSpec callback is not executed because there are no active tests. kotest.tags=Mysql yes yes A is executed only, because that is the only test marked with Mysql kotest.tags=!Mysql yes yes B, C are executed only, because A is excluded by being marked with Mysql kotest.tags=Linux & !Mysql yes yes B, C are executed only, because all tests inherit Linux from the annotation, but A is excluded by the Mysql tag","title":"Marking Specs"},{"location":"tags/#gradle","text":"Special attention is needed in your gradle configuration To use System Properties (-Dx=y), your gradle must be configured to propagate them to the test executors, and an extra configuration must be added to your tests: Groovy: test { //... Other configurations ... systemProperties = System.properties } Kotlin Gradle DSL: val test by tasks.getting(Test::class) { // ... Other configurations ... systemProperties = System.getProperties().map { it.key.toString() to it.value }.toMap() } This will guarantee that the system property is correctly read by the JVM","title":"Gradle"},{"location":"tempfile/","text":"Temporary Files Sometimes it is requires for a test to create a file and delete it after test, deleting it manually may lead to flaky test. For example, you may be using a temporary file during a test. If the test passes successfully, your clean up code will execute and the file will be deleted. But in case the assertion fails or another error occurs, which may have caused the file to not be deleted, you will get a stale file which might affect the test on the next run (file cannot be overwritten exception and so on). Kotest provides a function tempfile() which you can use in your Spec to create a temporary file for your tests, and which Kotest will take the responsibility of cleaning up after running all tests in the Spec. This way your tests does not have to worry about deleting the temporary file. class MySpec : FunSpec({ val file = tempfile() test(\"a temporary file dependent test\") { //... } })","title":"Temporary Files"},{"location":"tempfile/#temporary-files","text":"Sometimes it is requires for a test to create a file and delete it after test, deleting it manually may lead to flaky test. For example, you may be using a temporary file during a test. If the test passes successfully, your clean up code will execute and the file will be deleted. But in case the assertion fails or another error occurs, which may have caused the file to not be deleted, you will get a stale file which might affect the test on the next run (file cannot be overwritten exception and so on). Kotest provides a function tempfile() which you can use in your Spec to create a temporary file for your tests, and which Kotest will take the responsibility of cleaning up after running all tests in the Spec. This way your tests does not have to worry about deleting the temporary file. class MySpec : FunSpec({ val file = tempfile() test(\"a temporary file dependent test\") { //... } })","title":"Temporary Files"},{"location":"test_case_config/","text":"Test Case Config Each test can be configured with various parameters. After the test name, invoke the config function passing in the parameters you wish to set. The available parameters are: invocations - The number of times to run this test. Useful if you have a non-deterministic test and you want to run that particular test a set number of times to see if it eventually fails. A test will only succeed if all invocations succeed. Defaults to 1. threads - Allows the invocation of this test to be parallelized by setting the number of threads. Value must be less or equal of invocations value. Similarly, if you set invocations to a value equal to the number threads, then each invocation will have its own thread. enabled - If set to false then this test is disabled . Can be useful if a test needs to be temporarily ignored. You can also use this parameter with boolean expressions to run a test only under certain conditions. enabledIf - A function which provides the same ability as enabled but is lazily evaluated when the test case is due for execution. timeout - sets a timeout for this test. If the test has not finished in that time then the test fails. Useful for code that is non-deterministic and might not finish. Timeout is of type kotlin.Duration which can be instantiated like 2.seconds , 3.minutes and so on. tags - a set of tags that can be used to group tests (see detailed description below). listeners - register test listeners to run only on this test. extensions - register extensions to run only on this test. An example of setting config on a test: class MyTests : ShouldSpec() { init { should(\"return the length of the string\").config(invocations = 10, threads = 2) { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } } class MyTests : WordSpec() { init { \"String.length\" should { \"return the length of the string\".config(timeout = 2.seconds) { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } } } class FunSpecTest : FunSpec() { init { test(\"FunSpec should support config syntax\").config(tags = setOf(Database, Linux)) { // ... } } } You can also specify a default TestCaseConfig for all test cases of a Spec: Overriding the defaultTestCaseConfig function: class MySpec : StringSpec() { override fun defaultTestCaseConfig() = TestCaseConfig(invocations = 3) init { // your test cases ... } } Or via assignment to the defaultTestConfig val: class FunSpecTest : FunSpec() { init { defaultTestConfig = TestCaseConfig(enabled = true, invocations = 3) test(\"FunSpec should support Spec config syntax in init{} block\") { // ... } } }","title":"Test Case Config"},{"location":"test_case_config/#test-case-config","text":"Each test can be configured with various parameters. After the test name, invoke the config function passing in the parameters you wish to set. The available parameters are: invocations - The number of times to run this test. Useful if you have a non-deterministic test and you want to run that particular test a set number of times to see if it eventually fails. A test will only succeed if all invocations succeed. Defaults to 1. threads - Allows the invocation of this test to be parallelized by setting the number of threads. Value must be less or equal of invocations value. Similarly, if you set invocations to a value equal to the number threads, then each invocation will have its own thread. enabled - If set to false then this test is disabled . Can be useful if a test needs to be temporarily ignored. You can also use this parameter with boolean expressions to run a test only under certain conditions. enabledIf - A function which provides the same ability as enabled but is lazily evaluated when the test case is due for execution. timeout - sets a timeout for this test. If the test has not finished in that time then the test fails. Useful for code that is non-deterministic and might not finish. Timeout is of type kotlin.Duration which can be instantiated like 2.seconds , 3.minutes and so on. tags - a set of tags that can be used to group tests (see detailed description below). listeners - register test listeners to run only on this test. extensions - register extensions to run only on this test. An example of setting config on a test: class MyTests : ShouldSpec() { init { should(\"return the length of the string\").config(invocations = 10, threads = 2) { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } } class MyTests : WordSpec() { init { \"String.length\" should { \"return the length of the string\".config(timeout = 2.seconds) { \"sammy\".length shouldBe 5 \"\".length shouldBe 0 } } } } class FunSpecTest : FunSpec() { init { test(\"FunSpec should support config syntax\").config(tags = setOf(Database, Linux)) { // ... } } } You can also specify a default TestCaseConfig for all test cases of a Spec: Overriding the defaultTestCaseConfig function: class MySpec : StringSpec() { override fun defaultTestCaseConfig() = TestCaseConfig(invocations = 3) init { // your test cases ... } } Or via assignment to the defaultTestConfig val: class FunSpecTest : FunSpec() { init { defaultTestConfig = TestCaseConfig(enabled = true, invocations = 3) test(\"FunSpec should support Spec config syntax in init{} block\") { // ... } } }","title":"Test Case Config"},{"location":"test_extensions/","text":"Framework Extensions Discovery Extensions Kotest allows developers to configure how test classes are discovered. By default classes are scanned from the classpath but this extension allows developers to inject classes from any source. For full details see here","title":"Test extensions"},{"location":"test_extensions/#framework-extensions","text":"","title":"Framework Extensions"},{"location":"test_extensions/#discovery-extensions","text":"Kotest allows developers to configure how test classes are discovered. By default classes are scanned from the classpath but this extension allows developers to inject classes from any source. For full details see here","title":"Discovery Extensions"},{"location":"test_factories/","text":"Test Factories Sometimes we may wish to write a set of generic tests and then reuse them for specific inputs. In Kotest we can do this via test factories which create tests that can be included into one or more specs. Overview Say we wanted to build our own collections library. A slightly trite example, but one that serves the documentation purpose well. We could create an interface IndexedSeq which has two implementations, List and Vector . interface IndexedSeq<T> { // returns the size of t fun size(): Int // returns a new seq with t added fun add(t: T): IndexedSeq<T> // returns true if this seq contains t fun contains(t: T): Boolean } If we wanted to test our List implementation, we could do this: class ListTest : WordSpec({ val empty = List<Int>() \"List\" should { \"increase size as elements are added\" { empty.size() shouldBe 0 val plus1 = empty.add(1) plus1.size() shouldBe 1 val plus2 = plus2.add(2) plus2.size() shouldBe 2 } \"contain an element after it is added\" { empty.contains(1) shouldBe false empty.add(1).contains(1) shouldBe true empty.add(1).contains(2) shouldBe false } } }) Now, if we wanted to test Vector we have to copy n paste the test. As we add more implementations and more tests, the likelihood is our test suite will become fragmented and out of sync. We can address this by creating a test factory, which accepts an IndexedSeq as a parameter. To create a test factory, we use a builder function such as funSpec , wordSpec and so on. A builder function exists for each of the spec styles . So, to convert our previous tests to a test factory, we simply do the following: fun <T> indexedSeqTests(name: String, empty: IndexedSeq<T>) = wordSpec { name should { \"increase size as elements are added\" { empty.size() shouldBe 0 val plus1 = empty.add(1) plus1.size() shouldBe 1 val plus2 = plus2.add(2) plus2.size() shouldBe 2 } \"contain an element after it is added\" { empty.contains(1) shouldBe false empty.add(1).contains(1) shouldBe true empty.add(1).contains(2) shouldBe false } } }) And then to use this, we must include it one or more times into a spec (or several specs). Tip You can include any style factory into any style spec. For example, a fun spec factory can be included into a string spec class. class IndexedSeqTestSuite : WordSpec({ include(indexedSeqTests(\"vector\"), Vector()) include(indexedSeqTests(\"list\"), List()) }) A test class can include several different types of factory, as well as inline tests as normal. For example: class HugeTestFile : FunSpec({ test(\"first test\") { // test here } include(factory1(\"foo\")) include(factory2(1, 4)) test(\"another test\") { // testhere } }) Each included test appears in the test output and reports as if it was individually defined. Tip tests from factories are included in the order they are defined in the spec class. Listeners Test factories support the usual before and after test callbacks. Any callback added to a factory, will in turn be added to the spec or specs where the factory is included. However, only those tests generated by that factory will have the callback applied. This means you can create stand alone factories with their own lifecycle methods and be assured they won't clash with lifecycle methods defined in other factories or specs themselves. For example: val factory1 = funSpec { beforeTest { println(\"Executing $it\") } test(\"a\") { } test(\"b\") { } } class LifecycleExample : FunSpec({ incude(factory1) test(\"c\") test(\"d\") }) After executing the test suite, the following would be printed: Executing a Executing b And as you can see, the beforeTest block added to factory1 only applies to those tests defined in that factory, and not in the tests defined in the spec it was added to.","title":"Test factories"},{"location":"test_factories/#test-factories","text":"Sometimes we may wish to write a set of generic tests and then reuse them for specific inputs. In Kotest we can do this via test factories which create tests that can be included into one or more specs.","title":"Test Factories"},{"location":"test_factories/#overview","text":"Say we wanted to build our own collections library. A slightly trite example, but one that serves the documentation purpose well. We could create an interface IndexedSeq which has two implementations, List and Vector . interface IndexedSeq<T> { // returns the size of t fun size(): Int // returns a new seq with t added fun add(t: T): IndexedSeq<T> // returns true if this seq contains t fun contains(t: T): Boolean } If we wanted to test our List implementation, we could do this: class ListTest : WordSpec({ val empty = List<Int>() \"List\" should { \"increase size as elements are added\" { empty.size() shouldBe 0 val plus1 = empty.add(1) plus1.size() shouldBe 1 val plus2 = plus2.add(2) plus2.size() shouldBe 2 } \"contain an element after it is added\" { empty.contains(1) shouldBe false empty.add(1).contains(1) shouldBe true empty.add(1).contains(2) shouldBe false } } }) Now, if we wanted to test Vector we have to copy n paste the test. As we add more implementations and more tests, the likelihood is our test suite will become fragmented and out of sync. We can address this by creating a test factory, which accepts an IndexedSeq as a parameter. To create a test factory, we use a builder function such as funSpec , wordSpec and so on. A builder function exists for each of the spec styles . So, to convert our previous tests to a test factory, we simply do the following: fun <T> indexedSeqTests(name: String, empty: IndexedSeq<T>) = wordSpec { name should { \"increase size as elements are added\" { empty.size() shouldBe 0 val plus1 = empty.add(1) plus1.size() shouldBe 1 val plus2 = plus2.add(2) plus2.size() shouldBe 2 } \"contain an element after it is added\" { empty.contains(1) shouldBe false empty.add(1).contains(1) shouldBe true empty.add(1).contains(2) shouldBe false } } }) And then to use this, we must include it one or more times into a spec (or several specs). Tip You can include any style factory into any style spec. For example, a fun spec factory can be included into a string spec class. class IndexedSeqTestSuite : WordSpec({ include(indexedSeqTests(\"vector\"), Vector()) include(indexedSeqTests(\"list\"), List()) }) A test class can include several different types of factory, as well as inline tests as normal. For example: class HugeTestFile : FunSpec({ test(\"first test\") { // test here } include(factory1(\"foo\")) include(factory2(1, 4)) test(\"another test\") { // testhere } }) Each included test appears in the test output and reports as if it was individually defined. Tip tests from factories are included in the order they are defined in the spec class.","title":"Overview"},{"location":"test_factories/#listeners","text":"Test factories support the usual before and after test callbacks. Any callback added to a factory, will in turn be added to the spec or specs where the factory is included. However, only those tests generated by that factory will have the callback applied. This means you can create stand alone factories with their own lifecycle methods and be assured they won't clash with lifecycle methods defined in other factories or specs themselves. For example: val factory1 = funSpec { beforeTest { println(\"Executing $it\") } test(\"a\") { } test(\"b\") { } } class LifecycleExample : FunSpec({ incude(factory1) test(\"c\") test(\"d\") }) After executing the test suite, the following would be printed: Executing a Executing b And as you can see, the beforeTest block added to factory1 only applies to those tests defined in that factory, and not in the tests defined in the spec it was added to.","title":"Listeners"},{"location":"test_ordering/","text":"Test Ordering When running multiple tests from a Spec, there's a certain order on how to execute them. By default, a sequential order is used (order that tests are defined in the spec), but it's also possible to configure them to be executed in a random order or lexicographic order. This setting can be configured in either a Spec or in ProjectConfig by overriding the testCaseOrder function. If both exist, the Spec 's configuration will have priority. Note Nested tests will always run in discovery order (sequential). class SequentialSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Sequential init { \"foo\" { // I run first as I'm defined first } \"bar\" { // I run second as I'm defined second } } } class RandomSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Random init { \"foo\" { // This test may run first or second } \"bar\" { // This test may run first or second } } } class LexicographicSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Lexicographic init { \"foo\" { // I run second as bar < foo } \"bar\" { // I run first as bar < foo } } }","title":"Test ordering"},{"location":"test_ordering/#test-ordering","text":"When running multiple tests from a Spec, there's a certain order on how to execute them. By default, a sequential order is used (order that tests are defined in the spec), but it's also possible to configure them to be executed in a random order or lexicographic order. This setting can be configured in either a Spec or in ProjectConfig by overriding the testCaseOrder function. If both exist, the Spec 's configuration will have priority. Note Nested tests will always run in discovery order (sequential). class SequentialSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Sequential init { \"foo\" { // I run first as I'm defined first } \"bar\" { // I run second as I'm defined second } } } class RandomSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Random init { \"foo\" { // This test may run first or second } \"bar\" { // This test may run first or second } } } class LexicographicSpec : StringSpec() { override fun testCaseOrder(): TestCaseOrder? = TestCaseOrder.Lexicographic init { \"foo\" { // I run second as bar < foo } \"bar\" { // I run first as bar < foo } } }","title":"Test Ordering"},{"location":"third_party_integrations/","text":"Third Party Integrations This page lists some integrations from third party libraries and frameworks that are maintained and hosted outside of the Kotest repositories. Http4k - Functional toolkit for Kotlin HTTP applications Micronaut - JVM-based, full-stack framework for building modular, easily testable microservice","title":"Third party integrations"},{"location":"third_party_integrations/#third-party-integrations","text":"This page lists some integrations from third party libraries and frameworks that are maintained and hosted outside of the Kotest repositories. Http4k - Functional toolkit for Kotlin HTTP applications Micronaut - JVM-based, full-stack framework for building modular, easily testable microservice","title":"Third Party Integrations"},{"location":"timeout/","text":"Timeouts Tests have two types of timeout that can be applied. The first is the overall time for all invocations of a test. This is just called timeout . The second is per individual run of a test, and this is called invocation timeout . Kotest can be configured to invoke a test multiple times. For example, class TimeoutTest : DescribeSpec({ describe(\"my test context\") { it(\"run me three times\").config(invocations = 3) { // some slow network test that takes 1500 millis } } }) In this case, a timeout of 2000 millis would cause the test to fail, because the total run time would be 4500 millis. Whereas an invocation timeout of 2000 millis would not cause the test to fail, because each individual run is 1500 millis. Info Timeouts include the time taken for nested tests. We can specify the timeout at three levels. Test Level Timeouts The most finely grained location for timeouts it on leaf tests directly. class TimeoutTest : DescribeSpec({ describe(\"my test context\") { it(\"timeout after 750ms\").config(timeout = 750.milliseconds, invocationTimeout = 250.milliseconds) { } } }) Spec Level Timeouts Timeouts can be specified at the spec level for every test in that spec, unless overriden by the test case itself. class TimeoutTest : DescribeSpec({ timeout = 1250.milliseconds describe(\"I will timeout in 1250 millis\") { it(\"And so will I\") { } it(\"But I'm a little faster\").config(timeout = 500.milliseconds) { } } }) Global Timeouts We can set global config in two ways - via system properties or by project config. System Property To set the global timeout or invocation timeout at the command line, use the system property kotest.framework.timeout and kotest.framework.invocation.timeout with a value in milliseconds. Project Config We can set a global default for both timeout and invocationTimeout inside project config . object ProjectConfig : AbstractProjectConfig { override val timeout = 2.seconds override val invocationTimeout = 1.second } Global config is overriden by spec level and test case level values.","title":"Timeouts"},{"location":"timeout/#timeouts","text":"Tests have two types of timeout that can be applied. The first is the overall time for all invocations of a test. This is just called timeout . The second is per individual run of a test, and this is called invocation timeout . Kotest can be configured to invoke a test multiple times. For example, class TimeoutTest : DescribeSpec({ describe(\"my test context\") { it(\"run me three times\").config(invocations = 3) { // some slow network test that takes 1500 millis } } }) In this case, a timeout of 2000 millis would cause the test to fail, because the total run time would be 4500 millis. Whereas an invocation timeout of 2000 millis would not cause the test to fail, because each individual run is 1500 millis. Info Timeouts include the time taken for nested tests. We can specify the timeout at three levels.","title":"Timeouts"},{"location":"timeout/#test-level-timeouts","text":"The most finely grained location for timeouts it on leaf tests directly. class TimeoutTest : DescribeSpec({ describe(\"my test context\") { it(\"timeout after 750ms\").config(timeout = 750.milliseconds, invocationTimeout = 250.milliseconds) { } } })","title":"Test Level Timeouts"},{"location":"timeout/#spec-level-timeouts","text":"Timeouts can be specified at the spec level for every test in that spec, unless overriden by the test case itself. class TimeoutTest : DescribeSpec({ timeout = 1250.milliseconds describe(\"I will timeout in 1250 millis\") { it(\"And so will I\") { } it(\"But I'm a little faster\").config(timeout = 500.milliseconds) { } } })","title":"Spec Level Timeouts"},{"location":"timeout/#global-timeouts","text":"We can set global config in two ways - via system properties or by project config.","title":"Global Timeouts"},{"location":"timeout/#system-property","text":"To set the global timeout or invocation timeout at the command line, use the system property kotest.framework.timeout and kotest.framework.invocation.timeout with a value in milliseconds.","title":"System Property"},{"location":"timeout/#project-config","text":"We can set a global default for both timeout and invocationTimeout inside project config . object ProjectConfig : AbstractProjectConfig { override val timeout = 2.seconds override val invocationTimeout = 1.second } Global config is overriden by spec level and test case level values.","title":"Project Config"},{"location":"blog/release_4.1/","text":"Release 4.1 The Kotest team is pleased to announce the release of Kotest 4.1.0. This minor feature release is packed with goodies including the first public release of the Intellij plugin. In this blog post we'll cover some of the more notable features and changes but for the full list see the changelog . Kotest Plugin Let's start with the most exciting news. As part of the 4.1.0 release cycle, we've released the first public version of the Kotest plugin for Intellij . The plugin is available in the Jetbrains plugin repository, so hop on over to settings -> plugins and search for \"kotest\". As this is the first release that will be used by the majority of users, bugs will likely be found. If you do encounter an issue, please open a ticket here . The plugin provides gutter run icons for specs, top level tests, and nested tests. The plugin additionally provides a tool window view which displays the structure of your tests. The window describes the currently selected test file, which includes any specs defined in that file and tests contained inside those specs. The tree layout will mirror the structure of your tests for easy navigation. The tool window will include lifecycle callback methods (such as before / after test) if defined, as well as included test factories. Clicking on a spec, test, include or callback will navigate directly to that element in the source editor. For full details on the features provided by the plugin, check out the readme . Note: In order to support this plugin, the behind the scenes code that fooled Intellij into thinking Kotest specs were Junit tests has been removed. This means that unless you have the plugin installed, you won't see the green play icon anymore on the class name. Kotlintest aliases removed With release 4.0 of Kotest, the project was renamed from Kotlintest. To aid migration, we created aliases from the kotlintest packages to the kotest packages for common imports. With the release of 4.1 these aliases have been removed. Highlight diff when comparing data classes When comparing two data classes for equality, previously you had to look through the fields to see which one(s) didn't match up. Instead now, the failure output will highlight the differences for you. For example, given the following data class: data class Foo(val a: String, val b: Boolean, val c: Double) And then executing this: val a = Foo(\"hello\", true, 1.0) val b = Foo(\"world\", true, 1.3) a shouldBe b Will give the following output: data class diff for Foo Expected :Foo(a=world, b=true, c=1.3) Actual :Foo(a=hello, b=true, c=1.0) <Click to see difference> org.opentest4j.AssertionFailedError: data class diff for Foo \u251c a: expected:<\"world\"> but was:<\"hello\"> \u2514 c: expected:<1.3> but was:<1.0> Integration with Testcontainers Test containers is a popular Java library that supports lightweight, throwaway instances of databases, message queues, elasticsearch and so on. And now Kotest has a module that allows easy integration into the test lifecylce. Add the kotest-extensions-testcontainers module to your build and then you can register a test container like this: val testStartable = SomeTestContainer() listeners(testStartable.perTest()) Notice the .perTest() function which creates a listener that will stop and start the container between tests. If you want a container that only starts and stops once per spec, then use the following: val testStartable = SomeTestContainer() listeners(testStartable.perSpec()) 'x' variants for Specs The popular javascript frameworks and RSpec in Ruby have popularized the describe / it layout style for tests. Kotest has supported this since version 1.0 in the form of the DescribeSpec. These other frameworks also provide an easy way to disable a test, by replacing describe with xdescribe and it with xit . Kotest also supports this. Starting with 4.1 Kotest now rolled out the same functionality to the other styles. For example, you can disable a given block in BehaviorSpec by using xgiven , you can describe a context block in FunSpec with xcontext and so on. A full example in the FunSpec style. class MyFunSpec : FunSpec({ xtest(\"a disabled test\") { // this test will not be invoked } xcontext(\"this context is disabled\") { test(\"and so this test is by extension\") { } } }) See full details on the styles page . Removing test prefixes from test output Following on from the previous section, when you use certain specs, the test names are prefixed with Describe: , or Feature: and so on in the output. This adds extra noise to the output and in retrospect should not have been added. Starting with 4.1 you can now disable these test prefixes by setting includeTestScopePrefixes to false in your project config . Note: In 4.2.0 this setting will be true by default. Invocation level timeouts Kotest has the option to apply a timeout to your tests through config on the test case. test(\"some test\").config(timeout = 3000.milliseconds) { } This timeout applies to all invocations of that test case. So if you have invocations set greater than 1, then the timeout is shared between all invocations. Starting with 4.1 you can now apply a timeout at the invocation level. test(\"some test\").config(timeout = 3000.milliseconds, invocationTimeout = 250.milliseconds, invocations = 10) { } Parallel test execution Kotest has for a long time, had the ability to run specs in parallel. Starting with 4.1 you can run individual test cases in parallel. Override the threads val inside your spec class to greater than 1. Note: This feature is experimental and only applies to the single instance isolation mode. All scopes are now coroutine scopes Leaf test cases have always been coroutine scopes since release 3.2 of Ko(tlin)Test. This means you can launch a coroutine directly in the test block without needing to provide a scope like GlobalScope or your own instance of CoroutineScope . test(\"some test\") { launch { delay(100) } } Previously, parent scopes in test styles that allow nesting, were not themselves coroutine scopes. This has been changed in 4.1. Now you can write a test like this: describe(\"some test\") { launch { delay(100) it(\"should do something\") { launch { delay(100) } } } } Make beforeProject and afterProject as suspend function Another feature that was more an oversight than anything else - the beforeProject and afterProject callbacks inside ProjectListener are now suspendable functions. Assert softly with receiver You might already be using assertSoftly to allow a test to finish before throwing all the failures at once. Now you can do the same but with a receiver. For example, rather than write val person = ... assertSoftly { person.name shouldBe \"sam\" person.age shouldBe 99 person.city shouldBe \"Chicago\" } You can now do: val person = ... person.assertSoftly { name shouldBe \"sam\" age shouldBe 99 city shouldBe \"Chicago\" } Better shrink information If you're using the property test framework you'll notice the improved shrinking output. This now includes both the reason for the original failure (with the original args) and the reason for the shrunk failure (with the shrunks args). For example, given a silly test that checks that any string reversed is the same as the input string: checkAll<String> { a -> a shouldBe a.reversed() } This will be true for the empty string and all single char strings, and then false for most other strings. Property test failed for inputs 0) \"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\" Caused by org.opentest4j.AssertionFailedError: expected:<\"63YthezR[QyeMg37Fn1PfawUb%&Olz$Ooqc07V3$`?qp;yBX?:s!\"> but was:<\"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\"> at com.sksamuel.kotest.property.ForAll2Test$1$1$1.invokeSuspend(ForAll2Test.kt:19) com.sksamuel.kotest.property.ForAll2Test$1$1$1.invoke(ForAll2Test.kt) io.kotest.property.internal.ProptestKt$proptest$$inlined$forEach$lambda$1.invokeSuspend(proptest.kt:28) io.kotest.property.internal.ProptestKt$proptest$$inlined$forEach$lambda$1.invoke(proptest.kt) Attempting to shrink arg \"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\" Shrink #1: \"!s:?XBy;pq?`$3V70cqoO$zlO&\" fail Shrink #2: \"!s:?XBy;pq?`$\" fail Shrink #3: \"!s:?XBy\" fail Shrink #4: \"!s:?\" fail Shrink #5: \"!s\" fail Shrink #6: \"!\" pass Shrink #7: \"as\" fail Shrink #8: \"a\" pass Shrink #9: \"s\" pass Shrink #10: \"aa\" pass Shrink result (after 10 shrinks) => \"as\" Caused by org.opentest4j.AssertionFailedError: expected:<\"sa\"> but was:<\"as\"> at com.sksamuel.kotest.property.ForAll2Test$1$1$1.invokeSuspend(ForAll2Test.kt:19) com.sksamuel.kotest.property.ForAll2Test$1$1$1.invoke(ForAll2Test.kt) io.kotest.property.internal.ShrinkfnsKt$shrinkfn$1$invokeSuspend$$inlined$with$lambda$1.invokeSuspend(shrinkfns.kt:19) io.kotest.property.internal.ShrinkfnsKt$shrinkfn$1$invokeSuspend$$inlined$with$lambda$1.invoke(shrinkfns.kt) Property Test Listeners The forAll and checkAll property test functions accept a PropTestConfig object to configure a property test. This object now contains a listeners field, to which you can attach PropTestListener instances. This allows you to run setup / teardown code before and after a property test, like you can for regular tests. For example. val listener = object : PropTestListener { override suspend fun beforeTest() { println(\"Startup\") } override suspend fun afterTest() { println(\"Shutdown\") } } val propConfig = PropTestConfig(listeners = listOf(listener)) checkAll<String, String>(10, propConfig) { a, b -> a.length + b.length shouldBe (a + b).length } Thanks Huge thanks to all who contributed to this release. AJ Alt, Albert Attard, Amy, Ashish Kumar Joy, ataronet, Attila Domokos, bbaldino, bright_spark, Caroline Ribeiro, Christian Nedreg\u00e5rd, crazyk2, George Wilkins, Harry JinHyeok Kang, James Pittendreigh, Leonardo Colman Lopes, Lyall Jonathan Di Trapani, Martin Nonnenmacher, Maxime Suret, mwfpope, Nikita Klimenko, Nimamoh, Octogonapus, Paul, Robert Macaulay, Robert Stoll, Ron Gebauer, Sebastian Schuberth, Sergei Bulgakov, sharmabhawna, sksamuel, Steffen Rehberg","title":"Release 4.1"},{"location":"blog/release_4.1/#release-41","text":"The Kotest team is pleased to announce the release of Kotest 4.1.0. This minor feature release is packed with goodies including the first public release of the Intellij plugin. In this blog post we'll cover some of the more notable features and changes but for the full list see the changelog .","title":"Release 4.1"},{"location":"blog/release_4.1/#kotest-plugin","text":"Let's start with the most exciting news. As part of the 4.1.0 release cycle, we've released the first public version of the Kotest plugin for Intellij . The plugin is available in the Jetbrains plugin repository, so hop on over to settings -> plugins and search for \"kotest\". As this is the first release that will be used by the majority of users, bugs will likely be found. If you do encounter an issue, please open a ticket here . The plugin provides gutter run icons for specs, top level tests, and nested tests. The plugin additionally provides a tool window view which displays the structure of your tests. The window describes the currently selected test file, which includes any specs defined in that file and tests contained inside those specs. The tree layout will mirror the structure of your tests for easy navigation. The tool window will include lifecycle callback methods (such as before / after test) if defined, as well as included test factories. Clicking on a spec, test, include or callback will navigate directly to that element in the source editor. For full details on the features provided by the plugin, check out the readme . Note: In order to support this plugin, the behind the scenes code that fooled Intellij into thinking Kotest specs were Junit tests has been removed. This means that unless you have the plugin installed, you won't see the green play icon anymore on the class name.","title":"Kotest Plugin"},{"location":"blog/release_4.1/#kotlintest-aliases-removed","text":"With release 4.0 of Kotest, the project was renamed from Kotlintest. To aid migration, we created aliases from the kotlintest packages to the kotest packages for common imports. With the release of 4.1 these aliases have been removed.","title":"Kotlintest aliases removed"},{"location":"blog/release_4.1/#highlight-diff-when-comparing-data-classes","text":"When comparing two data classes for equality, previously you had to look through the fields to see which one(s) didn't match up. Instead now, the failure output will highlight the differences for you. For example, given the following data class: data class Foo(val a: String, val b: Boolean, val c: Double) And then executing this: val a = Foo(\"hello\", true, 1.0) val b = Foo(\"world\", true, 1.3) a shouldBe b Will give the following output: data class diff for Foo Expected :Foo(a=world, b=true, c=1.3) Actual :Foo(a=hello, b=true, c=1.0) <Click to see difference> org.opentest4j.AssertionFailedError: data class diff for Foo \u251c a: expected:<\"world\"> but was:<\"hello\"> \u2514 c: expected:<1.3> but was:<1.0>","title":"Highlight diff when comparing data classes"},{"location":"blog/release_4.1/#integration-with-testcontainers","text":"Test containers is a popular Java library that supports lightweight, throwaway instances of databases, message queues, elasticsearch and so on. And now Kotest has a module that allows easy integration into the test lifecylce. Add the kotest-extensions-testcontainers module to your build and then you can register a test container like this: val testStartable = SomeTestContainer() listeners(testStartable.perTest()) Notice the .perTest() function which creates a listener that will stop and start the container between tests. If you want a container that only starts and stops once per spec, then use the following: val testStartable = SomeTestContainer() listeners(testStartable.perSpec())","title":"Integration with Testcontainers"},{"location":"blog/release_4.1/#x-variants-for-specs","text":"The popular javascript frameworks and RSpec in Ruby have popularized the describe / it layout style for tests. Kotest has supported this since version 1.0 in the form of the DescribeSpec. These other frameworks also provide an easy way to disable a test, by replacing describe with xdescribe and it with xit . Kotest also supports this. Starting with 4.1 Kotest now rolled out the same functionality to the other styles. For example, you can disable a given block in BehaviorSpec by using xgiven , you can describe a context block in FunSpec with xcontext and so on. A full example in the FunSpec style. class MyFunSpec : FunSpec({ xtest(\"a disabled test\") { // this test will not be invoked } xcontext(\"this context is disabled\") { test(\"and so this test is by extension\") { } } }) See full details on the styles page .","title":"'x' variants for Specs"},{"location":"blog/release_4.1/#removing-test-prefixes-from-test-output","text":"Following on from the previous section, when you use certain specs, the test names are prefixed with Describe: , or Feature: and so on in the output. This adds extra noise to the output and in retrospect should not have been added. Starting with 4.1 you can now disable these test prefixes by setting includeTestScopePrefixes to false in your project config . Note: In 4.2.0 this setting will be true by default.","title":"Removing test prefixes from test output"},{"location":"blog/release_4.1/#invocation-level-timeouts","text":"Kotest has the option to apply a timeout to your tests through config on the test case. test(\"some test\").config(timeout = 3000.milliseconds) { } This timeout applies to all invocations of that test case. So if you have invocations set greater than 1, then the timeout is shared between all invocations. Starting with 4.1 you can now apply a timeout at the invocation level. test(\"some test\").config(timeout = 3000.milliseconds, invocationTimeout = 250.milliseconds, invocations = 10) { }","title":"Invocation level timeouts"},{"location":"blog/release_4.1/#parallel-test-execution","text":"Kotest has for a long time, had the ability to run specs in parallel. Starting with 4.1 you can run individual test cases in parallel. Override the threads val inside your spec class to greater than 1. Note: This feature is experimental and only applies to the single instance isolation mode.","title":"Parallel test execution"},{"location":"blog/release_4.1/#all-scopes-are-now-coroutine-scopes","text":"Leaf test cases have always been coroutine scopes since release 3.2 of Ko(tlin)Test. This means you can launch a coroutine directly in the test block without needing to provide a scope like GlobalScope or your own instance of CoroutineScope . test(\"some test\") { launch { delay(100) } } Previously, parent scopes in test styles that allow nesting, were not themselves coroutine scopes. This has been changed in 4.1. Now you can write a test like this: describe(\"some test\") { launch { delay(100) it(\"should do something\") { launch { delay(100) } } } }","title":"All scopes are now coroutine scopes"},{"location":"blog/release_4.1/#make-beforeproject-and-afterproject-as-suspend-function","text":"Another feature that was more an oversight than anything else - the beforeProject and afterProject callbacks inside ProjectListener are now suspendable functions.","title":"Make beforeProject and afterProject as suspend function"},{"location":"blog/release_4.1/#assert-softly-with-receiver","text":"You might already be using assertSoftly to allow a test to finish before throwing all the failures at once. Now you can do the same but with a receiver. For example, rather than write val person = ... assertSoftly { person.name shouldBe \"sam\" person.age shouldBe 99 person.city shouldBe \"Chicago\" } You can now do: val person = ... person.assertSoftly { name shouldBe \"sam\" age shouldBe 99 city shouldBe \"Chicago\" }","title":"Assert softly with receiver"},{"location":"blog/release_4.1/#better-shrink-information","text":"If you're using the property test framework you'll notice the improved shrinking output. This now includes both the reason for the original failure (with the original args) and the reason for the shrunk failure (with the shrunks args). For example, given a silly test that checks that any string reversed is the same as the input string: checkAll<String> { a -> a shouldBe a.reversed() } This will be true for the empty string and all single char strings, and then false for most other strings. Property test failed for inputs 0) \"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\" Caused by org.opentest4j.AssertionFailedError: expected:<\"63YthezR[QyeMg37Fn1PfawUb%&Olz$Ooqc07V3$`?qp;yBX?:s!\"> but was:<\"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\"> at com.sksamuel.kotest.property.ForAll2Test$1$1$1.invokeSuspend(ForAll2Test.kt:19) com.sksamuel.kotest.property.ForAll2Test$1$1$1.invoke(ForAll2Test.kt) io.kotest.property.internal.ProptestKt$proptest$$inlined$forEach$lambda$1.invokeSuspend(proptest.kt:28) io.kotest.property.internal.ProptestKt$proptest$$inlined$forEach$lambda$1.invoke(proptest.kt) Attempting to shrink arg \"!s:?XBy;pq?`$3V70cqoO$zlO&%bUwafP1nF73gMeyQ[RzehtY36\" Shrink #1: \"!s:?XBy;pq?`$3V70cqoO$zlO&\" fail Shrink #2: \"!s:?XBy;pq?`$\" fail Shrink #3: \"!s:?XBy\" fail Shrink #4: \"!s:?\" fail Shrink #5: \"!s\" fail Shrink #6: \"!\" pass Shrink #7: \"as\" fail Shrink #8: \"a\" pass Shrink #9: \"s\" pass Shrink #10: \"aa\" pass Shrink result (after 10 shrinks) => \"as\" Caused by org.opentest4j.AssertionFailedError: expected:<\"sa\"> but was:<\"as\"> at com.sksamuel.kotest.property.ForAll2Test$1$1$1.invokeSuspend(ForAll2Test.kt:19) com.sksamuel.kotest.property.ForAll2Test$1$1$1.invoke(ForAll2Test.kt) io.kotest.property.internal.ShrinkfnsKt$shrinkfn$1$invokeSuspend$$inlined$with$lambda$1.invokeSuspend(shrinkfns.kt:19) io.kotest.property.internal.ShrinkfnsKt$shrinkfn$1$invokeSuspend$$inlined$with$lambda$1.invoke(shrinkfns.kt)","title":"Better shrink information"},{"location":"blog/release_4.1/#property-test-listeners","text":"The forAll and checkAll property test functions accept a PropTestConfig object to configure a property test. This object now contains a listeners field, to which you can attach PropTestListener instances. This allows you to run setup / teardown code before and after a property test, like you can for regular tests. For example. val listener = object : PropTestListener { override suspend fun beforeTest() { println(\"Startup\") } override suspend fun afterTest() { println(\"Shutdown\") } } val propConfig = PropTestConfig(listeners = listOf(listener)) checkAll<String, String>(10, propConfig) { a, b -> a.length + b.length shouldBe (a + b).length }","title":"Property Test Listeners"},{"location":"blog/release_4.1/#thanks","text":"Huge thanks to all who contributed to this release. AJ Alt, Albert Attard, Amy, Ashish Kumar Joy, ataronet, Attila Domokos, bbaldino, bright_spark, Caroline Ribeiro, Christian Nedreg\u00e5rd, crazyk2, George Wilkins, Harry JinHyeok Kang, James Pittendreigh, Leonardo Colman Lopes, Lyall Jonathan Di Trapani, Martin Nonnenmacher, Maxime Suret, mwfpope, Nikita Klimenko, Nimamoh, Octogonapus, Paul, Robert Macaulay, Robert Stoll, Ron Gebauer, Sebastian Schuberth, Sergei Bulgakov, sharmabhawna, sksamuel, Steffen Rehberg","title":"Thanks"},{"location":"blog/release_4.2/","text":"Release 4.2 The Kotest team is pleased to announce the release of Kotest 4.2.0. This minor feature release continues on the excellent work that was included in the 4.1.0 release (which itself was almost as large as the 4.0.0 release!). In this blog post we'll cover some of the more notable features and changes but for the full list see the changelog . Module changes Firstly, the kotest-runner-console dependency is no longer required by the intellij plugin, and therefore no longer exists. So that can be removed completely from your build if you were using it. Secondly, the kotest-core dependency has become kotest-framework-engine . If you are using JVM tests, you should continue to use the kotest-runner-junit5-jvm dependency as before, and no changes are needed. If you were explicitly depending on the core module (for JS tests), then you can add kotest-framework-engine to your commonMain sourceset or kotest-framework-engine-js to your jsMain sourceset. Finally this release of Kotest is fully compatible with Kotlin 1.4. Multiplatform improvements The core assertions library is now published for ios, watchos and tvos. This brings the list of support platforms to: linuxX64, mingwX64, macosX64, tvosX64, tvosArm64, watchosX86, watchosArm64, iosX64, iosArm64, iosArm32 Kotlinx Date/Time Matchers A new assertions module has been created kotest-assertions-kotlinx-time which contains matchers for the new Kotlinx Datetime library . Since the datetime library has an incubating status, this assertions module may require breaking changes in the future if the date/time API mandates it. This assertions module is multi platform and is released for the JVM, JS, Linux, Mac and Windows targets. An example assertion is checking that a date time has a given hour. val date = LocalDateTime(2019, 2, 15, 12, 10, 0, 0) date.shouldHaveHour(12) For the full list of matchers, see the source code . Multiple Project Configs Kotest supports customizing test plans by extending the AbstractProjectConfig class and placing it in your classpath somewhere. From 4.2.0, you can now create more than one and all will be detected and configs merged. This is really nice if you want to have some shared config for all your tests in a root module, and then customize with more finer details per module. In the case of clashes, one value will be arbitrarily picked, so it is not recommended to add competing settings to different configs. Extended Callbacks Kotest has always had beforeTest / afterTest callbacks which run before / after any 'test scope'. However sometimes you need a way to run setup/teardown code only before leaf test scopes (called tests in Kotest) or branch test scopes (called containers in Kotest). So in 4.2.0 we've introduced beforeEach , afterEach , beforeContainer , and afterContainer . The xxEach functions are invoked only for leaf level test scopes. The xxContainer functions are invoked only for branch level test scopes. This distinction is only relevant to test styles that support nested scopes. For example: class CallbacksTest : DescribeSpec({ beforeEach { println(\"Test: \" + it.displayName) } beforeContainer { println(\"Container: \" + it.displayName) } beforeTest { println(\"All: \" + it.displayName) } describe(\"I am a container scope\") { it(\"And I am a test scope\") { } } }) The output you would receive is: Container: I am a container scope All: I am a container scope Test: And I am a test scope All: And I am a test scope Spec Ordering Kotest previously allowed the execution order of Specs to be decided randomly, discovery order (the default), or lexicographically. Now, there is support for an annotation based approach. By selecting this, and annotating your Specs with @Order(int) you can specify any order you wish, with the specs with the lowest int values executing first. Any spec without an @Order annotation is considered \"last\". Any specs that tie will be executed arbitrarily. Tag Expressions Tests and Specs can be tagged with Tag objects and then at runtime, tests can be enabled or disabled by specifying which tags to use. Previously, you could do this by specifying which tags to include and which tags to exclude but nothing more advanced. Now, you are able to specfify full boolean expressions using the kotest.tags system property, for example: gradle test -Dkotest.tags=\"Linux & !Database\" . Expressions can be nested using parenthesis and can be arbitrarily complex. For full details see Tags . Note: Existing system properties kotest.tags.include and kotest.tags.exclude are still supported, but the new functionality supersedes this. Spec level Timeout Overrides It has always been possible to add a timeout to a test at the global level or via test case config for each specific test: test(\"my test\").config(timeout = 20.seconds) { } But it has not previously been possible to override this as the spec level for all tests in that spec. Now you can. class TimeoutTest : DescribeSpec({ timeout = 1000 describe(\"I will timeout in 1000 millis\") { it(\"And so will I\") { } it(\"But I'm a little faster\").config(timeout = 500.milliseconds) { } } }) Note: You can apply a spec level timeout and then override this per test case, as you can see in the example above. The same functionality exists for invocation timeouts. Exhaustive Specific forAll / checkAll When property testing, if you are using only exhaustive generators, then the forAll / checkAll methods will now ensure that the number of iterations is equal to the number of combinations in the exhaustives, and that all combinations are executed. As a contrived example, consider this: val context = checkAll( Exhaustive.ints(0..5), Exhaustive.ints(0..5), Exhaustive.ints(0..5) ) { ... } Here, the number of iterations is 6 * 6 * 6 = 216 and each tuple combination of (0-5, 0-5, 0-5) will be executed. The first will be (0, 0, 0) and the last wil be (5, 5, 5) with every combination in between. Generic Contracts in Matchers When using shouldBeInstanceOf or shouldBeTypeOf , the assertions can now use generic contracts to smart case down to generic instances. For example, consider the following example where we are given an Any. After invoking shouldBeTypeOf with a generic type, the type is smart casted if the assertion passes. val list: Any = arrayListOf(1, 2, 3) list.shouldBeTypeOf<ArrayList<Int>>() list[0] shouldBe 1 // can only work with a smart case Kotest Plugin Updates The Kotest Intellij Plugin is released on a separate cadence from Kotest itself, but here are some notable changes since Kotest 4.1.0. No extra dependencies are needed to use the plugin - the plugin ships with all required libraries. The new extended callbacks are recognized in the Kotest tool window. Runnning single tests is now supported in AnnotationSpec . Seperate builds for Android Studio / Intellij 2019 to address some minor incompatibilities. Added inspection for using focus mode in nested tests Added implicit usage provider for object based project config Improved JUnit XML Report The Junit XML report (what JUnit refers to as the legacy XML report because it existed prior to JUnit5) has no concept of nested tests. Therefore, if you are using a spec style that supports nested tests, the gradle report generator will only use the leaf test name. This can be confusing if you are expecting the full test path for context. In 4.2.0 Kotest has it's own implementation of this XML report that contains options to a) include the full test path and / or b) ignore parent tests completely. Example usage from within project config: class ProjectConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf( JunitXmlReporter( includeContainers = true, // write out status for all tests useTestPathAsName = true // use the full test path (ie, includes parent test names) ) ) } Spring Listener Warning If you are using the spring support and are using a final class, you will receive a warning from Kotest: Using SpringListener on a final class. If any Spring annotation fails to work, try making this class open You can disable this warning by setting the system property kotest.listener.spring.ignore.warning to true. Thanks Huge thanks to all who contributed to this release. Alberto Ballano, Ali Albaali, amollberg, Ashish Kumar Joy, Christian Stoenescu, Cleidiano Oliveira ,Daniel Asztalos, fauscik, Juanjo Aguililla, Justin, Leonardo Colman, Matthew Mikolay, Neenad Ingole, Shane Lathrop, sksamuel, Timothy Lusk","title":"Release 4.2"},{"location":"blog/release_4.2/#release-42","text":"The Kotest team is pleased to announce the release of Kotest 4.2.0. This minor feature release continues on the excellent work that was included in the 4.1.0 release (which itself was almost as large as the 4.0.0 release!). In this blog post we'll cover some of the more notable features and changes but for the full list see the changelog .","title":"Release 4.2"},{"location":"blog/release_4.2/#module-changes","text":"Firstly, the kotest-runner-console dependency is no longer required by the intellij plugin, and therefore no longer exists. So that can be removed completely from your build if you were using it. Secondly, the kotest-core dependency has become kotest-framework-engine . If you are using JVM tests, you should continue to use the kotest-runner-junit5-jvm dependency as before, and no changes are needed. If you were explicitly depending on the core module (for JS tests), then you can add kotest-framework-engine to your commonMain sourceset or kotest-framework-engine-js to your jsMain sourceset. Finally this release of Kotest is fully compatible with Kotlin 1.4.","title":"Module changes"},{"location":"blog/release_4.2/#multiplatform-improvements","text":"The core assertions library is now published for ios, watchos and tvos. This brings the list of support platforms to: linuxX64, mingwX64, macosX64, tvosX64, tvosArm64, watchosX86, watchosArm64, iosX64, iosArm64, iosArm32","title":"Multiplatform improvements"},{"location":"blog/release_4.2/#kotlinx-datetime-matchers","text":"A new assertions module has been created kotest-assertions-kotlinx-time which contains matchers for the new Kotlinx Datetime library . Since the datetime library has an incubating status, this assertions module may require breaking changes in the future if the date/time API mandates it. This assertions module is multi platform and is released for the JVM, JS, Linux, Mac and Windows targets. An example assertion is checking that a date time has a given hour. val date = LocalDateTime(2019, 2, 15, 12, 10, 0, 0) date.shouldHaveHour(12) For the full list of matchers, see the source code .","title":"Kotlinx Date/Time Matchers"},{"location":"blog/release_4.2/#multiple-project-configs","text":"Kotest supports customizing test plans by extending the AbstractProjectConfig class and placing it in your classpath somewhere. From 4.2.0, you can now create more than one and all will be detected and configs merged. This is really nice if you want to have some shared config for all your tests in a root module, and then customize with more finer details per module. In the case of clashes, one value will be arbitrarily picked, so it is not recommended to add competing settings to different configs.","title":"Multiple Project Configs"},{"location":"blog/release_4.2/#extended-callbacks","text":"Kotest has always had beforeTest / afterTest callbacks which run before / after any 'test scope'. However sometimes you need a way to run setup/teardown code only before leaf test scopes (called tests in Kotest) or branch test scopes (called containers in Kotest). So in 4.2.0 we've introduced beforeEach , afterEach , beforeContainer , and afterContainer . The xxEach functions are invoked only for leaf level test scopes. The xxContainer functions are invoked only for branch level test scopes. This distinction is only relevant to test styles that support nested scopes. For example: class CallbacksTest : DescribeSpec({ beforeEach { println(\"Test: \" + it.displayName) } beforeContainer { println(\"Container: \" + it.displayName) } beforeTest { println(\"All: \" + it.displayName) } describe(\"I am a container scope\") { it(\"And I am a test scope\") { } } }) The output you would receive is: Container: I am a container scope All: I am a container scope Test: And I am a test scope All: And I am a test scope","title":"Extended Callbacks"},{"location":"blog/release_4.2/#spec-ordering","text":"Kotest previously allowed the execution order of Specs to be decided randomly, discovery order (the default), or lexicographically. Now, there is support for an annotation based approach. By selecting this, and annotating your Specs with @Order(int) you can specify any order you wish, with the specs with the lowest int values executing first. Any spec without an @Order annotation is considered \"last\". Any specs that tie will be executed arbitrarily.","title":"Spec Ordering"},{"location":"blog/release_4.2/#tag-expressions","text":"Tests and Specs can be tagged with Tag objects and then at runtime, tests can be enabled or disabled by specifying which tags to use. Previously, you could do this by specifying which tags to include and which tags to exclude but nothing more advanced. Now, you are able to specfify full boolean expressions using the kotest.tags system property, for example: gradle test -Dkotest.tags=\"Linux & !Database\" . Expressions can be nested using parenthesis and can be arbitrarily complex. For full details see Tags . Note: Existing system properties kotest.tags.include and kotest.tags.exclude are still supported, but the new functionality supersedes this.","title":"Tag Expressions"},{"location":"blog/release_4.2/#spec-level-timeout-overrides","text":"It has always been possible to add a timeout to a test at the global level or via test case config for each specific test: test(\"my test\").config(timeout = 20.seconds) { } But it has not previously been possible to override this as the spec level for all tests in that spec. Now you can. class TimeoutTest : DescribeSpec({ timeout = 1000 describe(\"I will timeout in 1000 millis\") { it(\"And so will I\") { } it(\"But I'm a little faster\").config(timeout = 500.milliseconds) { } } }) Note: You can apply a spec level timeout and then override this per test case, as you can see in the example above. The same functionality exists for invocation timeouts.","title":"Spec level Timeout Overrides"},{"location":"blog/release_4.2/#exhaustive-specific-forall-checkall","text":"When property testing, if you are using only exhaustive generators, then the forAll / checkAll methods will now ensure that the number of iterations is equal to the number of combinations in the exhaustives, and that all combinations are executed. As a contrived example, consider this: val context = checkAll( Exhaustive.ints(0..5), Exhaustive.ints(0..5), Exhaustive.ints(0..5) ) { ... } Here, the number of iterations is 6 * 6 * 6 = 216 and each tuple combination of (0-5, 0-5, 0-5) will be executed. The first will be (0, 0, 0) and the last wil be (5, 5, 5) with every combination in between.","title":"Exhaustive Specific forAll / checkAll"},{"location":"blog/release_4.2/#generic-contracts-in-matchers","text":"When using shouldBeInstanceOf or shouldBeTypeOf , the assertions can now use generic contracts to smart case down to generic instances. For example, consider the following example where we are given an Any. After invoking shouldBeTypeOf with a generic type, the type is smart casted if the assertion passes. val list: Any = arrayListOf(1, 2, 3) list.shouldBeTypeOf<ArrayList<Int>>() list[0] shouldBe 1 // can only work with a smart case","title":"Generic Contracts in Matchers"},{"location":"blog/release_4.2/#kotest-plugin-updates","text":"The Kotest Intellij Plugin is released on a separate cadence from Kotest itself, but here are some notable changes since Kotest 4.1.0. No extra dependencies are needed to use the plugin - the plugin ships with all required libraries. The new extended callbacks are recognized in the Kotest tool window. Runnning single tests is now supported in AnnotationSpec . Seperate builds for Android Studio / Intellij 2019 to address some minor incompatibilities. Added inspection for using focus mode in nested tests Added implicit usage provider for object based project config","title":"Kotest Plugin Updates"},{"location":"blog/release_4.2/#improved-junit-xml-report","text":"The Junit XML report (what JUnit refers to as the legacy XML report because it existed prior to JUnit5) has no concept of nested tests. Therefore, if you are using a spec style that supports nested tests, the gradle report generator will only use the leaf test name. This can be confusing if you are expecting the full test path for context. In 4.2.0 Kotest has it's own implementation of this XML report that contains options to a) include the full test path and / or b) ignore parent tests completely. Example usage from within project config: class ProjectConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf( JunitXmlReporter( includeContainers = true, // write out status for all tests useTestPathAsName = true // use the full test path (ie, includes parent test names) ) ) }","title":"Improved JUnit XML Report"},{"location":"blog/release_4.2/#spring-listener-warning","text":"If you are using the spring support and are using a final class, you will receive a warning from Kotest: Using SpringListener on a final class. If any Spring annotation fails to work, try making this class open You can disable this warning by setting the system property kotest.listener.spring.ignore.warning to true.","title":"Spring Listener Warning"},{"location":"blog/release_4.2/#thanks","text":"Huge thanks to all who contributed to this release. Alberto Ballano, Ali Albaali, amollberg, Ashish Kumar Joy, Christian Stoenescu, Cleidiano Oliveira ,Daniel Asztalos, fauscik, Juanjo Aguililla, Justin, Leonardo Colman, Matthew Mikolay, Neenad Ingole, Shane Lathrop, sksamuel, Timothy Lusk","title":"Thanks"},{"location":"blog/release_4.3/","text":"Release 4.3.0 The Kotest team is pleased to announce the release of Kotest 4.3.0. This blog covers some of the new features added in this release. For the full list, see the changelog . New and improved data driven testing Kotest has improved its data driven testing support, directly integrating into the framework. This means it will now automatically generate individual test case entries. As an example, lets test a function that returns true if the input values are valid pythagorean triples . fun isPythagTriple(a: Int, b: Int, c: Int): Boolean = a * a + b * b == c * c We start by writing a data class that will hold each row - a set of inputs. data class PythagTriple(val a: Int, val b: Int, val c: Int) Next we invoke the function forAll inside a test case, passing in one or more of these data classes, and a lambda that performs some test logic for a given row . context(\"Pythag triples tests\") { forAll( PythagTriple(3, 4, 5), PythagTriple(6, 8, 10), PythagTriple(8, 15, 17), PythagTriple(7, 24, 25) ) { (a, b, c) -> isPythagTriple(a, b, c) shouldBe true } } Kotest will automatically generate a test case for each input row, as if you had manually written a seperate test case for each. For full documentation click here . EnabledIf annotation on specs It can be useful to avoid instantiating a spec entirely, and often we can do that via test tags. But if you want to do this with some bespoke code, then the annotation EnabledIf has been added. Annotate a spec with EnabledIf , passing in a class that extends from EnabledCondition and that condition will be invoked at runtime to determine if the spec should be instantiated. The EnabledCondition implementation must have a zero arg constructor. For example, lets make a condition that only executes a test if it is midnight. class EnabledIfMidnight : EnabledCondition { override fun enabled(specKlass: KClass<out Spec>): Boolean = LocalTime.now().hour == 0 } And then attach that to a spec: @EnabledIf(EnabledIfMidnight::class) class EnabledIfTest : FunSpec() { init { test(\"tis midnight when the witches roam free\") { // test here } } } TestCase severity Test case can be conditionally executed via test tags, and now also by severity levels. The levels are BLOCKER, CRITICAL, NORMAL, MINOR, and TRIVIAL. We can mark each test case with a severity level: class MyTest : FunSpec() { init { test(\"very very important\").config(severity = TestCaseSeverityLevel.CRITICAL) { // test here } } } Say we only want to execute tests that are CRITICAL or higher, we can execute with the system property kotest.framework.test.severity=CRITICAL This can be useful if we have a huge test suite and want to run some tests first in a seperate test run. By default, all tests are executed. Disabling source references Whenever a test case is created, Kotest creates a stack trace so that it can link back to the test case. The stack trace contains the filename and line number which the Intellij Plugin uses to create links in the test window. It calls these the sourceref . If you have 1000s of tests and are encountering some slowdown when executing the full suite via gradle, you can now disable the generation of these sourcerefs by setting the system property kotest.framework.sourceref.disable=true Generally speaking, this is only of use if you have a huge test suite and mostly aimed at CI builds. Make engine dependency free A test framework is one of the lowest levels of dependences in an ecosystem. As Kotest is used by many Kotlin libraries, a clash can occur if Kotest and your project are using the same dependencies but with different versions. It is beneficial then if Kotest has as few dependencies as possible. To this aim, 4.3.0 has seen the dependencies for the Kotest framework reduced to just Classgraph (to scan for specs), Mordant (for console output), and opentest4j. Matchers return 'this' for easy chaining In the opinion of this author, Kotest has the most comprehensive assertion support for Kotlin. Now they just became more convienient, by allowing you to chain assertions together if you wish. So, instead of val employees: List<Employee> = ... employees.shouldBeSorted() employees.shouldHaveSize(4) employees.shouldContain(Employee(\"Sam\", \"Chicago\")) You can now do val employees: List<Employee> = ... employees.shouldBeSorted() shouldHaveSize(4) shouldContain(Employee(\"Sam\", \"Chicago\")) Of course, this is entirely optional. Property test module for kotlinx datetime Kotest's expansive property test generators now include ones for the incubating kotlinx datetime library. Add the module kotest-property-datetime to your build. These generators are available for JVM and JS. For example: forAll(Arb.datetime(1987..1994)) { date -> isValidStarTrekTngSeason(date) shouldBe true } Option to strip whitespace from test names If you like to define test names over multiple lines, Kotest will now strip out leading, trailing and repeated whitespace from test names. For example, the following spec: class MySpec : StringSpec() { init { \"\"\"this is a test spanning multiple lines\"\"\" { } } } Would normally be output as this is a test spanning multiple lines By setting the configuration object removeTestNameWhitespace to true, this would instead by output as this is a test spanning multiple lines Thanks Huge thanks to all who contributed to this release (includes commits since v4.2.0 tag): AJ Alt, Alex Facciorusso, Ashish Kumar Joy, J Phani Mahesh, Jasper de Vries, Javier Segovia C\u00f3rdoba, Josh Graham, KeremAslan, Leonardo Colman, Micha\u0142 Sikora, Mitchell Yuwono, Neenad Ingole, Rick Busarow, SergKhram, Sergei Khramkov, crazyk2, sksamuel","title":"Release 4.3"},{"location":"blog/release_4.3/#release-430","text":"The Kotest team is pleased to announce the release of Kotest 4.3.0. This blog covers some of the new features added in this release. For the full list, see the changelog .","title":"Release 4.3.0"},{"location":"blog/release_4.3/#new-and-improved-data-driven-testing","text":"Kotest has improved its data driven testing support, directly integrating into the framework. This means it will now automatically generate individual test case entries. As an example, lets test a function that returns true if the input values are valid pythagorean triples . fun isPythagTriple(a: Int, b: Int, c: Int): Boolean = a * a + b * b == c * c We start by writing a data class that will hold each row - a set of inputs. data class PythagTriple(val a: Int, val b: Int, val c: Int) Next we invoke the function forAll inside a test case, passing in one or more of these data classes, and a lambda that performs some test logic for a given row . context(\"Pythag triples tests\") { forAll( PythagTriple(3, 4, 5), PythagTriple(6, 8, 10), PythagTriple(8, 15, 17), PythagTriple(7, 24, 25) ) { (a, b, c) -> isPythagTriple(a, b, c) shouldBe true } } Kotest will automatically generate a test case for each input row, as if you had manually written a seperate test case for each. For full documentation click here .","title":"New and improved data driven testing"},{"location":"blog/release_4.3/#enabledif-annotation-on-specs","text":"It can be useful to avoid instantiating a spec entirely, and often we can do that via test tags. But if you want to do this with some bespoke code, then the annotation EnabledIf has been added. Annotate a spec with EnabledIf , passing in a class that extends from EnabledCondition and that condition will be invoked at runtime to determine if the spec should be instantiated. The EnabledCondition implementation must have a zero arg constructor. For example, lets make a condition that only executes a test if it is midnight. class EnabledIfMidnight : EnabledCondition { override fun enabled(specKlass: KClass<out Spec>): Boolean = LocalTime.now().hour == 0 } And then attach that to a spec: @EnabledIf(EnabledIfMidnight::class) class EnabledIfTest : FunSpec() { init { test(\"tis midnight when the witches roam free\") { // test here } } }","title":"EnabledIf annotation on specs"},{"location":"blog/release_4.3/#testcase-severity","text":"Test case can be conditionally executed via test tags, and now also by severity levels. The levels are BLOCKER, CRITICAL, NORMAL, MINOR, and TRIVIAL. We can mark each test case with a severity level: class MyTest : FunSpec() { init { test(\"very very important\").config(severity = TestCaseSeverityLevel.CRITICAL) { // test here } } } Say we only want to execute tests that are CRITICAL or higher, we can execute with the system property kotest.framework.test.severity=CRITICAL This can be useful if we have a huge test suite and want to run some tests first in a seperate test run. By default, all tests are executed.","title":"TestCase severity"},{"location":"blog/release_4.3/#disabling-source-references","text":"Whenever a test case is created, Kotest creates a stack trace so that it can link back to the test case. The stack trace contains the filename and line number which the Intellij Plugin uses to create links in the test window. It calls these the sourceref . If you have 1000s of tests and are encountering some slowdown when executing the full suite via gradle, you can now disable the generation of these sourcerefs by setting the system property kotest.framework.sourceref.disable=true Generally speaking, this is only of use if you have a huge test suite and mostly aimed at CI builds.","title":"Disabling source references"},{"location":"blog/release_4.3/#make-engine-dependency-free","text":"A test framework is one of the lowest levels of dependences in an ecosystem. As Kotest is used by many Kotlin libraries, a clash can occur if Kotest and your project are using the same dependencies but with different versions. It is beneficial then if Kotest has as few dependencies as possible. To this aim, 4.3.0 has seen the dependencies for the Kotest framework reduced to just Classgraph (to scan for specs), Mordant (for console output), and opentest4j.","title":"Make engine dependency free"},{"location":"blog/release_4.3/#matchers-return-this-for-easy-chaining","text":"In the opinion of this author, Kotest has the most comprehensive assertion support for Kotlin. Now they just became more convienient, by allowing you to chain assertions together if you wish. So, instead of val employees: List<Employee> = ... employees.shouldBeSorted() employees.shouldHaveSize(4) employees.shouldContain(Employee(\"Sam\", \"Chicago\")) You can now do val employees: List<Employee> = ... employees.shouldBeSorted() shouldHaveSize(4) shouldContain(Employee(\"Sam\", \"Chicago\")) Of course, this is entirely optional.","title":"Matchers return 'this' for easy chaining"},{"location":"blog/release_4.3/#property-test-module-for-kotlinx-datetime","text":"Kotest's expansive property test generators now include ones for the incubating kotlinx datetime library. Add the module kotest-property-datetime to your build. These generators are available for JVM and JS. For example: forAll(Arb.datetime(1987..1994)) { date -> isValidStarTrekTngSeason(date) shouldBe true }","title":"Property test module for kotlinx datetime"},{"location":"blog/release_4.3/#option-to-strip-whitespace-from-test-names","text":"If you like to define test names over multiple lines, Kotest will now strip out leading, trailing and repeated whitespace from test names. For example, the following spec: class MySpec : StringSpec() { init { \"\"\"this is a test spanning multiple lines\"\"\" { } } } Would normally be output as this is a test spanning multiple lines By setting the configuration object removeTestNameWhitespace to true, this would instead by output as this is a test spanning multiple lines","title":"Option to strip whitespace from test names"},{"location":"blog/release_4.3/#thanks","text":"Huge thanks to all who contributed to this release (includes commits since v4.2.0 tag): AJ Alt, Alex Facciorusso, Ashish Kumar Joy, J Phani Mahesh, Jasper de Vries, Javier Segovia C\u00f3rdoba, Josh Graham, KeremAslan, Leonardo Colman, Micha\u0142 Sikora, Mitchell Yuwono, Neenad Ingole, Rick Busarow, SergKhram, Sergei Khramkov, crazyk2, sksamuel","title":"Thanks"},{"location":"extensions/allure/","text":"Allure Allure is an open-source framework designed for detailed and interactive test reports. It works by generating report files which are then used to create the final HTML report. You can think of it as like the traditional junit report but more advanced and detailed. There are two steps to allure. The first is to generate the raw data when executing tests, the second is to compile that data into the interactive HTML report. Collect Data Allure has data collectors for most test frameworks, and Kotest is no different. In order to activate allure for kotest, you first need to add the module kotest-extensions-allure to your build. Next, wire in the AllureTestReporter class globally using project config . class MyConfig : AbstractProjectConfig { override fun listeners() = listOf(AllureTestReporter()) } Now, whenever tests are executed, Kotest will write out test data in the allure json format. Gradle Plugin Now that the tests have completed, we can compile them into the final report . This can be done manually using the allure binary, or we can use the allure gradle plugin . To use the gradle plugin, first add the plugin to your build's plugins block. plugins { ... id(\"io.qameta.allure\") version \"2.8.1\" } Next, add an allure configuration section to set the version and disable autoconfigure (because allure can only auto configure junit and kotest takes care of this for you anyway). allure { autoconfigure = false version = \"2.13.1\" } Finally, execute the gradle task allureReport and the report will be generated in ./build/reports/allure-report and inside you should find the index.html entry point for the report. Setting Build Dir If you are not using the gradle plugin then you will need to inform Allure where the build dir is by setting the allure.results.directory system property on your tests configuration. If you are using the gradle plugin, then this can be skipped as the gradle plugin does this for you. For example: tasks.named<Test>(\"test\") { // or \"jvmTest\" etc useJUnitPlatform() systemProperty(\"allure.results.directory\", project.buildDir.toString() + \"/allure-results\") } Final Report If all was successful, after test execution and report generation, you will see something like this:","title":"Allure"},{"location":"extensions/allure/#allure","text":"Allure is an open-source framework designed for detailed and interactive test reports. It works by generating report files which are then used to create the final HTML report. You can think of it as like the traditional junit report but more advanced and detailed. There are two steps to allure. The first is to generate the raw data when executing tests, the second is to compile that data into the interactive HTML report.","title":"Allure"},{"location":"extensions/allure/#collect-data","text":"Allure has data collectors for most test frameworks, and Kotest is no different. In order to activate allure for kotest, you first need to add the module kotest-extensions-allure to your build. Next, wire in the AllureTestReporter class globally using project config . class MyConfig : AbstractProjectConfig { override fun listeners() = listOf(AllureTestReporter()) } Now, whenever tests are executed, Kotest will write out test data in the allure json format.","title":"Collect Data"},{"location":"extensions/allure/#gradle-plugin","text":"Now that the tests have completed, we can compile them into the final report . This can be done manually using the allure binary, or we can use the allure gradle plugin . To use the gradle plugin, first add the plugin to your build's plugins block. plugins { ... id(\"io.qameta.allure\") version \"2.8.1\" } Next, add an allure configuration section to set the version and disable autoconfigure (because allure can only auto configure junit and kotest takes care of this for you anyway). allure { autoconfigure = false version = \"2.13.1\" } Finally, execute the gradle task allureReport and the report will be generated in ./build/reports/allure-report and inside you should find the index.html entry point for the report.","title":"Gradle Plugin"},{"location":"extensions/allure/#setting-build-dir","text":"If you are not using the gradle plugin then you will need to inform Allure where the build dir is by setting the allure.results.directory system property on your tests configuration. If you are using the gradle plugin, then this can be skipped as the gradle plugin does this for you. For example: tasks.named<Test>(\"test\") { // or \"jvmTest\" etc useJUnitPlatform() systemProperty(\"allure.results.directory\", project.buildDir.toString() + \"/allure-results\") }","title":"Setting Build Dir"},{"location":"extensions/allure/#final-report","text":"If all was successful, after test execution and report generation, you will see something like this:","title":"Final Report"},{"location":"extensions/junit_xml/","text":"JUnit XML Format Reporter JUnit includes an XML report generator that it calls the legacy xml report . Many tools integrate with this format so it is very useful. However, this report has no concept of nesting tests. Therefore when used with a nested test style in Kotest, it will include parent tests as orphans. To solve this, Kotest has it's own implementation of the same format, that is configurable on whether to include parent tests and/or collapse the names. To set this up, we need to add the JunitXmlReporter to our project through project config . class MyConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf( JunitXmlReporter( includeContainers = false, useTestPathAsName = true ) ) } Additionally, the reporter needs to know where your build output folder is by setting a system property, so we configure that in the tests block in gradle. tasks.named<Test>(\"test\") { useJUnitPlatform() systemProperty(\"gradle.build.dir\", project.buildDir) } Parameters The reporter has two parameters: includeContainers when true, all intermediate tests are included in the report as tests in their own right. Defaults to false. useTestPathAsName when true, the full test path will be used as the name. In other words the name will include the name of any parent tests as a single string.","title":"Junit xml"},{"location":"extensions/junit_xml/#junit-xml-format-reporter","text":"JUnit includes an XML report generator that it calls the legacy xml report . Many tools integrate with this format so it is very useful. However, this report has no concept of nesting tests. Therefore when used with a nested test style in Kotest, it will include parent tests as orphans. To solve this, Kotest has it's own implementation of the same format, that is configurable on whether to include parent tests and/or collapse the names. To set this up, we need to add the JunitXmlReporter to our project through project config . class MyConfig : AbstractProjectConfig() { override fun listeners(): List<Listener> = listOf( JunitXmlReporter( includeContainers = false, useTestPathAsName = true ) ) } Additionally, the reporter needs to know where your build output folder is by setting a system property, so we configure that in the tests block in gradle. tasks.named<Test>(\"test\") { useJUnitPlatform() systemProperty(\"gradle.build.dir\", project.buildDir) }","title":"JUnit XML Format Reporter"},{"location":"extensions/junit_xml/#parameters","text":"The reporter has two parameters: includeContainers when true, all intermediate tests are included in the report as tests in their own right. Defaults to false. useTestPathAsName when true, the full test path will be used as the name. In other words the name will include the name of any parent tests as a single string.","title":"Parameters"},{"location":"extensions/mockserver/","text":"MockServer Kotest provides an extension for integration with the MockServer library. Note Requires the kotest-extensions-mockserver module to be added to your build. Mockserver allows us to define an in process HTTP server which is hard coded for routes that we want to test against. To use in Kotest, we attach an instance of MockServerListener to the spec under test, and Kotest will control the lifecycle automatically. Then it is a matter of using MockServerClient to wire in our responses. For example: class MyMockServerTest : FunSpec() { init { // this attaches the server to the lifeycle of the spec listener(MockServerListener(1080)) // we can use the client to create routes. Here we are setting them up // before each test by using the beforeTest callback. beforeTest { MockServerClient(\"localhost\", 1080).`when`( HttpRequest.request() .withMethod(\"POST\") .withPath(\"/login\") .withHeader(\"Content-Type\", \"application/json\") .withBody(\"\"\"{\"username\": \"foo\", \"password\": \"bar\"}\"\"\") ).respond( HttpResponse.response() .withStatusCode(202) .withHeader(\"X-Test\", \"foo\") ) } // this test will confirm the endpoint works test(\"login endpoint should accept username and password json\") { // using the ktor client to send requests val client = HttpClient(CIO) val resp = client.post<io.ktor.client.statement.HttpResponse>(\"http://localhost:1080/login\") { contentType(ContentType.Application.Json) body = \"\"\"{\"username\": \"foo\", \"password\": \"bar\"}\"\"\" } // these handy matchers come from the kotest-assertions-ktor module resp.shouldHaveStatus(HttpStatusCode.Accepted) resp.shouldHaveHeader(\"X-Test\", \"foo\") } } } In the above example, we are of course just testing the mock itself, but it shows how a real test could be configured. For example, you may have an API client that you want to test, so you would configure the API routes using mock server, and then invoke methods on your API client, ensuring it handles the responses correctly.","title":"Mockserver"},{"location":"extensions/mockserver/#mockserver","text":"Kotest provides an extension for integration with the MockServer library. Note Requires the kotest-extensions-mockserver module to be added to your build. Mockserver allows us to define an in process HTTP server which is hard coded for routes that we want to test against. To use in Kotest, we attach an instance of MockServerListener to the spec under test, and Kotest will control the lifecycle automatically. Then it is a matter of using MockServerClient to wire in our responses. For example: class MyMockServerTest : FunSpec() { init { // this attaches the server to the lifeycle of the spec listener(MockServerListener(1080)) // we can use the client to create routes. Here we are setting them up // before each test by using the beforeTest callback. beforeTest { MockServerClient(\"localhost\", 1080).`when`( HttpRequest.request() .withMethod(\"POST\") .withPath(\"/login\") .withHeader(\"Content-Type\", \"application/json\") .withBody(\"\"\"{\"username\": \"foo\", \"password\": \"bar\"}\"\"\") ).respond( HttpResponse.response() .withStatusCode(202) .withHeader(\"X-Test\", \"foo\") ) } // this test will confirm the endpoint works test(\"login endpoint should accept username and password json\") { // using the ktor client to send requests val client = HttpClient(CIO) val resp = client.post<io.ktor.client.statement.HttpResponse>(\"http://localhost:1080/login\") { contentType(ContentType.Application.Json) body = \"\"\"{\"username\": \"foo\", \"password\": \"bar\"}\"\"\" } // these handy matchers come from the kotest-assertions-ktor module resp.shouldHaveStatus(HttpStatusCode.Accepted) resp.shouldHaveHeader(\"X-Test\", \"foo\") } } } In the above example, we are of course just testing the mock itself, but it shows how a real test could be configured. For example, you may have an API client that you want to test, so you would configure the API routes using mock server, and then invoke methods on your API client, ensuring it handles the responses correctly.","title":"MockServer"},{"location":"matchers/android_matchers/","text":"Android Matchers This page lists all current Android matchers in Kotest. These are additional to the default matchers and are specific to Android. To use them, it's required to add an extra dependency to your project: implementation(\"io.kotest:kotest-assertions-android:VERSION\") View view.shouldBeVisible() Asserts that the view visibility is VISIBLE view.shouldBeInvisible() Asserts that the view visibility is INVISIBLE view.shouldBeGone() Asserts that the view visibility is GONE view.shouldHaveContentDescription() Asserts that the view has any content description view.shouldHaveContentDescription(desc) Asserts that the view has desc as Content Description view.shouldHaveTag(key, value) Asserts that the view has a tag key with value value view.shouldHaveTag(any) Asserts that the view's tag is any view.shouldBeEnabled() Asserts that the view is enabled view.shouldBeFocused() Asserts that the view has focus view.shouldBeFocusable() Asserts that the view is focusable view.shouldBeFocusableInTouchMode() Asserts that the view is focusable in touch mode view.shouldBeClickable() Asserts that the view is clickable view.shouldBeLongClickable() Asserts that the view is long clickable TextView tv.shouldHaveText(text) Asserts that the text view has text text tv.shouldHaveTextColorId(id) Asserts that the text color is the same from color resource id tv.shouldHaveTextColor(colorInt) Asserts that the text color is colorInt tv.shouldBeAllCaps() Asserts that the textview is marked with the isAllCaps flag tv.shouldHaveTextAlignment(alignment) Asserts that the text alignment is alignment","title":"Android matchers"},{"location":"matchers/android_matchers/#android-matchers","text":"This page lists all current Android matchers in Kotest. These are additional to the default matchers and are specific to Android. To use them, it's required to add an extra dependency to your project: implementation(\"io.kotest:kotest-assertions-android:VERSION\") View view.shouldBeVisible() Asserts that the view visibility is VISIBLE view.shouldBeInvisible() Asserts that the view visibility is INVISIBLE view.shouldBeGone() Asserts that the view visibility is GONE view.shouldHaveContentDescription() Asserts that the view has any content description view.shouldHaveContentDescription(desc) Asserts that the view has desc as Content Description view.shouldHaveTag(key, value) Asserts that the view has a tag key with value value view.shouldHaveTag(any) Asserts that the view's tag is any view.shouldBeEnabled() Asserts that the view is enabled view.shouldBeFocused() Asserts that the view has focus view.shouldBeFocusable() Asserts that the view is focusable view.shouldBeFocusableInTouchMode() Asserts that the view is focusable in touch mode view.shouldBeClickable() Asserts that the view is clickable view.shouldBeLongClickable() Asserts that the view is long clickable TextView tv.shouldHaveText(text) Asserts that the text view has text text tv.shouldHaveTextColorId(id) Asserts that the text color is the same from color resource id tv.shouldHaveTextColor(colorInt) Asserts that the text color is colorInt tv.shouldBeAllCaps() Asserts that the textview is marked with the isAllCaps flag tv.shouldHaveTextAlignment(alignment) Asserts that the text alignment is alignment","title":"Android Matchers"},{"location":"matchers/arrow/","text":"Arrow Matchers This page lists all current matchers in the Kotest arrow matchers extension library. To use this library you need to add kotest-assertions-arrow to your build. Option option.shouldBeSome(v) Asserts that the option is of type Some with value v option.shouldBeNone() Asserts that the option is of type None Either either.shouldBeRight() Asserts that the either is of type Right either.shouldBeRight(v) Asserts that the either is of type Right with specified value v either.shouldBeLeft() Asserts that the either is of type Left either.shouldBeLeft(v) Asserts that the either is of type Left with specific value v either.shouldBeLeftOfType<A>() Asserts that the either is of type Left with a specified type A NonEmptyList nel.shouldContain(e) Asserts that the NonEmptyList contains the given element e nel.shouldContainAll(e1,e2,...,en) Asserts that the NonEmptyList contains all the given elements e1,e2,...,en nel.shouldContainNull() Asserts that the NonEmptyList contains at least one null nel.shouldContainNoNulls() Asserts that the NonEmptyList contains no nulls nel.shouldContainOnlyNulls() Asserts that the NonEmptyList contains only nulls or is empty nel.shouldHaveDuplicates() Asserts that the NonEmptyList has at least one duplicate nel.shouldBeSingleElement(e) Asserts that the NonEmptyList has a single element which is e nel.shouldBeSorted() Asserts that the NonEmptyList is sorted Validated validated.shouldBeValid() Asserts that the validated is of type Valid validated.shouldBeValid(v) Asserts that the validated is of type Valid with specific value v validated.shouldBeInvalid() Asserts that the validated is of type Invalid","title":"Arrow Matchers"},{"location":"matchers/arrow/#arrow-matchers","text":"This page lists all current matchers in the Kotest arrow matchers extension library. To use this library you need to add kotest-assertions-arrow to your build. Option option.shouldBeSome(v) Asserts that the option is of type Some with value v option.shouldBeNone() Asserts that the option is of type None Either either.shouldBeRight() Asserts that the either is of type Right either.shouldBeRight(v) Asserts that the either is of type Right with specified value v either.shouldBeLeft() Asserts that the either is of type Left either.shouldBeLeft(v) Asserts that the either is of type Left with specific value v either.shouldBeLeftOfType<A>() Asserts that the either is of type Left with a specified type A NonEmptyList nel.shouldContain(e) Asserts that the NonEmptyList contains the given element e nel.shouldContainAll(e1,e2,...,en) Asserts that the NonEmptyList contains all the given elements e1,e2,...,en nel.shouldContainNull() Asserts that the NonEmptyList contains at least one null nel.shouldContainNoNulls() Asserts that the NonEmptyList contains no nulls nel.shouldContainOnlyNulls() Asserts that the NonEmptyList contains only nulls or is empty nel.shouldHaveDuplicates() Asserts that the NonEmptyList has at least one duplicate nel.shouldBeSingleElement(e) Asserts that the NonEmptyList has a single element which is e nel.shouldBeSorted() Asserts that the NonEmptyList is sorted Validated validated.shouldBeValid() Asserts that the validated is of type Valid validated.shouldBeValid(v) Asserts that the validated is of type Valid with specific value v validated.shouldBeInvalid() Asserts that the validated is of type Invalid","title":"Arrow Matchers"},{"location":"matchers/compiler/","text":"Compiler Matchers Matchers that verify if a given piece of Kotlin code compiles or not Matcher Description string.shouldCompile() Asserts that the string is a valid Kotlin code. file.shouldCompile() Asserts that the file contains valid Kotlin code.","title":"Compiler"},{"location":"matchers/compiler/#compiler-matchers","text":"Matchers that verify if a given piece of Kotlin code compiles or not Matcher Description string.shouldCompile() Asserts that the string is a valid Kotlin code. file.shouldCompile() Asserts that the file contains valid Kotlin code.","title":"Compiler Matchers"},{"location":"matchers/core/","text":"Core Matchers Matchers provided by the kotest-assertions-core module. General obj.shouldBe(other) General purpose assertion that the given obj and other are both equal expr.shouldBeTrue() Convenience assertion that the expression is true. Equivalent to expr.shouldBe(true) expr.shouldBeFalse() Convenience assertion that the expression is false. Equivalent to expr.shouldBe(false) shouldThrow<T> { block } General purpose construct that asserts that the block throws a T Throwable or a subtype of T shouldThrowExactly<T> { block } General purpose construct that asserts that the block throws exactly T shouldThrowAny { block } General purpose construct that asserts that the block throws a Throwable of any type Types obj.shouldBeSameInstanceAs(other) Compares objects by identity, that is, they are the same exact reference. obj.shouldBeTypeOf<T>() Asserts that the given reference is exactly of type T. Subclass will fail. Ie, 1 should beOfType<Number> would fail because although 1 is a Number, the runtime type is not Number. obj.shouldBeInstanceOf<T> Asserts that the given reference is of type T or a subclass of T. obj.shouldHaveAnnotation(annotationClass) Asserts that the object has an annotation of the given type. obj.shouldBeNull() Asserts that a given reference is null. Comparables comp.shouldBeLessThan(other) Uses compareTo to verify that comp is less than other comp.shouldBeLessThanOrEqualTo(other) Uses compareTo to verify that comp is less than or equal to other comp.shouldBeEqualComparingTo(other) Uses compareTo to verify that comp is equal to other comp.shouldBeEqualComparingTo(other, comparator) Uses comparator.compare to verify that comp is equal to other comp.shouldBeGreaterThan(other) Uses compareTo to verify that comp is greater than other comp.shouldBeGreaterThanOrEqualTo(other) Uses compareTo to verify that comp is greater than or equal to other Iterator iterator.shouldBeEmpty() Asserts that the iterator does not have a next value. iterator.shouldHaveNext() Asserts that the iterator has a next value Maps map.shouldContain(\"key\", \"value\") Asserts that the map contains the mapping \"key\" to \"value\" map.shouldContainAll(other) Asserts that the map contains all the pairs from the given map. map.shouldContainExactly(other) Asserts that the map contains exactly the pairs from given map, and no extra. map.shouldContainKey(key) Asserts that the map contains a key called key with any value map.shouldContainKeys(keys) Asserts that the map contains mappings for all the given keys. map.shouldContainValue(value) Asserts that the map contains at least one mapping where the value is value . map.shouldContainValues(values) Asserts that the map contains all the given values. map.shouldBeEmpty() Asserts that this map is empty. Strings str.shouldBeBlank() Asserts that the string contains only whitespace, or is empty. str.shouldBeEmpty() Asserts that the string has length zero. str.shouldBeLowerCase() Asserts that the string is all in lower case. str.shouldBeUpperCase() Asserts that the string is all in upper case. str.shouldContain(\"substr\") Asserts that the string includes the given substring. The substring can be equal to the string. This matcher is case sensitive. To make this case insensitive use shouldContainIgnoringCase(). str.shouldContain(regex) Asserts that the string includes the given regular expression. str.shouldContainADigit() Asserts that the string contains at least one digit. str.shouldContainIgnoringCase(substring) Asserts that the string contains the substring ignoring case. str.shouldContainOnlyDigits() Asserts that the string contains only digits, or is empty. str.shouldBeInteger([radix]) Asserts that the string contains an integer and returns it. str.shouldContainOnlyOnce(substring) Asserts that the string contains the substring exactly once. str.shouldEndWith(\"suffix\") Asserts that the string ends with the given suffix. The suffix can be equal to the string. This matcher is case sensitive. To make this case insensitive call toLowerCase() on the value before the matcher. str.shouldHaveLength(length) Asserts that the string has the given length. str.shouldHaveLineCount(count) Asserts that the string contains the given number of lines. Similar to str.split(\"\\n\").length.shouldBe(n) str.shouldHaveMaxLength(max) Asserts that the string is no longer than the given max length. str.shouldHaveMinLength(min) Asserts that the string is no shorter than the given min length. str.shouldHaveSameLengthAs(length) Asserts that the string has the same length as another string. str.shouldMatch(regex) Asserts that the string fully matches the given regex. str.shouldStartWith(\"prefix\") Asserts that the string starts with the given prefix. The prefix can be equal to the string. This matcher is case sensitive. To make this case insensitive call toLowerCase() on the value before the matcher. str.shouldBeEqualIgnoringCase(other) Asserts that the string is equal to another string ignoring case. Integers int.shouldBeBetween(x, y) Asserts that the integer is between x and y, inclusive on both x and y int.shouldBeLessThan(n) Asserts that the integer is less than the given value n int.shouldBeLessThanOrEqual(n) Asserts that the integer is less or equal to than the given value n int.shouldBeGreaterThan(n) Asserts that the integer is greater than the given value n int.shouldBeGreaterThanOrEqual(n) Asserts that the integer is greater than or equal to the given value n int.shouldBeEven() Asserts that the integer is even. int.shouldBeOdd() Asserts that the integer is odd. int.shouldBeInRange(range) Asserts that the integer is included in the given range. int.shouldBeZero() Asserts that the integer is zero Longs long.shouldBeBetween(x, y) Asserts that the long is between x and y, inclusive on both x and y long.shouldBeLessThan(n) Asserts that the long is less than the given value n long.shouldBeLessThanOrEqual(n) Asserts that the long is less or equal to than the given value n long.shouldBeGreaterThan(n) Asserts that the long is greater than the given value n long.shouldBeGreaterThanOrEqual(n) Asserts that the long is greater than or equal to the given value n long.shouldBeInRange(range) Asserts that the long is included in the given range. long.shouldBeEven() Asserts that the long is even. long.shouldBeOdd() Asserts that the long is odd. long.shouldBeZero() Asserts that the long is zero Doubles or Floats double.shouldBe(value plusOrMinus(tolerance)) Asserts that the double is equal to the given value within a tolerance range. This is the recommended way of testing for double equality. double.shouldBeBetween(x, y) Asserts that the double is between x and y, inclusive on both x and y double.shouldBeLessThan(n) Asserts that the double is less than the given value n double.shouldBeLessThanOrEqual(n) Asserts that the double is less or equal to than the given value n double.shouldBeGreaterThan(n) Asserts that the double is greater than the given value n double.shouldBeGreaterThanOrEqual(n) Asserts that the double is greater than or equal to the given value n double.shouldBePositive() Asserts that the double is positive double.shouldBeNegative() Asserts that the double is negative double.shouldBePositiveInfinity() Asserts that the double is positive infinity double.shouldBeNegativeInfinity() Asserts that the double is negative infinity double.shouldBeNaN() Asserts that the double is the Not-a-Number constant NaN double.shouldBeZero() Asserts that the double is zero BigDecimal bigDecimal.shouldHavePrecision(n) Asserts that the bigDecimal precision is equals than the given value n bigDecimal.shouldHaveScale(n) Asserts that the bigDecimal scale is equals than the given value n bigDecimal.shouldBePositive() Asserts that the bigDecimal is positive bigDecimal.shouldBeNegative() Asserts that the bigDecimal is negative bigDecimal.shouldBeZero() Asserts that the bigDecimal is zero bigDecimal.shouldBeLessThan(n) Asserts that the bigDecimal is less than the given value n bigDecimal.shouldBeLessThanOrEquals(n) Asserts that the bigDecimal is less than or equ bigDecimal.shouldBeGreaterThan(n) Asserts that the bigDecimal is greater than the given value n bigDecimal.shouldBeGreaterThanOrEquals(n) Asserts that the bigDecimal is greater than or equals to the given value n bigDecimal.shouldBeInRange(r) Asserts that the bigDecimal is in the given range Channels channel.shouldReceiveWithin(duration) Asserts that the channel should receive within duration channel.shouldReceiveNoElementsWithin(duration) Asserts that the channel should not receive any elements within duration channel.shouldHaveSize(n) Asserts that the channel should receive exactly n elements before closing channel.shouldReceiveAtLeast(n) Asserts that the channel should receive >= n elements channel.shouldReceiveAtMost(n) Asserts that the channel should receive <=n elements before closing channel.shouldBeClosed() Asserts that the channel is closed channel.shouldBeOpen() Asserts that the channel is open channel.shouldBeEmpty() Asserts that the channel is empty Collections collection.shouldBeEmpty() Asserts that the collections has zero elements. collection.shouldBeUnique() Asserts that all the elements of the collection are distinct. collection.shouldContain(element) Asserts that the collection contains the given element. collection.shouldContainAll(e1, e2, ..., en) Asserts that the collection contains all the elements listed, where order is not important. Ie, element 2 can be in the collection before element 1. collection.shouldContainDuplicates() Asserts that the collection contains at least one duplicate element. collection.shouldContainExactly() Assert that a collection contains exactly the given values and nothing else, in order. collection.shouldContainExactlyInAnyOrder() Assert that a collection contains exactly the given values and nothing else, in any order. collection.shouldContainAllInAnyOrder() Assert that a collection contains all the given values and nothing else, in any order. collection.shouldContainNoNulls() Asserts that the collection contains no null elements, or is empty. collection.shouldContainNull() Asserts that the collection contains at least one null element. collection.shouldContainOnlyNulls() Asserts that the collection contains only null elements, or is empty. collection.shouldHaveSingleElement(element) Asserts that the collection only contains a single element and that that element is the given one. collection.shouldHaveSingleElement { block } Asserts that the collection contains a single element by a given predicate. collection.shouldHaveSize(length) Asserts that the collection is exactly the given length. collection.shouldBeSingleton() Asserts that the collection contains only one element. collection.shouldBeSingleton { block } Asserts that the collection only one element, and then, runs the block with this element. collection.shouldHaveLowerBound(element) Asserts that the given element is smaller or equal to every element of the collection. Works only for elements that implement Comparable. collection.shouldHaveUpperBound(element) Asserts that the given element is larger or equal to every element of the collection. Works only for elements that implement Comparable. collection.shouldBeSmallerThan(col) Asserts that the collection is smaller than the other collection. collection.shouldBeLargerThan(col) Asserts that the collection is larger than the other collection. collection.shouldBeSameSizeAs(col) Asserts that the collection has the same size as the other collection. collection.shouldHaveAtLeastSize(n) Asserts that the collection has at least size n. collection.shouldHaveAtMostSize(n) Asserts that the collection has at most size n. list.shouldBeSorted() Asserts that the list is sorted. list.shouldContainInOrder(other) Asserts that this list contains the given list in order. Other elements may appear either side of the given list. list.shouldExistInOrder({ element }, ...) Asserts that this list contains elements matching the predicates in order. Other elements may appear around or between the elements matching the predicates. list.shouldHaveElementAt(index, element) Asserts that this list contains the given element at the given position. list.shouldStartWith(lst) Asserts that this list starts with the elements of the given list, in order. list.shouldEndWith(lst) Asserts that this list ends with the elements of the given list, in order. value.shouldBeOneOf(collection) Asserts that a specific instance is contained in a collection. collection.shouldContainAnyOf(collection) Asserts that the collection has at least one of the elements in collection value.shouldBeIn(collection) Asserts that an object is contained in collection, checking by value and not by reference. URIs uri.shouldHaveAuthority(fragment) Asserts that the uri has the given authority. uri.shouldHaveFragment(fragment) Asserts that the uri has the given fragment. uri.shouldHaveHost(scheme) Asserts that the uri has the given hostname. uri.shouldHaveParameter(scheme) Asserts that the uri's query string contains the given parameter. uri.shouldHavePath(scheme) Asserts that the uri has the given path. uri.shouldHavePort(scheme) Asserts that the uri has the given port. uri.shouldHaveQuery(fragment) Asserts that the uri has the given query. uri.shouldHaveScheme(scheme) Asserts that the uri has the given scheme. Files file.shouldBeAbsolute() Asserts that the file represents an absolute path. file.shouldBeADirectory() Asserts that the file denotes a directory. file.shouldBeAFile() Asserts that the file denotes a file. file.shouldBeCanonical() Asserts that the file is in canonical format. file.shouldBeEmpty() Asserts that the file exists but is empty. file.shouldBeExecutable() Asserts that the file is executable by the current process. file.shouldBeHidden() Asserts that the file exists on disk and is a hidden file. file.shouldBeReadable() Asserts that the file is readable by the current process. file.shouldBeRelative() Asserts that the file represents a relative path. file.shouldBeSmaller(file) Asserts that this file is smaller than the given file. file.shouldBeLarger(file) Asserts that this file is larger than the given file. file.shouldBeWriteable() Asserts that the file is writeable by the current process. dir.shouldBeNonEmptyDirectory() Asserts that the file is a directory and is non empty. dir.shouldContainFile(name) Asserts that the file is a directory and that it contains a file with the given name. dir.shouldContainNFiles(name) Asserts that the file is a directory and that it contains exactly n files. file.shouldExist() Asserts that the file exists on disk, either a directory or as a file. file.shouldHaveExtension(ext) Asserts that the file ends with the given extension. file.shouldHaveFileSize(size) Asserts that the file has the given file size. file.shouldHaveName(name) Asserts that the file's name matches the given name. file.shouldHavePath(path) Asserts that the file's path matches the given path. file.shouldStartWithPath(prefix) Asserts that the file's path starts with the given prefix. dir.shouldContainFileDeep(name) Assert that file is a directory and that it or any sub directory contains a file with the given name. dir.shouldContainFiles(name1, name2, ..., nameN) Asserts that the file is a directory and that it contains al files with the given name. file.shouldBeSymbolicLink() Asserts that the file is a symbolic link. file.shouldHaveParent(name) Assert that the file has a parent with the given name Dates date.shouldHaveSameYearAs(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonthAs(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDayAs(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeWithin(period, otherDate) Asserts that the date is within the period of the given date. date.shouldBeWithin(duration, otherDate) Asserts that the date is within the duration of the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDayOfYear(day) Asserts that the date have correct day of year. date.shouldHaveDayOfMonth(day) Asserts that the date have correct day of month. date.shouldHaveDayOfWeek(day) Asserts that the date have correct day of week. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. date.shouldHaveNano(nao) Asserts that the date have correct nano second. ZonedDateTime zonedDateTime.shouldBeToday() Asserts that the ZonedDateTime has the same day as the today. zonedDateTime.shouldHaveSameInstantAs(other: ZonedDateTime) Asserts that the ZonedDateTime is equal to other ZonedDateTime using ChronoZonedDateTime.isEqual . Times time.shouldHaveSameHoursAs(otherTime) Asserts that the time has the same hours as the given time. time.shouldHaveSameMinutesAs(otherTime) Asserts that the time has the same minutes as the given time. time.shouldHaveSameSecondsAs(otherTime) Asserts that the time has the same seconds as the given time. time.shouldHaveSameNanosAs(otherTime) Asserts that the time has the same nanos as the given time. time.shouldBeBefore(otherTime) Asserts that the time is before the given time. time.shouldBeAfter(otherTime) Asserts that the time is after the given time. time.shouldBeBetween(firstTime, secondTime) Asserts that the time is between firstTime and secondTime. Instant instant.shouldBeAfter(anotherInstant) Asserts that the instant is after anotherInstant instant.shouldBeBefore(anotherInstant) Asserts that the instant is before anotherInstant instant.shouldBeBetween(fromInstant, toInstant) Asserts that the instant is between fromInstant and toInstant Timestamp timestamp.shouldBeAfter(anotherTimestamp) Asserts that the timestamp is after anotherTimestamp timestamp.shouldBeBefore(anotherTimestamp) Asserts that the timestamp is before anotherTimestamp timestamp.shouldBeBetween(fromTimestamp, toTimestamp) Asserts that the timestamp is between fromTimestamp and toTimestamp Concurrent shouldCompleteWithin(timeout, unit, function) Asserts that the given function completes within the given duration. shouldTimeout(timeout, unit, function) Asserts that given function does not complete within the given duration. shouldTimeout(duration, suspendableFunction) Asserts that given suspendable function does not complete within the given duration. Futures future.shouldBeCancelled() Asserts that the future has been cancelled. future.shouldBeCompleted() Asserts that the future has completed. future.shouldBeCompletedExceptionally() Asserts that the the future has completed with an exception. future.shouldCompleteExceptionallyWith(throwable) Asserts that the the future will complete with given exception. Threads thread.shouldBeBlocked() Asserts that the thread is currently blocked. thread.shouldBeDaemon() Asserts that the thread is a daemon thread. thread.shouldBeAlive() Asserts that the thread is alive. thread.shouldBeTerminated() Asserts that the thread has been terminated. Throwables / Exceptions throwable.shouldHaveMessage(message) Asserts that the throwable message is the same of the given one. throwable.shouldHaveCause() Asserts that the throwable have a cause. throwable.shouldHaveCause { block } Asserts that the throwable have a cause, and pass it as parameter to the block throwable.shouldHaveCauseInstanceOf<T>() Asserts that the throwable have a cause and it is of type T or a subclass of T. throwable.shouldHaveCauseOfType<T>() Asserts that the throwable have a cause and it is exactly of type T. Result result.shouldBeSuccess() Asserts that the result is success result.shouldBeSuccess(value) Asserts that the result is a success and the value is the same of the given one. result.shouldBeSuccess(block) Asserts that the result is success and then, runs the block with the result value. result.shouldBeFailure() Asserts that the result is failure result.shouldBeFailureOfType<Type : Throwable>() Asserts that the result is a failure and the exception class is equals the same of the given one. result.shouldBeFailure(block) Asserts that the result is failure and then, runs the block with the exception. Optional optional.shouldBePresent() Asserts that this Optional is present optional.shouldBePresent { value -> .. } Asserts that this Optional is present , then execute block with the value optional.shouldBeEmpty() Asserts that this optional is empty Reflection kclass.shouldHaveAnnotations() Asserts that the class has some annotation kclass.shouldHaveAnnotations(n) Asserts that the class has exactly N annotation kclass.shouldBeAnnotatedWith<T>() Asserts that the class is annotated with the given type kclass.shouldBeAnnotatedWith<T> { block } Asserts that the class is annotated with the given type, and then, runs the block with the annotation kclass.shouldHaveFunction(name) Asserts that the class have a function with the given name kclass.shouldHaveFunction(name) { block } Asserts that the class have a function with the given name, and then, runs the block with the function kclass.shouldHaveMemberProperty(name) Asserts that the class have a member property with the given name kclass.shouldHaveMemberProperty(name) { block } Asserts that the class have a member property with the given name, and then, runs the block with the function kclass.shouldBeSubtypeOf<T>() Asserts that the class is a subtype of T kclass.shouldBeSupertypeOf<T>() Asserts that the class is a supertype of T kclass.shouldBeData() Asserts that the class is a data class kclass.shouldBeSealed() Asserts that the class is a sealed class kclass.shouldBeCompanion() Asserts that the class is a companion object kclass.shouldHavePrimaryConstructor() Asserts that the class has a primary constructor kclass.shouldHaveVisibility(visibility) Asserts that the class has the given visibility kfunction.shouldHaveAnnotations() Asserts that the function has some annotation kfunction.shouldHaveAnnotations(n) Asserts that the function has exactly N annotation kfunction.shouldBeAnnotatedWith<T>() Asserts that the function is annotated with the given type kfunction.shouldBeAnnotatedWith<T> { block } Asserts that the function is annotated with the given type, and then, runs the block with the annotation kfunction.shouldHaveReturnType<T>() Asserts that the function returns the given type kfunction.shouldBeInline() Asserts that the function is inline kfunction.shouldBeInfix() Asserts that the function is infix kproperty.shouldBeOfType<T>() Asserts that the property is of the given type kproperty.shouldBeConst() Asserts that the property is a const kproperty.shouldBeLateInit() Asserts that the property is a late init var kcallable.shouldHaveVisibility(visibility) Asserts that the member have the given visibility kcallable.shouldBeFinal() Asserts that the member is final kcallable.shouldBeOpen() Asserts that the member is open kcallable.shouldBeAbstract() Asserts that the member is abstract kcallable.shouldBeSuspendable() Asserts that the member is suspendable kcallable.shouldAcceptParameters(parameters) Asserts that the member can be called with the parameters (check the types) kcallable.shouldAcceptParameters(parameters) { block } Asserts that the member can be called with the parameters (check the types), and then, runs the block with the annotation kcallable.shouldHaveParametersWithName(parameters) Asserts that the member has the parameters with the given name kcallable.shouldHaveParametersWithName(parameters) { block } Asserts that the member has the parameters with the given name, and then, runs the block with the annotation ktype.shouldBeOfType<T>() Asserts that the KType has the type T Statistic collection.shouldHaveMean(mean) Asserts that collection has specific mean with default precision = 4 collection.shouldHaveMean(mean, precision) Asserts that collection has specific mean with specific precision collection.shouldHaveVariance(mean) Asserts that collection has specific variance with default precision = 4 collection.shouldHaveVariance(mean, precision) Asserts that collection has specific variance with specific precision collection.shouldHaveStandardDeviation(mean) Asserts that collection has specific standard deviation with default precision = 4 collection.shouldHaveStandardDeviation(mean, precision) Asserts that collection has specific standard deviation with specific precision Regex regex.shouldBeRegex(anotherRegex) Asserts that regex is equal to anotherRegex by comparing their pattern and regexOptions regex.shouldHavePattern(regexPattern) Asserts that regex have given regexPattern regex.shouldHaveExactRegexOptions(regexOptions) Asserts that regex have exactly the given regexOptions regex.shouldIncludeRegexOption(regexOption) Asserts that regex include the given regexOption regex.shouldIncludeRegexOptions(regexOptions) Asserts that regex include of the given regexOptions Selective Matchers any.shouldBeEqualToUsingFields(other: T, vararg properties: KProperty<*>) Asserts that the any is equal to other considering only given properties. See Example any.shouldBeEqualToIgnoringFields(other: T, vararg properties: KProperty<*>) Asserts that the any is equal to other ignoring the given properties. See Example","title":"Core Matchers"},{"location":"matchers/core/#core-matchers","text":"Matchers provided by the kotest-assertions-core module. General obj.shouldBe(other) General purpose assertion that the given obj and other are both equal expr.shouldBeTrue() Convenience assertion that the expression is true. Equivalent to expr.shouldBe(true) expr.shouldBeFalse() Convenience assertion that the expression is false. Equivalent to expr.shouldBe(false) shouldThrow<T> { block } General purpose construct that asserts that the block throws a T Throwable or a subtype of T shouldThrowExactly<T> { block } General purpose construct that asserts that the block throws exactly T shouldThrowAny { block } General purpose construct that asserts that the block throws a Throwable of any type Types obj.shouldBeSameInstanceAs(other) Compares objects by identity, that is, they are the same exact reference. obj.shouldBeTypeOf<T>() Asserts that the given reference is exactly of type T. Subclass will fail. Ie, 1 should beOfType<Number> would fail because although 1 is a Number, the runtime type is not Number. obj.shouldBeInstanceOf<T> Asserts that the given reference is of type T or a subclass of T. obj.shouldHaveAnnotation(annotationClass) Asserts that the object has an annotation of the given type. obj.shouldBeNull() Asserts that a given reference is null. Comparables comp.shouldBeLessThan(other) Uses compareTo to verify that comp is less than other comp.shouldBeLessThanOrEqualTo(other) Uses compareTo to verify that comp is less than or equal to other comp.shouldBeEqualComparingTo(other) Uses compareTo to verify that comp is equal to other comp.shouldBeEqualComparingTo(other, comparator) Uses comparator.compare to verify that comp is equal to other comp.shouldBeGreaterThan(other) Uses compareTo to verify that comp is greater than other comp.shouldBeGreaterThanOrEqualTo(other) Uses compareTo to verify that comp is greater than or equal to other Iterator iterator.shouldBeEmpty() Asserts that the iterator does not have a next value. iterator.shouldHaveNext() Asserts that the iterator has a next value Maps map.shouldContain(\"key\", \"value\") Asserts that the map contains the mapping \"key\" to \"value\" map.shouldContainAll(other) Asserts that the map contains all the pairs from the given map. map.shouldContainExactly(other) Asserts that the map contains exactly the pairs from given map, and no extra. map.shouldContainKey(key) Asserts that the map contains a key called key with any value map.shouldContainKeys(keys) Asserts that the map contains mappings for all the given keys. map.shouldContainValue(value) Asserts that the map contains at least one mapping where the value is value . map.shouldContainValues(values) Asserts that the map contains all the given values. map.shouldBeEmpty() Asserts that this map is empty. Strings str.shouldBeBlank() Asserts that the string contains only whitespace, or is empty. str.shouldBeEmpty() Asserts that the string has length zero. str.shouldBeLowerCase() Asserts that the string is all in lower case. str.shouldBeUpperCase() Asserts that the string is all in upper case. str.shouldContain(\"substr\") Asserts that the string includes the given substring. The substring can be equal to the string. This matcher is case sensitive. To make this case insensitive use shouldContainIgnoringCase(). str.shouldContain(regex) Asserts that the string includes the given regular expression. str.shouldContainADigit() Asserts that the string contains at least one digit. str.shouldContainIgnoringCase(substring) Asserts that the string contains the substring ignoring case. str.shouldContainOnlyDigits() Asserts that the string contains only digits, or is empty. str.shouldBeInteger([radix]) Asserts that the string contains an integer and returns it. str.shouldContainOnlyOnce(substring) Asserts that the string contains the substring exactly once. str.shouldEndWith(\"suffix\") Asserts that the string ends with the given suffix. The suffix can be equal to the string. This matcher is case sensitive. To make this case insensitive call toLowerCase() on the value before the matcher. str.shouldHaveLength(length) Asserts that the string has the given length. str.shouldHaveLineCount(count) Asserts that the string contains the given number of lines. Similar to str.split(\"\\n\").length.shouldBe(n) str.shouldHaveMaxLength(max) Asserts that the string is no longer than the given max length. str.shouldHaveMinLength(min) Asserts that the string is no shorter than the given min length. str.shouldHaveSameLengthAs(length) Asserts that the string has the same length as another string. str.shouldMatch(regex) Asserts that the string fully matches the given regex. str.shouldStartWith(\"prefix\") Asserts that the string starts with the given prefix. The prefix can be equal to the string. This matcher is case sensitive. To make this case insensitive call toLowerCase() on the value before the matcher. str.shouldBeEqualIgnoringCase(other) Asserts that the string is equal to another string ignoring case. Integers int.shouldBeBetween(x, y) Asserts that the integer is between x and y, inclusive on both x and y int.shouldBeLessThan(n) Asserts that the integer is less than the given value n int.shouldBeLessThanOrEqual(n) Asserts that the integer is less or equal to than the given value n int.shouldBeGreaterThan(n) Asserts that the integer is greater than the given value n int.shouldBeGreaterThanOrEqual(n) Asserts that the integer is greater than or equal to the given value n int.shouldBeEven() Asserts that the integer is even. int.shouldBeOdd() Asserts that the integer is odd. int.shouldBeInRange(range) Asserts that the integer is included in the given range. int.shouldBeZero() Asserts that the integer is zero Longs long.shouldBeBetween(x, y) Asserts that the long is between x and y, inclusive on both x and y long.shouldBeLessThan(n) Asserts that the long is less than the given value n long.shouldBeLessThanOrEqual(n) Asserts that the long is less or equal to than the given value n long.shouldBeGreaterThan(n) Asserts that the long is greater than the given value n long.shouldBeGreaterThanOrEqual(n) Asserts that the long is greater than or equal to the given value n long.shouldBeInRange(range) Asserts that the long is included in the given range. long.shouldBeEven() Asserts that the long is even. long.shouldBeOdd() Asserts that the long is odd. long.shouldBeZero() Asserts that the long is zero Doubles or Floats double.shouldBe(value plusOrMinus(tolerance)) Asserts that the double is equal to the given value within a tolerance range. This is the recommended way of testing for double equality. double.shouldBeBetween(x, y) Asserts that the double is between x and y, inclusive on both x and y double.shouldBeLessThan(n) Asserts that the double is less than the given value n double.shouldBeLessThanOrEqual(n) Asserts that the double is less or equal to than the given value n double.shouldBeGreaterThan(n) Asserts that the double is greater than the given value n double.shouldBeGreaterThanOrEqual(n) Asserts that the double is greater than or equal to the given value n double.shouldBePositive() Asserts that the double is positive double.shouldBeNegative() Asserts that the double is negative double.shouldBePositiveInfinity() Asserts that the double is positive infinity double.shouldBeNegativeInfinity() Asserts that the double is negative infinity double.shouldBeNaN() Asserts that the double is the Not-a-Number constant NaN double.shouldBeZero() Asserts that the double is zero BigDecimal bigDecimal.shouldHavePrecision(n) Asserts that the bigDecimal precision is equals than the given value n bigDecimal.shouldHaveScale(n) Asserts that the bigDecimal scale is equals than the given value n bigDecimal.shouldBePositive() Asserts that the bigDecimal is positive bigDecimal.shouldBeNegative() Asserts that the bigDecimal is negative bigDecimal.shouldBeZero() Asserts that the bigDecimal is zero bigDecimal.shouldBeLessThan(n) Asserts that the bigDecimal is less than the given value n bigDecimal.shouldBeLessThanOrEquals(n) Asserts that the bigDecimal is less than or equ bigDecimal.shouldBeGreaterThan(n) Asserts that the bigDecimal is greater than the given value n bigDecimal.shouldBeGreaterThanOrEquals(n) Asserts that the bigDecimal is greater than or equals to the given value n bigDecimal.shouldBeInRange(r) Asserts that the bigDecimal is in the given range Channels channel.shouldReceiveWithin(duration) Asserts that the channel should receive within duration channel.shouldReceiveNoElementsWithin(duration) Asserts that the channel should not receive any elements within duration channel.shouldHaveSize(n) Asserts that the channel should receive exactly n elements before closing channel.shouldReceiveAtLeast(n) Asserts that the channel should receive >= n elements channel.shouldReceiveAtMost(n) Asserts that the channel should receive <=n elements before closing channel.shouldBeClosed() Asserts that the channel is closed channel.shouldBeOpen() Asserts that the channel is open channel.shouldBeEmpty() Asserts that the channel is empty Collections collection.shouldBeEmpty() Asserts that the collections has zero elements. collection.shouldBeUnique() Asserts that all the elements of the collection are distinct. collection.shouldContain(element) Asserts that the collection contains the given element. collection.shouldContainAll(e1, e2, ..., en) Asserts that the collection contains all the elements listed, where order is not important. Ie, element 2 can be in the collection before element 1. collection.shouldContainDuplicates() Asserts that the collection contains at least one duplicate element. collection.shouldContainExactly() Assert that a collection contains exactly the given values and nothing else, in order. collection.shouldContainExactlyInAnyOrder() Assert that a collection contains exactly the given values and nothing else, in any order. collection.shouldContainAllInAnyOrder() Assert that a collection contains all the given values and nothing else, in any order. collection.shouldContainNoNulls() Asserts that the collection contains no null elements, or is empty. collection.shouldContainNull() Asserts that the collection contains at least one null element. collection.shouldContainOnlyNulls() Asserts that the collection contains only null elements, or is empty. collection.shouldHaveSingleElement(element) Asserts that the collection only contains a single element and that that element is the given one. collection.shouldHaveSingleElement { block } Asserts that the collection contains a single element by a given predicate. collection.shouldHaveSize(length) Asserts that the collection is exactly the given length. collection.shouldBeSingleton() Asserts that the collection contains only one element. collection.shouldBeSingleton { block } Asserts that the collection only one element, and then, runs the block with this element. collection.shouldHaveLowerBound(element) Asserts that the given element is smaller or equal to every element of the collection. Works only for elements that implement Comparable. collection.shouldHaveUpperBound(element) Asserts that the given element is larger or equal to every element of the collection. Works only for elements that implement Comparable. collection.shouldBeSmallerThan(col) Asserts that the collection is smaller than the other collection. collection.shouldBeLargerThan(col) Asserts that the collection is larger than the other collection. collection.shouldBeSameSizeAs(col) Asserts that the collection has the same size as the other collection. collection.shouldHaveAtLeastSize(n) Asserts that the collection has at least size n. collection.shouldHaveAtMostSize(n) Asserts that the collection has at most size n. list.shouldBeSorted() Asserts that the list is sorted. list.shouldContainInOrder(other) Asserts that this list contains the given list in order. Other elements may appear either side of the given list. list.shouldExistInOrder({ element }, ...) Asserts that this list contains elements matching the predicates in order. Other elements may appear around or between the elements matching the predicates. list.shouldHaveElementAt(index, element) Asserts that this list contains the given element at the given position. list.shouldStartWith(lst) Asserts that this list starts with the elements of the given list, in order. list.shouldEndWith(lst) Asserts that this list ends with the elements of the given list, in order. value.shouldBeOneOf(collection) Asserts that a specific instance is contained in a collection. collection.shouldContainAnyOf(collection) Asserts that the collection has at least one of the elements in collection value.shouldBeIn(collection) Asserts that an object is contained in collection, checking by value and not by reference. URIs uri.shouldHaveAuthority(fragment) Asserts that the uri has the given authority. uri.shouldHaveFragment(fragment) Asserts that the uri has the given fragment. uri.shouldHaveHost(scheme) Asserts that the uri has the given hostname. uri.shouldHaveParameter(scheme) Asserts that the uri's query string contains the given parameter. uri.shouldHavePath(scheme) Asserts that the uri has the given path. uri.shouldHavePort(scheme) Asserts that the uri has the given port. uri.shouldHaveQuery(fragment) Asserts that the uri has the given query. uri.shouldHaveScheme(scheme) Asserts that the uri has the given scheme. Files file.shouldBeAbsolute() Asserts that the file represents an absolute path. file.shouldBeADirectory() Asserts that the file denotes a directory. file.shouldBeAFile() Asserts that the file denotes a file. file.shouldBeCanonical() Asserts that the file is in canonical format. file.shouldBeEmpty() Asserts that the file exists but is empty. file.shouldBeExecutable() Asserts that the file is executable by the current process. file.shouldBeHidden() Asserts that the file exists on disk and is a hidden file. file.shouldBeReadable() Asserts that the file is readable by the current process. file.shouldBeRelative() Asserts that the file represents a relative path. file.shouldBeSmaller(file) Asserts that this file is smaller than the given file. file.shouldBeLarger(file) Asserts that this file is larger than the given file. file.shouldBeWriteable() Asserts that the file is writeable by the current process. dir.shouldBeNonEmptyDirectory() Asserts that the file is a directory and is non empty. dir.shouldContainFile(name) Asserts that the file is a directory and that it contains a file with the given name. dir.shouldContainNFiles(name) Asserts that the file is a directory and that it contains exactly n files. file.shouldExist() Asserts that the file exists on disk, either a directory or as a file. file.shouldHaveExtension(ext) Asserts that the file ends with the given extension. file.shouldHaveFileSize(size) Asserts that the file has the given file size. file.shouldHaveName(name) Asserts that the file's name matches the given name. file.shouldHavePath(path) Asserts that the file's path matches the given path. file.shouldStartWithPath(prefix) Asserts that the file's path starts with the given prefix. dir.shouldContainFileDeep(name) Assert that file is a directory and that it or any sub directory contains a file with the given name. dir.shouldContainFiles(name1, name2, ..., nameN) Asserts that the file is a directory and that it contains al files with the given name. file.shouldBeSymbolicLink() Asserts that the file is a symbolic link. file.shouldHaveParent(name) Assert that the file has a parent with the given name Dates date.shouldHaveSameYearAs(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonthAs(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDayAs(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeWithin(period, otherDate) Asserts that the date is within the period of the given date. date.shouldBeWithin(duration, otherDate) Asserts that the date is within the duration of the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDayOfYear(day) Asserts that the date have correct day of year. date.shouldHaveDayOfMonth(day) Asserts that the date have correct day of month. date.shouldHaveDayOfWeek(day) Asserts that the date have correct day of week. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. date.shouldHaveNano(nao) Asserts that the date have correct nano second. ZonedDateTime zonedDateTime.shouldBeToday() Asserts that the ZonedDateTime has the same day as the today. zonedDateTime.shouldHaveSameInstantAs(other: ZonedDateTime) Asserts that the ZonedDateTime is equal to other ZonedDateTime using ChronoZonedDateTime.isEqual . Times time.shouldHaveSameHoursAs(otherTime) Asserts that the time has the same hours as the given time. time.shouldHaveSameMinutesAs(otherTime) Asserts that the time has the same minutes as the given time. time.shouldHaveSameSecondsAs(otherTime) Asserts that the time has the same seconds as the given time. time.shouldHaveSameNanosAs(otherTime) Asserts that the time has the same nanos as the given time. time.shouldBeBefore(otherTime) Asserts that the time is before the given time. time.shouldBeAfter(otherTime) Asserts that the time is after the given time. time.shouldBeBetween(firstTime, secondTime) Asserts that the time is between firstTime and secondTime. Instant instant.shouldBeAfter(anotherInstant) Asserts that the instant is after anotherInstant instant.shouldBeBefore(anotherInstant) Asserts that the instant is before anotherInstant instant.shouldBeBetween(fromInstant, toInstant) Asserts that the instant is between fromInstant and toInstant Timestamp timestamp.shouldBeAfter(anotherTimestamp) Asserts that the timestamp is after anotherTimestamp timestamp.shouldBeBefore(anotherTimestamp) Asserts that the timestamp is before anotherTimestamp timestamp.shouldBeBetween(fromTimestamp, toTimestamp) Asserts that the timestamp is between fromTimestamp and toTimestamp Concurrent shouldCompleteWithin(timeout, unit, function) Asserts that the given function completes within the given duration. shouldTimeout(timeout, unit, function) Asserts that given function does not complete within the given duration. shouldTimeout(duration, suspendableFunction) Asserts that given suspendable function does not complete within the given duration. Futures future.shouldBeCancelled() Asserts that the future has been cancelled. future.shouldBeCompleted() Asserts that the future has completed. future.shouldBeCompletedExceptionally() Asserts that the the future has completed with an exception. future.shouldCompleteExceptionallyWith(throwable) Asserts that the the future will complete with given exception. Threads thread.shouldBeBlocked() Asserts that the thread is currently blocked. thread.shouldBeDaemon() Asserts that the thread is a daemon thread. thread.shouldBeAlive() Asserts that the thread is alive. thread.shouldBeTerminated() Asserts that the thread has been terminated. Throwables / Exceptions throwable.shouldHaveMessage(message) Asserts that the throwable message is the same of the given one. throwable.shouldHaveCause() Asserts that the throwable have a cause. throwable.shouldHaveCause { block } Asserts that the throwable have a cause, and pass it as parameter to the block throwable.shouldHaveCauseInstanceOf<T>() Asserts that the throwable have a cause and it is of type T or a subclass of T. throwable.shouldHaveCauseOfType<T>() Asserts that the throwable have a cause and it is exactly of type T. Result result.shouldBeSuccess() Asserts that the result is success result.shouldBeSuccess(value) Asserts that the result is a success and the value is the same of the given one. result.shouldBeSuccess(block) Asserts that the result is success and then, runs the block with the result value. result.shouldBeFailure() Asserts that the result is failure result.shouldBeFailureOfType<Type : Throwable>() Asserts that the result is a failure and the exception class is equals the same of the given one. result.shouldBeFailure(block) Asserts that the result is failure and then, runs the block with the exception. Optional optional.shouldBePresent() Asserts that this Optional is present optional.shouldBePresent { value -> .. } Asserts that this Optional is present , then execute block with the value optional.shouldBeEmpty() Asserts that this optional is empty Reflection kclass.shouldHaveAnnotations() Asserts that the class has some annotation kclass.shouldHaveAnnotations(n) Asserts that the class has exactly N annotation kclass.shouldBeAnnotatedWith<T>() Asserts that the class is annotated with the given type kclass.shouldBeAnnotatedWith<T> { block } Asserts that the class is annotated with the given type, and then, runs the block with the annotation kclass.shouldHaveFunction(name) Asserts that the class have a function with the given name kclass.shouldHaveFunction(name) { block } Asserts that the class have a function with the given name, and then, runs the block with the function kclass.shouldHaveMemberProperty(name) Asserts that the class have a member property with the given name kclass.shouldHaveMemberProperty(name) { block } Asserts that the class have a member property with the given name, and then, runs the block with the function kclass.shouldBeSubtypeOf<T>() Asserts that the class is a subtype of T kclass.shouldBeSupertypeOf<T>() Asserts that the class is a supertype of T kclass.shouldBeData() Asserts that the class is a data class kclass.shouldBeSealed() Asserts that the class is a sealed class kclass.shouldBeCompanion() Asserts that the class is a companion object kclass.shouldHavePrimaryConstructor() Asserts that the class has a primary constructor kclass.shouldHaveVisibility(visibility) Asserts that the class has the given visibility kfunction.shouldHaveAnnotations() Asserts that the function has some annotation kfunction.shouldHaveAnnotations(n) Asserts that the function has exactly N annotation kfunction.shouldBeAnnotatedWith<T>() Asserts that the function is annotated with the given type kfunction.shouldBeAnnotatedWith<T> { block } Asserts that the function is annotated with the given type, and then, runs the block with the annotation kfunction.shouldHaveReturnType<T>() Asserts that the function returns the given type kfunction.shouldBeInline() Asserts that the function is inline kfunction.shouldBeInfix() Asserts that the function is infix kproperty.shouldBeOfType<T>() Asserts that the property is of the given type kproperty.shouldBeConst() Asserts that the property is a const kproperty.shouldBeLateInit() Asserts that the property is a late init var kcallable.shouldHaveVisibility(visibility) Asserts that the member have the given visibility kcallable.shouldBeFinal() Asserts that the member is final kcallable.shouldBeOpen() Asserts that the member is open kcallable.shouldBeAbstract() Asserts that the member is abstract kcallable.shouldBeSuspendable() Asserts that the member is suspendable kcallable.shouldAcceptParameters(parameters) Asserts that the member can be called with the parameters (check the types) kcallable.shouldAcceptParameters(parameters) { block } Asserts that the member can be called with the parameters (check the types), and then, runs the block with the annotation kcallable.shouldHaveParametersWithName(parameters) Asserts that the member has the parameters with the given name kcallable.shouldHaveParametersWithName(parameters) { block } Asserts that the member has the parameters with the given name, and then, runs the block with the annotation ktype.shouldBeOfType<T>() Asserts that the KType has the type T Statistic collection.shouldHaveMean(mean) Asserts that collection has specific mean with default precision = 4 collection.shouldHaveMean(mean, precision) Asserts that collection has specific mean with specific precision collection.shouldHaveVariance(mean) Asserts that collection has specific variance with default precision = 4 collection.shouldHaveVariance(mean, precision) Asserts that collection has specific variance with specific precision collection.shouldHaveStandardDeviation(mean) Asserts that collection has specific standard deviation with default precision = 4 collection.shouldHaveStandardDeviation(mean, precision) Asserts that collection has specific standard deviation with specific precision Regex regex.shouldBeRegex(anotherRegex) Asserts that regex is equal to anotherRegex by comparing their pattern and regexOptions regex.shouldHavePattern(regexPattern) Asserts that regex have given regexPattern regex.shouldHaveExactRegexOptions(regexOptions) Asserts that regex have exactly the given regexOptions regex.shouldIncludeRegexOption(regexOption) Asserts that regex include the given regexOption regex.shouldIncludeRegexOptions(regexOptions) Asserts that regex include of the given regexOptions Selective Matchers any.shouldBeEqualToUsingFields(other: T, vararg properties: KProperty<*>) Asserts that the any is equal to other considering only given properties. See Example any.shouldBeEqualToIgnoringFields(other: T, vararg properties: KProperty<*>) Asserts that the any is equal to other ignoring the given properties. See Example","title":"Core Matchers"},{"location":"matchers/json/","text":"Json Matchers Matchers for JSON are provided by the kotest-assertions-json module. JSON For convenience, JSONs are simply strings str?.shouldMatchJson(json?) Asserts that the JSON is equal to another JSON ignoring properties' order and formatting. str?.shouldContainJsonKey(\"$.json.path\") Asserts that the JSON contains a JSON path. str?.shouldContainJsonKeyValue(\"$.json.path\", value) Asserts that the JSON contains a JSON path with a specific value . str?.shouldMatchJsonResource(\"/file.json\") Asserts that the JSON is equal to the existing /file.json ignoring properties' order and formatting. Info JSON matchers are built using the Jackson library","title":"Json Matchers"},{"location":"matchers/json/#json-matchers","text":"Matchers for JSON are provided by the kotest-assertions-json module. JSON For convenience, JSONs are simply strings str?.shouldMatchJson(json?) Asserts that the JSON is equal to another JSON ignoring properties' order and formatting. str?.shouldContainJsonKey(\"$.json.path\") Asserts that the JSON contains a JSON path. str?.shouldContainJsonKeyValue(\"$.json.path\", value) Asserts that the JSON contains a JSON path with a specific value . str?.shouldMatchJsonResource(\"/file.json\") Asserts that the JSON is equal to the existing /file.json ignoring properties' order and formatting. Info JSON matchers are built using the Jackson library","title":"Json Matchers"},{"location":"matchers/jsoup/","text":"Jsoup Matchers This page lists all current matchers in the KotlinTest jsoup matchers extension library. To use this library you need to add kotlintest-assertions-jsoup to your build. Element element.shouldHaveChildWithTag(tag) Asserts that the element has a child with the given tag element.shouldHaveText(text) Asserts that the element has the given text element.shouldHaveAttribute(name) Asserts that the element has an attribute with the given name element.shouldHaveAttributeValue(name, value) Asserts that the element have an attribute with the given value Elements elements.shouldBePresent() Asserts that the Elements object has some item elements.shouldBePresent(n) Asserts that the Elements object has N items elements.shouldBePresent(n) Asserts that the Elements object has N items HTML element.shouldHaveId(id) Asserts that the element has an attribute id with the given value element.shouldHaveClass(class) Asserts that the element has the specified class element.shouldHaveSrc(src) Asserts that the element has an attribute src with the given value element.shouldHaveHref(href) Asserts that the element has an attribute href with the given value element.shouldHaveElementWithId(id) Asserts that the element has a child with the given id element.shouldHaveChildWithClass(id) Asserts that the element has a child with the given class","title":"Jsoup"},{"location":"matchers/jsoup/#jsoup-matchers","text":"This page lists all current matchers in the KotlinTest jsoup matchers extension library. To use this library you need to add kotlintest-assertions-jsoup to your build. Element element.shouldHaveChildWithTag(tag) Asserts that the element has a child with the given tag element.shouldHaveText(text) Asserts that the element has the given text element.shouldHaveAttribute(name) Asserts that the element has an attribute with the given name element.shouldHaveAttributeValue(name, value) Asserts that the element have an attribute with the given value Elements elements.shouldBePresent() Asserts that the Elements object has some item elements.shouldBePresent(n) Asserts that the Elements object has N items elements.shouldBePresent(n) Asserts that the Elements object has N items HTML element.shouldHaveId(id) Asserts that the element has an attribute id with the given value element.shouldHaveClass(class) Asserts that the element has the specified class element.shouldHaveSrc(src) Asserts that the element has an attribute src with the given value element.shouldHaveHref(href) Asserts that the element has an attribute href with the given value element.shouldHaveElementWithId(id) Asserts that the element has a child with the given id element.shouldHaveChildWithClass(id) Asserts that the element has a child with the given class","title":"Jsoup Matchers"},{"location":"matchers/klock/","text":"Klock Matchers Matchers for the Klock library, provided by the kotest-assertions-klock module. Matcher Description date.shouldHaveSameYear(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonth(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDay(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDay(day) Asserts that the date have correct day of year. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. time.shouldHaveSameHoursAs(time) Asserts that the time has the same hours as the given time. time.shouldHaveHours(hours) Asserts that the time has the given hours. time.shouldHaveSameMinutesAs(time) Asserts that the time has the same minutes as the given time. time.shouldHaveMinutes(minutes) Asserts that the time has the given minutes. time.shouldHaveSameSeconds(time) Asserts that the time has the same seconds as the given time. time.shouldHaveSeconds(seconds) Asserts that the time has the given seconds. time.shouldHaveSameMillisecondsAs(time) Asserts that the time has the same milliseconds as the given time. time.shouldHaveMilliseconds(millis) Asserts that the time has the given millis. time.shouldBeBefore(time) Asserts that the time is before the given time. time.shouldBeAfter(time) Asserts that the time is after the given time. time.shouldBeBetween(time, time) Asserts that the time is between the two given times.","title":"Klock"},{"location":"matchers/klock/#klock-matchers","text":"Matchers for the Klock library, provided by the kotest-assertions-klock module. Matcher Description date.shouldHaveSameYear(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonth(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDay(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDay(day) Asserts that the date have correct day of year. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. time.shouldHaveSameHoursAs(time) Asserts that the time has the same hours as the given time. time.shouldHaveHours(hours) Asserts that the time has the given hours. time.shouldHaveSameMinutesAs(time) Asserts that the time has the same minutes as the given time. time.shouldHaveMinutes(minutes) Asserts that the time has the given minutes. time.shouldHaveSameSeconds(time) Asserts that the time has the same seconds as the given time. time.shouldHaveSeconds(seconds) Asserts that the time has the given seconds. time.shouldHaveSameMillisecondsAs(time) Asserts that the time has the same milliseconds as the given time. time.shouldHaveMilliseconds(millis) Asserts that the time has the given millis. time.shouldBeBefore(time) Asserts that the time is before the given time. time.shouldBeAfter(time) Asserts that the time is after the given time. time.shouldBeBetween(time, time) Asserts that the time is between the two given times.","title":"Klock Matchers"},{"location":"matchers/konform/","text":"Konform Matchers Kotest provides various matchers for use with Konform . They can be used in your tests to assert that a given object is validated or fails validation. To use these matchers add implementation 'io.kotest:kotest-assertions-konform-jvm:<version>' or implementation 'io.kotest:kotest-assertions-konform-js:<version> to your build. Let's start with a basic data class: data class UserProfile( val fullName: String, val age: Int? ) Then given a UserProfile validator like this: val validateUser = Validation<UserProfile> { UserProfile::fullName { minLength(4) maxLength(100) } UserProfile::age ifPresent { minimum(21) maximum(99) } } We can test that instances pass validation like this: val alice = UserProfile(\"Alice\", 25) validateUser shouldBeValid user1 And we can test that instances fail validation with specific error messages like this: val bob = UserProfile(\"bob\", 18) validateUser.shouldBeInvalid(a) { it.shouldContainError(UserProfile::fullName, \"must have at least 4 characters\") it.shouldContainError(UserProfile::age, \"must be at least '21'\") } Matcher Description validation.shouldBeValid(value) Asserts that the validation is valid for the given value validation.shouldBeInvalid(value) Asserts that the validation is invalid for the given value validation.shouldBeInvalid(value) { block } Asserts that the validation is invalid for the given value, and then, runs the block with invalid value","title":"Konform"},{"location":"matchers/konform/#konform-matchers","text":"Kotest provides various matchers for use with Konform . They can be used in your tests to assert that a given object is validated or fails validation. To use these matchers add implementation 'io.kotest:kotest-assertions-konform-jvm:<version>' or implementation 'io.kotest:kotest-assertions-konform-js:<version> to your build. Let's start with a basic data class: data class UserProfile( val fullName: String, val age: Int? ) Then given a UserProfile validator like this: val validateUser = Validation<UserProfile> { UserProfile::fullName { minLength(4) maxLength(100) } UserProfile::age ifPresent { minimum(21) maximum(99) } } We can test that instances pass validation like this: val alice = UserProfile(\"Alice\", 25) validateUser shouldBeValid user1 And we can test that instances fail validation with specific error messages like this: val bob = UserProfile(\"bob\", 18) validateUser.shouldBeInvalid(a) { it.shouldContainError(UserProfile::fullName, \"must have at least 4 characters\") it.shouldContainError(UserProfile::age, \"must be at least '21'\") } Matcher Description validation.shouldBeValid(value) Asserts that the validation is valid for the given value validation.shouldBeInvalid(value) Asserts that the validation is invalid for the given value validation.shouldBeInvalid(value) { block } Asserts that the validation is invalid for the given value, and then, runs the block with invalid value","title":"Konform Matchers"},{"location":"matchers/kotlinx-time/","text":"Kotlinx Datetime Matchers for the Kotlinx Datetime library are provided by the kotest-assertions-kotlinx-time module. LocalDate date.shouldHaveSameYearAs(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonthAs(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDayAs(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeWithin(period, otherDate) Asserts that the date is within the period of the given date. date.shouldBeWithin(duration, otherDate) Asserts that the date is within the duration of the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDayOfYear(day) Asserts that the date have correct day of year. date.shouldHaveDayOfMonth(day) Asserts that the date have correct day of month. date.shouldHaveDayOfWeek(day) Asserts that the date have correct day of week. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. date.shouldHaveNano(nano) Asserts that the date have correct nano second. LocalDateTime time.shouldHaveSameHoursAs(otherTime) Asserts that the time has the same hours as the given time. time.shouldHaveSameMinutesAs(otherTime) Asserts that the time has the same minutes as the given time. time.shouldHaveSameSecondsAs(otherTime) Asserts that the time has the same seconds as the given time. time.shouldHaveSameNanosAs(otherTime) Asserts that the time has the same nanos as the given time. time.shouldBeBefore(otherTime) Asserts that the time is before the given time. time.shouldBeAfter(otherTime) Asserts that the time is after the given time. time.shouldBeBetween(firstTime, secondTime) Asserts that the time is between firstTime and secondTime. Instant instant.shouldBeAfter(anotherInstant) Asserts that the instant is after anotherInstant instant.shouldBeBefore(anotherInstant) Asserts that the instant is before anotherInstant instant.shouldBeBetween(fromInstant, toInstant) Asserts that the instant is between fromInstant and toInstant","title":"Kotlinx time"},{"location":"matchers/kotlinx-time/#kotlinx-datetime","text":"Matchers for the Kotlinx Datetime library are provided by the kotest-assertions-kotlinx-time module. LocalDate date.shouldHaveSameYearAs(otherDate) Asserts that the date has the same year as the given date. date.shouldHaveSameMonthAs(otherDate) Asserts that the date has the same month as the given date. date.shouldHaveSameDayAs(otherDate) Asserts that the date has the same day of the month as the given date. date.shouldBeBefore(otherDate) Asserts that the date is before the given date. date.shouldBeAfter(otherDate) Asserts that the date is after the given date. date.shouldBeWithin(period, otherDate) Asserts that the date is within the period of the given date. date.shouldBeWithin(duration, otherDate) Asserts that the date is within the duration of the given date. date.shouldBeBetween(firstDate, secondDate) Asserts that the date is between firstdate and seconddate. date.shouldHaveYear(year) Asserts that the date have correct year. date.shouldHaveMonth(month) Asserts that the date have correct month. date.shouldHaveDayOfYear(day) Asserts that the date have correct day of year. date.shouldHaveDayOfMonth(day) Asserts that the date have correct day of month. date.shouldHaveDayOfWeek(day) Asserts that the date have correct day of week. date.shouldHaveHour(hour) Asserts that the date have correct hour. date.shouldHaveMinute(Minute) Asserts that the date have correct minute. date.shouldHaveSecond(second) Asserts that the date have correct second. date.shouldHaveNano(nano) Asserts that the date have correct nano second. LocalDateTime time.shouldHaveSameHoursAs(otherTime) Asserts that the time has the same hours as the given time. time.shouldHaveSameMinutesAs(otherTime) Asserts that the time has the same minutes as the given time. time.shouldHaveSameSecondsAs(otherTime) Asserts that the time has the same seconds as the given time. time.shouldHaveSameNanosAs(otherTime) Asserts that the time has the same nanos as the given time. time.shouldBeBefore(otherTime) Asserts that the time is before the given time. time.shouldBeAfter(otherTime) Asserts that the time is after the given time. time.shouldBeBetween(firstTime, secondTime) Asserts that the time is between firstTime and secondTime. Instant instant.shouldBeAfter(anotherInstant) Asserts that the instant is after anotherInstant instant.shouldBeBefore(anotherInstant) Asserts that the instant is before anotherInstant instant.shouldBeBetween(fromInstant, toInstant) Asserts that the instant is between fromInstant and toInstant","title":"Kotlinx Datetime"},{"location":"matchers/ktor/","text":"Ktor Matchers Matchers for Ktor are provided by the kotest-assertions-ktor module. Test Application Response The following matchers are used when testing via the ktor server testkit. Matcher Description shouldHaveStatus(HttpStatusCode) Tests that the response had the given http status code shouldHaveContent(content) Tests that the response has the given body `shouldHaveContentType(ContentType) Tests that the response has the given Content Type shouldHaveHeader(name, value) Tests that the response included the given name=value header shouldHaveCookie(name, value) Tests that the response included the given cookie HttpResponse The following matchers can be used against responses from the ktor http client. Matcher Description shouldHaveStatus(HttpStatusCode) Tests that the response had the given http status code `shouldHaveContentType(ContentType) Tests that the response has the given Content Type shouldHaveHeader(name, value) Tests that the response included the given name=value header shouldHaveVersion(HttpProtocolVersion) Tests that the response used the given protocol version","title":"Ktor Matchers"},{"location":"matchers/ktor/#ktor-matchers","text":"Matchers for Ktor are provided by the kotest-assertions-ktor module.","title":"Ktor Matchers"},{"location":"matchers/ktor/#test-application-response","text":"The following matchers are used when testing via the ktor server testkit. Matcher Description shouldHaveStatus(HttpStatusCode) Tests that the response had the given http status code shouldHaveContent(content) Tests that the response has the given body `shouldHaveContentType(ContentType) Tests that the response has the given Content Type shouldHaveHeader(name, value) Tests that the response included the given name=value header shouldHaveCookie(name, value) Tests that the response included the given cookie","title":"Test Application Response"},{"location":"matchers/ktor/#httpresponse","text":"The following matchers can be used against responses from the ktor http client. Matcher Description shouldHaveStatus(HttpStatusCode) Tests that the response had the given http status code `shouldHaveContentType(ContentType) Tests that the response has the given Content Type shouldHaveHeader(name, value) Tests that the response included the given name=value header shouldHaveVersion(HttpProtocolVersion) Tests that the response used the given protocol version","title":"HttpResponse"},{"location":"matchers/sql/","text":"Sql Matchers","title":"Sql"},{"location":"matchers/sql/#sql-matchers","text":"","title":"Sql Matchers"}]}